{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MAP Developer Documentation","text":"<p>Welcome to the MAP Developer Documentation.</p> <p>This site is intended to support developers, schema authors, and community contributors who are building with the MAP Type System and holonic data structures.</p> <p>MAP is designed to be:</p> <ul> <li>Self-describing \u2014 every type is a holon</li> <li>Composable \u2014 types and schemas can be extended without breaking compatibility</li> <li>Federated \u2014 schema evolution happens across a network of independently defined but interoperable types</li> </ul>"},{"location":"#getting-started","title":"\ud83e\udded Getting Started","text":"<p>This documentation is still evolving. It's initial focus is on a JSON File Authoring Guide as part of the MAP Holon Data Loader. </p> <ul> <li>Explore the type system design in the MAP wiki</li> <li>Review example import files in <code>schemas/</code> if available</li> <li>Watch this space for developer guides and schema authoring tips</li> </ul> <p>We\u2019ll be adding more structured guides and references as the project grows. Contributions are welcome.</p> <p>For licensing info, see LICENSE.md.</p>"},{"location":"core/capsulization/","title":"MAP Context-Aware Capsulization &amp; Session State Strategies \u2014 Design Spec","text":""},{"location":"core/capsulization/#0-purpose-scope","title":"0. Purpose &amp; Scope","text":"<p>This specification defines how MAP determines the appropriate capsulization strategy for a given Dance invocation based on the interaction context, and how session state is managed across contexts where state continuity cannot be assumed.</p> <p>It extends the MAP Trust Channel and Security Model specifications by describing: - Context profiles for different communication topologies. - How envelope stacks are constructed dynamically. - How session state (transient holon pools, nursery references) is shipped or resolved. - How Agreements override or refine these defaults for cross-Space exchanges.</p>"},{"location":"core/capsulization/#1-architectural-overview","title":"1. Architectural Overview","text":""},{"location":"core/capsulization/#11-context-aware-capsuleization","title":"1.1 Context-Aware Capsuleization","text":"<p>A capsuleization strategy determines which envelopes are applied around a Dance payload when building or validating a Dance Capsule. The selected strategy depends on: - The context boundary being crossed (in-process, inter-agent, or cross-space). - The trust surface (same process vs. network transport). - The state continuity (whether the callee maintains persistent context). - The Agreement defining additional envelope requirements for cross-space flows.</p> <p>Capsuleization is governed by ContextProfiles, not hard-coded paths. Each ContextProfile maps a boundary type to an ordered list of envelope kinds and defines its state-handling strategy.</p>"},{"location":"core/capsulization/#2-context-profiles","title":"2. Context Profiles","text":""},{"location":"core/capsulization/#21-profile-definition","title":"2.1 Profile Definition","text":"<p>Holon Type: <code>ContextProfile</code> Key Properties: - <code>src_env</code> / <code>dst_env</code> (TypeScript, RustHost, RustGuest, RemoteSpace) - <code>space_boundary</code> (None | SameSpace | CrossSpace) - <code>trust_surface</code> (InProcess | LocalIPC | LAN | WAN | DHT) - <code>state_strategy</code> (NoShipping | ShipSessionState) - <code>default_envelope_set</code> (ordered list of envelope kinds) - <code>gating_policy</code> (conditions for step-up or extra envelopes)</p> <p>Relationships: <pre><code>ContextProfile\n \u251c\u2500\u2500 UsesEnvelopeType \u2192 [EnvelopeType...]\n \u251c\u2500\u2500 AppliesStateStrategy \u2192 StateStrategy\n \u251c\u2500\u2500 UsesStepUpPolicy \u2192 StepUpPolicy\n \u2514\u2500\u2500 OverridesByAgreement \u2192 Agreement?\n</code></pre></p> <p>Each ContextProfile is itself a holon, discoverable and replaceable by Agreements that define custom profiles.</p>"},{"location":"core/capsulization/#22-canonical-profiles","title":"2.2 Canonical Profiles","text":"Context Boundary State Strategy Envelope Stack (inbound/outbound) Notes TypeScript \u2192 Rust (Tauri same process) None NoShipping [Unlock?], [Payload] Not a membrane; minimal capsule. Rust Host \u2192 Rust Guest (stateless guest) SameSpace ShipSessionState [Unlock?], [AuthZ?], [SessionState], [Payload] State ping-ponged; optional logical AuthZ. Space A \u2192 Space B (network/DHT) CrossSpace Configured by Agreement [Transport, AuthN, Crypto, AuthZ, Dispatch, Unlock?, SessionState?, Payload] / [Payload, Exfiltration, Crypto, AuthN, Transport] Full capsule sequence. <p>Each profile defines the expected validator order and transient state behavior for the trust surface.</p>"},{"location":"core/capsulization/#3-capsulebuilder-capsulevalidator","title":"3. CapsuleBuilder &amp; CapsuleValidator","text":""},{"location":"core/capsulization/#31-capsulebuilder","title":"3.1 CapsuleBuilder","text":"<p>Constructs Dance Capsules based on a ContextProfile (or Agreement-overridden suite).</p> <p>Steps: 1. Identify active <code>ContextProfile</code> based on src/dst environment. 2. Select the appropriate <code>ProtocolSuite</code> from Agreement (if CrossSpace). 3. Build envelope stack using <code>default_envelope_set</code>, applying:     - <code>UnlockEnvelope</code> if required by gating_policy.     - <code>SessionStateEnvelope</code> if <code>ShipSessionState</code>. 4. Pin <code>Agreement</code> and <code>ProtocolSuite</code> references. 5. Compute hash chain for envelope integrity.</p> <p>Output: a complete <code>DanceCapsule</code> ready for transport.</p>"},{"location":"core/capsulization/#32-capsulevalidator","title":"3.2 CapsuleValidator","text":"<p>Sequentially validates and unwraps envelopes according to the same ContextProfile or pinned ProtocolSuite.</p> <p>Steps: 1. Read <code>PinnedAgreement</code> / <code>NegotiatedSuite</code> (outermost layer). 2. Validate envelopes in declared order. 3. Invoke pluggable validators for each envelope type. 4. Rehydrate transient state if a <code>SessionStateEnvelope</code> is present. 5. Return the unwrapped <code>Dance</code> to the Choreographer.</p>"},{"location":"core/capsulization/#4-state-management-strategies","title":"4. State Management Strategies","text":""},{"location":"core/capsulization/#41-noshipping","title":"4.1 NoShipping","text":"<p>Use when: both ends share live memory context (e.g., TypeScript\u2194Rust). - Only references are passed; no state serialization. - All resolution occurs in host context.</p>"},{"location":"core/capsulization/#42-shipsessionstate","title":"4.2 ShipSessionState","text":"<p>Use when: the recipient is stateless (e.g., Rust Guest or remote Space). - Serialize the TransientHolonPool and NurseryRefs into a <code>SessionStateEnvelope</code>. - Validate integrity via content hash and policy (e.g., allowed reference types). - On receive, hydrate these pools in the callee\u2019s transient context.</p> <p>Holon Type: <code>SessionStateEnvelope</code> Relationships: <code>CarriesState \u2192 [TransientHolonPool, NurseryRefs]</code></p> <p>Validation rules: - <code>state_hash</code> must match computed digest. - Only whitelisted transient holon types may be shipped across a membrane. - State size thresholds enforced by policy.</p>"},{"location":"core/capsulization/#5-gating-and-step-up-policies","title":"5. Gating and Step-Up Policies","text":"<p>Each ContextProfile references a <code>StepUpPolicy</code>, which governs whether a local unlock is required.</p> <p>Triggers: - Dance sensitivity (Elevated | Critical) - Behavioral risk score \u2265 threshold - Explicit <code>require_step_up</code> flag from Agreement</p> <p>If triggered, an <code>UnlockEnvelope</code> is inserted before the Payload. The validator checks that the active Second Factor Session (SFS) is valid, unexpired, and not revoked.</p> <p>Holon Type: <code>UnlockEnvelope</code> Relationships: <code>VerifiedBy \u2192 StepUpPolicy</code></p>"},{"location":"core/capsulization/#6-agreement-overrides","title":"6. Agreement Overrides","text":"<p>Agreements can override ContextProfiles for cross-space interactions.</p> <p>Mechanism: - Agreement declares a <code>UsesContextProfile</code> relationship. - During capsule creation, the Trust Channel uses this Agreement-specific profile instead of the default one. - This allows different spaces to negotiate alternate envelope sets or state strategies.</p> <p>Example: <pre><code>Agreement \u2500\u2500UsesContextProfile\u2500\u2500\u25ba ContextProfile: secure-bridge-v2\nContextProfile.secure-bridge-v2:\n   EnvelopeStack: [Transport, AuthN, Crypto, AuthZ, Dispatch, Payload]\n   StateStrategy: NoShipping\n   StepUpPolicy: AlwaysRequire\n</code></pre></p>"},{"location":"core/capsulization/#7-session-state-envelope-flow-example","title":"7. Session State Envelope Flow Example","text":"<p>Rust Host \u2192 Rust Guest (stateless guest):</p> <p>DanceCapsule \u251c\u2500\u2500 UnlockEnvelope (if Sensitive or risky) \u2502   \u2514\u2500\u2500 SessionStateEnvelope \u2502       \u251c\u2500\u2500 CarriesState \u2192 TransientHolonPool \u2502       \u2514\u2500\u2500 Wraps \u2192 PayloadEnvelope \u2502           \u2514\u2500\u2500 HasPayloadDance \u2192 Dance \u2502               \u2514\u2500\u2500 HasRequest \u2192 LoaderHolonSegment</p> <p>Validation sequence: 1. UnlockEnvelope \u2192 verify SFS. 2. SessionStateEnvelope \u2192 validate state integrity. 3. PayloadEnvelope \u2192 execute Dance with hydrated transient context.</p>"},{"location":"core/capsulization/#8-state-resolution-rules","title":"8. State Resolution Rules","text":""},{"location":"core/capsulization/#81-transientholonpool","title":"8.1 TransientHolonPool","text":"<ul> <li>Contains staged holons awaiting persistence or relationship resolution.</li> <li>Used for Pass 1\u20132 data loader operations.</li> <li>Must not contain persistent identifiers or DHT addresses.</li> </ul>"},{"location":"core/capsulization/#82-nurseryrefs","title":"8.2 NurseryRefs","text":"<ul> <li>Lightweight handles for deferred relationship resolution.</li> <li>Hydrated during guest execution; discarded afterward.</li> </ul>"},{"location":"core/capsulization/#83-security-implications","title":"8.3 Security Implications","text":"<ul> <li>State shipping must respect Agreement-defined data-sharing limits.</li> <li>Certain value types (e.g., MapBytesValueType, MapIdValueType) may be redacted or masked when crossing membranes.</li> <li>Session state is never persisted; it expires at end of Dance execution.</li> </ul>"},{"location":"core/capsulization/#9-context-selection-logic","title":"9. Context Selection Logic","text":"<p>Algorithm for capsuleization: 1. Determine context (TS\u2192Rust, Host\u2192Guest, Space\u2194Space). 2. Load corresponding ContextProfile. 3. If Agreement present:     - Override profile with Agreement\u2019s <code>UsesContextProfile</code> if specified.     - Use <code>ProtocolSuite</code> from Agreement to determine final envelope set. 4. Apply gating_policy \u2192 insert UnlockEnvelope if required. 5. Apply state_strategy \u2192 add SessionStateEnvelope if needed. 6. Assemble and send capsule.</p> <p>This algorithm ensures capsuleization is adaptive, not static \u2014 matching security, performance, and state requirements to context.</p>"},{"location":"core/capsulization/#10-summary","title":"10. Summary","text":"<p>Context-aware capsuleization allows MAP to: - Optimize in-process Dances (minimal envelopes, no overhead). - Support stateless guests via controlled state shipping. - Enforce Agreement-defined envelope sequences for cross-space trust. - Dynamically add authentication layers when sensitivity or behavioral risk warrants it.</p> <p>By encoding these strategies as holons (<code>ContextProfile</code>, <code>StateStrategy</code>, <code>StepUpPolicy</code>), capsule formation and validation remain fully data-driven, extensible, and discoverable \u2014 consistent with MAP\u2019s self-describing architecture.</p>"},{"location":"core/connect-design/","title":"MAP Connect Dashboards: Early Design Sketches","text":"<p>\ud83d\udea7 Draft for discussion \u2014 not final. Intended to seed design conversations among MAP Core developers.</p>"},{"location":"core/connect-design/#1-connect-dashboard-offer-centric","title":"1. Connect Dashboard (Offer-Centric)","text":"<p>The primary dashboard shows aggregate data on my Offers and inbound Offers. It surfaces both state counts and actionable prompts.</p>"},{"location":"core/connect-design/#lifecycle-flow","title":"Lifecycle Flow","text":"<ul> <li>Drafts \u2014 Offers not yet placed in a Space (parked, not visible).</li> <li>Active Offers \u2014 visible in a Space, subdivided by matching state:<ul> <li>Under-constrained \u2192 too many matches; suggests requirements to add.</li> <li>Over-constrained \u2192 too few/none; suggests requirements to relax.</li> <li>Waiting for My Responses \u2192 unknowns I must answer.</li> <li>Waiting on Others \u2192 unknowns others must answer.</li> <li>Healthy Fit \u2192 matches in desired range but below Agreement threshold.</li> </ul> </li> <li>Agreement Phase \u2192 matches \u2265 Agreement Phase Threshold; ready to reveal identity and negotiate.</li> <li>Agreed / Closed \u2192 historical Offers (archived for reference).</li> </ul>"},{"location":"core/connect-design/#dashboard-interactions","title":"Dashboard Interactions","text":"<ul> <li>Click a header (e.g. \u201cOver-constrained\u201d):<ul> <li>Reveals Top 3 prompts relevant to that state.<ul> <li>For \u201cOver-constrained\u201d: top 3 requirements to consider relaxing.</li> <li>For \u201cWaiting for My Responses\u201d: top missing promises I\u2019m asked to make.</li> </ul> </li> </ul> </li> <li>Click a number (e.g. \u201c7 Over-constrained Offers\u201d):<ul> <li>Opens a Collection View of Offer Cards in that state.</li> <li>From there, I can drill into any card\u2019s Feedback Panel.</li> </ul> </li> </ul>"},{"location":"core/connect-design/#2-collection-view","title":"2. Collection View","text":"<p>Displays a grid or list of Offer Cards.</p> <p>Offer Card Preview - Title &amp; context (e.g. Service Offer, Join Offer, Space). - Status chips: \u2715 Mismatches | ? Unknowns | \u25d4 Possibles | \u2705 Matches. - Click \u2192 opens Feedback Panel.</p>"},{"location":"core/connect-design/#3-feedback-panel-card-drill-down","title":"3. Feedback Panel (Card Drill-Down)","text":"<p>When I drill into a specific Offer Card:</p> <ul> <li> <p>Status Strip</p> <ul> <li>Counts for \u2715 mismatches, ? unknowns, \u25d4 possibles, \u2705 matches.</li> </ul> </li> <li> <p>Unlocking Promises (ranked)</p> <ul> <li>Promises I could make to unlock the most matches.</li> <li>Each shows projected gain (e.g. \u201cAdd Value: Regeneration \u2192 +8 matches\u201d).</li> <li>Actions: Answer, Learn More (link to Meme Pool definition).</li> </ul> </li> <li> <p>Blocking Requirements (ranked)</p> <ul> <li>Requirements I imposed that are over-constraining.</li> <li>Each shows projected gain if relaxed (e.g. \u201cRelax Age \u2265 18 to 16 \u2192 +3 matches\u201d).</li> <li>Actions: Adjust / Relax.</li> </ul> </li> <li> <p>Next Actions</p> <ul> <li>Propose Agreement (if matches are in range).</li> <li>Reveal Identity / Open Negotiation (Agreement Phase).</li> <li>Withdraw Offer.</li> </ul> </li> <li> <p>Notifications (Sense)</p> <ul> <li>Toggle: \u201cNotify me when this Offer reaches Agreement Phase / gains new matches / gets blocked.\u201d</li> </ul> </li> </ul>"},{"location":"core/connect-design/#4-resonance-engine-dashboard-promise-centric","title":"4. Resonance Engine Dashboard (Promise-Centric)","text":"<p>A complementary dashboard for sense-making into a Space. Instead of Offers, it organizes around Promises themselves.</p>"},{"location":"core/connect-design/#what-it-surfaces","title":"What it surfaces","text":"<ul> <li>Top Resonant Promises \u2014 promises most frequently included in offers in this space.</li> <li>Aspirational Gaps \u2014 promises often required in offers but rarely present in members\u2019 LifeCodes.</li> <li>Cultural Climate Heatmap \u2014 % of members aligned with key promises (values, principles).</li> <li>Growth Prompts \u2014 promises I\u2019m being nudged to consider adding to my LifeCode to unlock more connections.</li> </ul>"},{"location":"core/connect-design/#why-it-matters","title":"Why it matters","text":"<ul> <li>Lets individuals see where they resonate with the culture of a space.</li> <li>Lets spaces see where alignment is strong or thin, and adapt over time.</li> <li>Complements the Offer-centric dashboard by showing the memetic layer of connection.</li> </ul>"},{"location":"core/connect-design/#5-design-notes","title":"5. Design Notes","text":"<ul> <li>States are mutually exclusive and clear: Draft \u2192 Active (with sub-status) \u2192 Agreement Phase \u2192 Closed.</li> <li>Top 3 prompts ensure dashboards surface actionable insights, not just numbers.</li> <li>Cross-cutting pivots: Clicking any Promise or Requirement shows both its definition (link to Meme Pool) and the collection of Offers it affects.</li> <li>Threshold awareness: Agreement Phase Threshold is explicit; exceeding it unlocks negotiation tools.</li> <li>Privacy posture: Spaces see only alignment signals; only I see my private answers.</li> </ul> <p>\ud83d\udc49 Next steps: - Align on visual language (chips, icons, color coding). - Decide whether the Resonance Engine Dashboard is part of Connect or a separate DAHN module. - Prototype the funnel dashboard + feedback flows in low-fidelity wireframes.  </p>"},{"location":"core/dances-design/","title":"MAP Design Spec: DanceType \u2194 DanceImplementation Binding &amp; Dispatch","text":"<p>Status: Draft Author: MAP Core / Steve Melville Intent: Specify how types declare dances, how implementations are bound, and how the host dispatches calls safely and dynamically.   Scope: Type system extensions, import format, governance/validation, runtime dispatch, security, caching, and compatibility with existing MAP/Holochain patterns.  </p>"},{"location":"core/dances-design/#0-foundations-assumptions","title":"0) Foundations &amp; Assumptions","text":"<ol> <li> <p>Self\u2011describing types</p> <ul> <li>All MAP types are holons described by TypeDescriptor holons.</li> <li><code>InstanceProperties</code> and <code>InstanceRelationships</code> declare expectations for instances.</li> <li>The metaschema already supports declaring new PropertyTypes and RelationshipTypes.</li> </ul> </li> <li> <p>Holon identity &amp; immutability</p> <ul> <li>Instances are immutable; newer versions create new holons.</li> <li>References are stable and do not \u201cgo stale\u201d; caches can safely retain instances until memory pressure requires eviction.</li> </ul> </li> <li> <p>Import format conventions</p> <ul> <li>Holon JSON import files use the unified <code>holons</code> array, with relationships and properties defined on each holon.</li> <li><code>$ref</code> resolution is strict within the provided file set (no implicit global context).</li> <li><code>key</code> MUST appear before <code>type</code> in each holon definition.</li> <li><code>type</code> is shorthand for a <code>DescribedBy</code> relationship and should not be duplicated unless rules require exact match.</li> </ul> </li> <li> <p>Key rules</p> <ul> <li>Some holons are keyed, some are keyless, per existing KeyRuleType semantics.</li> <li>Enum Variant holons are keyed and top-level (not embedded).</li> </ul> </li> <li> <p>Governance membranes</p> <ul> <li>Spaces (I\u2011Spaces / We\u2011Spaces) enforce admission, attestation, and activation policies for new descriptors and modules.</li> <li>Provenance and attestations are recorded as holons and/or signatures on content hashes.</li> </ul> </li> <li> <p>Runtime execution</p> <ul> <li>Host supports WASM/WASI execution and may optionally support:<ul> <li>Process (spawned executable with stream protocol),</li> <li>Rust dylib (FFI with stable ABI),</li> <li>Builtin (host-registered functions).</li> </ul> </li> <li>Single-threaded isolation for WASM execution is assumed.</li> <li>Modules are addressed by content hash and may be fetched via membrane-authorized channels.</li> </ul> </li> </ol>"},{"location":"core/dances-design/#1-conceptual-model","title":"1) Conceptual Model","text":"<p>At its heart, the MAP type system implements a dynamic dispatch model in which every type \u2014 not just <code>HolonType</code> \u2014 can advertise the behaviors it supports via fine-grained dispatch tables. These tables are essentially the per-type registries of \u201cwhat this type can do,\u201d expressed as relationships from the type descriptor to a set of DanceTypes.</p> <p>In our new terminology, we\u2019re formalizing this as:</p> <pre><code>&lt;TypeDescriptor&gt; \u2014AFFORDS\u2192 &lt;DanceType&gt;\n</code></pre>"},{"location":"core/dances-design/#dynamic-dispatch-tables","title":"Dynamic Dispatch Tables","text":"<ul> <li> <p>One per type:   Every <code>TypeDescriptor</code> can have its own dispatch table \u2014 a set of <code>Affords</code> relationships that point to the <code>DanceType</code>s it supports. This allows dispatch to be as fine-grained as needed: even closely related types can differ in the set of dances they afford.</p> </li> <li> <p>Any type can afford dances:   We don\u2019t limit affordances to <code>HolonType</code>s. <code>ValueType</code>s, <code>RelationshipType</code>s, even <code>DanceType</code>s themselves can have <code>Affords</code> links to other dances, enabling compositional and meta-level behaviors.</p> </li> <li> <p>Behavior resolution:   When the system receives a <code>DanceRequest</code> for a specific target, the dispatch mechanism:</p> <ol> <li>Identifies the type of the target holon.</li> <li>Looks up that type\u2019s <code>Affords</code> relationships.</li> <li>Matches the requested dance against the list.</li> <li>Routes execution to the handler bound to that dance for this type.</li> </ol> </li> </ul>"},{"location":"core/dances-design/#affordances-as-first-class-relationships","title":"Affordances as First-Class Relationships","text":"<ul> <li><code>Affords</code> is itself a RelationshipType holon (like all type descriptors in MAP).</li> <li>Concrete instances of <code>Affords</code> are smartlinks between a type and a dance type.</li> <li>Because <code>Affords</code> is part of the schema, it can carry metadata \u2014 version constraints, capability conditions, or even parameter hints \u2014 making affordances declarative, inspectable, and extensible.</li> </ul>"},{"location":"core/dances-design/#why-this-matters","title":"Why This Matters","text":"<ul> <li>Granularity: Instead of large, monolithic capability declarations, we get fine-grained, composable affordances that can evolve per type.</li> <li>Flexibility: Adding a new dance is a matter of creating a <code>DanceType</code> and linking it via <code>Affords</code>; no core code needs changing for schema-driven dispatch.</li> <li>Uniformity: All affordances are modeled the same way, whether they\u2019re about creating a holon, validating a property, or triggering a real-world workflow.</li> <li>Extensibility: The dispatch model is naturally open to extension in downstream schemas or spaces without schema rewrites \u2014 just add new <code>Affords</code> links.</li> </ul>"},{"location":"core/dances-design/#2-newupdated-descriptors-relationships","title":"2) New/Updated Descriptors &amp; Relationships","text":""},{"location":"core/dances-design/#21-descriptors","title":"2.1 Descriptors","text":"<ul> <li> <p>DanceType (HolonType, abstract)   The DanceType defines the interface for a single dance. This includes the dance name (by convention, this should be a verb) (e.g., <code>Render</code>, <code>Validate</code>, <code>SyncOut</code>).</p> <ul> <li>Properties (examples): <code>display_name</code>, <code>description</code>, <code>abi_id</code> (optional if polymorphic).</li> <li>Relationships:</li> <li><code>Request</code> -- to a HolonType that bundles the input parameters to the DanceRequest. </li> </ul> </li> <li> <p>DanceImplementation (Holon)   A concrete binding of a <code>DanceType</code> for a specific <code>TypeDescriptor</code>.</p> <ul> <li>Properties (required unless noted):<ul> <li><code>Engine</code> (Enum): <code>WasmWasi</code> | <code>Process</code> | <code>RustDylib</code> | <code>Builtin</code></li> <li><code>ModuleRef</code> (String): content address (e.g., <code>b3:\u2026</code> multihash, URL with hash, capability address)</li> <li><code>Entrypoint</code> (String): export/function name (WASM symbol, FFI symbol, command name)</li> <li><code>ABI</code> (String): stable ABI signature id the host supports (e.g., <code>map.dance.v1</code>)</li> <li><code>Version</code> (String): semver or content-hash pin</li> <li><code>CompatRange</code> (String, optional): semver range allowed</li> <li><code>ActivationStatus</code> (Enum): <code>proposed</code> | <code>active</code> | <code>disabled</code></li> <li><code>Scope</code> (Enum): <code>Builtin</code> | <code>SchemaDefault</code> | <code>SpaceOverride</code></li> <li><code>ModuleHash</code> (String): cryptographic hash of the content (if not implicit in ModuleRef)</li> </ul> </li> <li>Relationships:</li> <li><code>DanceType</code>-&gt;DanceType -- The Dance being implemented.</li> <li><code>AffordingType</code>-&gt; TypeDescriptor (?) the type on whose behalf this dance is being implemented</li> </ul> </li> <li> <p>(optional) DanceParameterSchema (Holon)   Describes structured inputs/outputs for ABI validation.</p> </li> </ul>"},{"location":"core/dances-design/#22-relationships","title":"2.2 Relationships","text":"<ul> <li> <p>Affords (DeclaredRelationshipType) <code>(TypeDescriptor) -[Affords]-&gt; (DanceType)</code>   Declares that instances of the type afford/expose the dance.</p> </li> <li> <p>ImplementsDance (DeclaredRelationshipType) <code>(TypeDescriptor) -[ImplementsDance]-&gt; (DanceImplementation)</code>   Binds concrete implementations available to the dispatcher.</p> </li> <li> <p>ForDance (DeclaredRelationshipType) <code>(DanceImplementation) -[ForDance]-&gt; (DanceType)</code>   The interface this implementation satisfies.</p> </li> <li> <p>(optional) ParametersSchema (DeclaredRelationshipType) <code>(DanceType) -[ParametersSchema]-&gt; (DanceParameterSchema)</code></p> </li> </ul> <p>All descriptors follow the foundational rule: <code>type: \"#TypeDescriptor\"</code> with <code>Extends</code> pointing at the appropriate meta-type, and they adopt MAP import conventions (key before type, unified relationships block, etc.).</p>"},{"location":"core/dances-design/#3-import-file-additions-examples-illustrative","title":"3) Import File Additions &amp; Examples (Illustrative)","text":"<p>Note: Examples are schematic and omit boilerplate. Use your established keys/type shorthands and naming patterns. (No code fences here; the following is raw markdown text with indentation.)</p> <p>Example A: Declaring a DanceType and parameter schema - key: <code>Render.DanceType</code> - type: <code>#DanceType</code> - properties: <code>display_name=\"Render\"</code>, <code>description=\"Produce a representation\"</code> - relationships: <code>ParametersSchema -&gt; #Render.Params.Schema</code> (optional)</p> <p>Example B: A TypeDescriptor that supports and implements a dance - key: <code>BookType.TypeDescriptor</code> - type: <code>#TypeDescriptor</code> - relationships:     - <code>Affords -&gt; #Render.DanceType</code>     - <code>ImplementsDance -&gt; #BookType.Render.WasmImpl</code> (below)</p> <p>Example C: A DanceImplementation bound to <code>BookType</code> for <code>Render</code> - key: <code>BookType.Render.WasmImpl</code> - type: <code>#DanceImplementation</code> - properties:     - <code>Engine=\"WasmWasi\"</code>     - <code>ModuleRef=\"b3hash:Qm...\"</code>     - <code>Entrypoint=\"render_book\"</code>     - <code>ABI=\"map.dance.v1\"</code>     - <code>Version=\"1.2.0\"</code>     - <code>CompatRange=\"^1.0.0\"</code>     - <code>ActivationStatus=\"active\"</code>     - <code>Scope=\"SchemaDefault\"</code>     - <code>ModuleHash=\"sha256:abcd...\"</code> - relationships:     - <code>ForDance -&gt; #Render.DanceType</code></p> <p>Space-scoped override A We\u2011Space can introduce a second implementation with <code>Scope=\"SpaceOverride\"</code> and <code>ActivationStatus=\"active\"</code>. Resolution rules (Section 5) ensure overrides take precedence without mutating the schema default.</p>"},{"location":"core/dances-design/#4-abi-application-binary-interface","title":"4) ABI (Application Binary Interface)","text":""},{"location":"core/dances-design/#41-goals","title":"4.1 Goals","text":"<ul> <li>Stable contract between host and implementation irrespective of engine.</li> <li>Enable content-addressed modules to be swapped/upgraded safely.</li> <li>Keep functions stateless and deterministic (inputs \u2192 outputs), with side effects routed through explicit host calls (capability-gated).</li> </ul>"},{"location":"core/dances-design/#42-core-shape-mapdancev1","title":"4.2 Core shape (<code>map.dance.v1</code>)","text":"<ul> <li>Inputs<ul> <li><code>dance_type_id</code> (ref)</li> <li><code>type_descriptor_id</code> (ref)</li> <li><code>instance_refs</code> (list of holon ids or $ref proxies)</li> <li><code>parameters</code> (bytes or canonical JSON/CBOR)</li> <li><code>context</code> (agent id, space id, capability token, call chain, clock)</li> </ul> </li> <li>Outputs<ul> <li><code>status</code> (OK | Error(code))</li> <li><code>result</code> (bytes or canonical JSON/CBOR)</li> <li><code>emitted_events</code> (optional; for telemetry)</li> </ul> </li> <li>Host imports<ul> <li><code>holon_fetch(id)</code> \u2192 bytes</li> <li><code>relationship_query(query)</code> \u2192 ids</li> <li><code>attest(proof)</code> \u2192 receipt</li> <li><code>emit(event)</code> \u2192 ack</li> <li>(All host functions are capability-gated and audited.)</li> </ul> </li> </ul>"},{"location":"core/dances-design/#43-serialization-determinism","title":"4.3 Serialization &amp; determinism","text":"<ul> <li>Canonical encoding (CBOR or JSON Canonical Form).</li> <li>No host clock access except via provided <code>context</code>.</li> <li>No ambient I/O except via host-imported capabilities.</li> </ul>"},{"location":"core/dances-design/#5-dispatch-algorithm-host","title":"5) Dispatch Algorithm (Host)","text":"<p>Given a request <code>(T, D, ctx)</code>:</p> <ol> <li>Affordance check: Ensure <code>T Affords D</code>; otherwise fail with <code>NotSupported(T,D)</code>.</li> <li>Collect candidates: <code>C = { impl | T ImplementsDance impl \u2227 impl ForDance = D \u2227 impl ActivationStatus=active }</code>.</li> <li>Select binding (deterministic precedence):<ul> <li>Prefer <code>Scope=\"SpaceOverride\"</code> in <code>ctx.space</code> &gt; <code>SchemaDefault</code> &gt; <code>Builtin</code>.</li> <li>Prefer exact <code>Version</code> pin &gt; satisfied <code>CompatRange</code> &gt; latest compatible by semver.</li> <li>Optional: apply policy filter (agent role, license/flowshare rules, allowlist).</li> <li>If multiple remain, choose lexicographically by <code>(Version, ModuleHash)</code> or policy-defined tiebreaker.</li> </ul> </li> <li>Load &amp; cache:<ul> <li>Fetch module by <code>ModuleRef</code> (verify <code>ModuleHash</code>, signatures, provenance).</li> <li>Instantiate per engine; reuse cached instance if ABI/spec allows (see lifecycle).</li> </ul> </li> <li>Invoke:<ul> <li>Marshal inputs to ABI.</li> <li>Call <code>Entrypoint</code>.</li> <li>Enforce time/memory fuel limits and capability quotas.</li> </ul> </li> <li>Validate &amp; return:<ul> <li>Check ABI contract on outputs.</li> <li>Apply membrane \u201cexfiltration filter\u201d (response validation &amp; redaction as promised).</li> <li>Return <code>DanceResponse</code>.</li> </ul> </li> </ol> <p>Error handling: Produce structured errors: <code>NotSupported</code>, <code>NoActiveImpl</code>, <code>ABIIncompatible</code>, <code>ModuleFetchFailed</code>, <code>SignatureInvalid</code>, <code>PolicyDenied</code>, <code>EngineError</code>, <code>Timeout</code>, <code>MemoryLimit</code>, <code>ResultValidationFailed</code>.</p>"},{"location":"core/dances-design/#6-module-lifecycle-caching-eviction","title":"6) Module Lifecycle, Caching, Eviction","text":"<ul> <li>Cache keys: <code>(Engine, ModuleHash, ABI)</code>; instance-specific caches may include <code>(SpaceId)</code> when overrides alter host imports.</li> <li>Warm: LRU or LFU for frequently used modules; prewarm on activation if policy allows.</li> <li>Evict: Under memory pressure, evict least-recently-used; keep provenance index regardless.</li> <li>Isolation: WASM instances single-threaded; no shared mutable state across invocations.</li> <li>Pure-function posture: Dances are stateless; all state arrives as inputs or accessed through explicit host capabilities.</li> </ul>"},{"location":"core/dances-design/#7-governance-licensing-and-flowshare-hooks","title":"7) Governance, Licensing, and Flowshare Hooks","text":"<ul> <li> <p>Activation workflow:</p> <ul> <li>A <code>DanceImplementation</code> arrives with <code>ActivationStatus=\"proposed\"</code>.</li> <li>Membrane policy may require two-key attest (Steward of <code>T</code> + Space Admin) and automated checks (hash, signature, license).</li> <li>On success, flip to <code>active</code> (space-scoped or schema default).</li> </ul> </li> <li> <p>Flowshare attachment:</p> <ul> <li>Implementations/Types may declare a ValueFlowPolicy holon that expresses revenue/reciprocity terms (e.g., non-extractive use-permitted; reciprocal flowshare when vital capitals exchanged).</li> <li>Dispatcher records <code>(T, D, impl_id)</code> in telemetry for downstream settlement.</li> </ul> </li> <li> <p>Non-extractive licensing posture:</p> <ul> <li>Free use in non-commercial/gift contexts remains unaffected.</li> <li>When reciprocal value flows are detected (per policy integration), contributors participate according to warrants/agreements.</li> </ul> </li> </ul>"},{"location":"core/dances-design/#8-validation-rules-import-time-and-activation-time","title":"8) Validation Rules (Import-time and Activation-time)","text":"<p>Import-time (schema-level) - <code>supports-impl-consistency</code>: If <code>(T ImplementsDance impl)</code> then <code>(impl ForDance) \u2208 (T Affords)</code>. Error otherwise. - <code>single-active-impl</code>: For each <code>(T, D, scope)</code>, at most one <code>ActivationStatus=\"active\"</code>. Error otherwise. - <code>engine-fields-required</code>: Property presence by engine:     - <code>WasmWasi</code> \u21d2 <code>ModuleRef</code>, <code>Entrypoint</code>, <code>ABI</code>     - <code>Process</code> \u21d2 <code>ModuleRef</code>, <code>ABI</code> (and <code>Entrypoint</code> if multiplexed)     - <code>RustDylib</code> \u21d2 <code>ModuleRef</code>, <code>Entrypoint</code>, <code>ABI</code>     - <code>Builtin</code> \u21d2 <code>Entrypoint</code>, <code>ABI</code> - <code>instance-type-kind-matches-extended-meta-type-name</code>: Continue enforcing your existing meta/type-kind rules.</p> <p>Activation-time (runtime policy) - <code>abi-compat</code>: <code>impl.ABI</code> supported by host. - <code>module-integrity</code>: <code>ModuleHash</code> matches fetched bytes; signatures and attestations verified. - <code>policy-eligibility</code>: Space policy permits activation (governance roles, allowlists, flowshare acceptance). - <code>parameters-schema-match</code> (optional): <code>parameters</code> conform to <code>DanceParameterSchema</code>.</p>"},{"location":"core/dances-design/#9-security-provenance-and-audit","title":"9) Security, Provenance, and Audit","text":"<ul> <li>Content addressing: <code>ModuleRef</code> and <code>ModuleHash</code> cryptographically bind code identity.</li> <li>Signatures: Contributors sign module manifests; Spaces countersign activation.</li> <li>Reproducibility: Prefer reproducible builds; include build-info holon.</li> <li>Supply chain: Maintain provenance graph from source \u2192 build \u2192 artifact; store as holons.</li> <li>Audit trail: Every dispatch logs <code>(timestamp, agent, space, T, D, impl_id, module_hash, status, duration, fuel_used)</code>.</li> </ul>"},{"location":"core/dances-design/#10-engines-host-integrations","title":"10) Engines &amp; Host Integrations","text":"<ul> <li> <p>WASM/WASI (preferred):</p> <ul> <li>Deterministic execution with resource caps (fuel, memory).</li> <li>Host imports expose capability-guarded functions.</li> <li>Versioned ABI adapters <code>map.dance.v1</code>, <code>v2</code>, \u2026 allow evolution.</li> </ul> </li> <li> <p>Process:</p> <ul> <li>IPC over stdin/stdout with canonical envelope.</li> <li>Strong isolation; higher overhead.</li> </ul> </li> <li> <p>Rust dylib:</p> <ul> <li>Stable FFI surface identical to ABI envelope.</li> <li>Platform coupling; reserved for controlled deployments.</li> </ul> </li> <li> <p>Builtin:</p> <ul> <li>Registered host handlers for critical hot paths.</li> <li>Still declared as <code>DanceImplementation</code> with <code>Scope=\"Builtin\"</code> for traceability.</li> </ul> </li> </ul>"},{"location":"core/dances-design/#11-performance-considerations","title":"11) Performance Considerations","text":"<ul> <li>Cold-start: Prewarm frequently-used <code>(T,D)</code> in background when allowed by policy.</li> <li>Batching: Allow vectorized invocation (<code>Render</code> for many instances) when ABI supports arrays.</li> <li>Streaming: Optional chunked results for large outputs (with exfiltration filter applied per chunk).</li> <li>Caching: Separate caches for (a) holons (state), (b) modules (code), (c) relationships (indices).</li> </ul>"},{"location":"core/dances-design/#12-compatibility-migration","title":"12) Compatibility &amp; Migration","text":"<ul> <li> <p>Holochain conductor:</p> <ul> <li>Aligns with zome WASM loading (single-threaded WASM, dynamic dispatch).</li> <li>This spec generalizes beyond zomes by attaching behavior to any TypeDescriptor.</li> </ul> </li> <li> <p>Incremental rollout:     1) Introduce descriptors/relationships with validators, no runtime usage.     2) Implement host-side dispatcher with <code>WasmWasi</code> only.     3) Add governance activation path and telemetry.     4) Add overrides (<code>SpaceOverride</code>) and precedence rules.     5) (Optional) Add <code>Process</code>/<code>RustDylib</code> engines.</p> </li> </ul>"},{"location":"core/dances-design/#13-open-questions","title":"13) Open Questions","text":"<ul> <li>ABI evolution: Which fields must be strictly stable vs. adapter-shimmed?</li> <li>Parameter schemas: Standardize on JSON Schema vs. ValueType holons?</li> <li>Multi-impl composition: Should a dance support ordered pipelines/compose-many?</li> <li>Sandbox capability surface: Minimum viable host imports per dance category?</li> <li>Flowshare metering: Best trigger points to detect \u201creciprocal value\u201d reliably and fairly?</li> </ul>"},{"location":"core/dances-design/#14-acceptance-criteria","title":"14) Acceptance Criteria","text":"<ul> <li>Types can declare <code>Affords</code> and bind one or more <code>DanceImplementation</code>s.</li> <li>Host can resolve <code>(T,D)</code> to an active implementation deterministically and execute it through <code>map.dance.v1</code> ABI.</li> <li>Import-time validators catch misconfigurations; activation-time checks enforce integrity and policy.</li> <li>Telemetry records every dispatch with provenance, enabling governance and (optional) flowshare settlement.</li> </ul>"},{"location":"core/dances-design/#15-risks-mitigations","title":"15) Risks &amp; Mitigations","text":"<ul> <li>Complexity creep \u2192 Keep dispatcher minimal; push variability to data + ABI.</li> <li>Security of third-party code \u2192 Content hashing, signatures, sandboxing, capability gates, resource caps.</li> <li>Version skew \u2192 Semantic ranges with explicit pins; strong precedence rules; safe fallbacks.</li> <li>Memory growth \u2192 LRU/LFU eviction, per-engine instance pooling, prewarm limits.</li> </ul>"},{"location":"core/dances-design/#16-next-steps","title":"16) Next Steps","text":"<ol> <li>Add new descriptors and relationships to the metaschema &amp; base-core import files.</li> <li>Implement import-time validation rules listed above.</li> <li>Define <code>map.dance.v1</code> ABI envelope precisely (field names, encoding, error codes).</li> <li>Build the host dispatcher (WASM/WASI path first) + module cache.</li> <li>Implement governance activation flows and attest capture.</li> <li>Instrument telemetry and add audit holons.</li> <li>Ship example: <code>BookType</code> with <code>Render</code> dance (schema default) and a Space-scoped override.</li> </ol>"},{"location":"core/holon-data-loader-design-spec/","title":"MAP Holon Data Loader Design Specification (Updated)","text":"<p>The Holon Data Loader will convert holon data presented in JSON files into Holons and HolonRelationships that are staged and committed to a (single) MAP Space using existing MAP APIs. Because all MAP types (e.g., PropertyType, HolonType, RelationshipType) are themselves holons, the Holon Data Loader can be used to load TypeDescriptors just like any other data \u2014 eliminating the need for a separate type-specific loader. Input files are syntactically validated against a JSON Schema to ensure they represent well-formed holons, properties, relationships and, eventually, dances.</p> <p>Validation of imported holons and their properties and relationships against their Type Descriptors is triggered by standard Holochain validation callbacks. These callback functions, implemented in the <code>holons_integrity_zome</code> invoke shared validation functions to actually perform the validations. All Holochain dependencies are isolated in the integrity zome so that the shared validation functions have no holochain dependencies.</p> <p>If the target space does not already contain all required TypeDescriptors (e.g., BookType, title, HAS_AUTHOR), they must be included as part of the import and loaded first. Since we do not yet have deployed instances of the MAP that persist data, all types and data required for an integration Test Case must be loaded as part of the test case itself. This includes importing the MAP Schema. Thus, the test case initialization includes the following steps:</p> <ol> <li>Import MAP Meta-Schema</li> <li>Import MAP Core Schema</li> <li>Import Domain-Specific Type Descriptors (if any)</li> <li>Import Domain-Specific Data (if any)</li> </ol> <p>All four test steps use the same Holon Data Loader. Each step imports the type descriptors needed to validate the data imported in the subsequent step.</p>"},{"location":"core/holon-data-loader-design-spec/#process-overview","title":"\ud83e\udde9 Process Overview","text":"<p>The following diagram shows the Holon Data Loading process.</p> <p></p>"},{"location":"core/holon-data-loader-design-spec/#step-by-step-map-holon-data-loader-flow","title":"\ud83e\udded Step-by-Step: MAP Holon Data Loader Flow","text":"<ol> <li> <p>Define Holons in Airtable -- For now, we are using Airtable as our source of truth for data imports. A user or domain expert defines holons, properties, and relationships as rows in a spreadsheet-like interface. NOTE: This is just one option \u2014 other JSON generation methods are possible.</p> </li> <li> <p>Export CSV from Airtable -- Airtable exports the holon definitions into a CSV file, which contains structured tabular data for each holon, including properties, types, and relationships.</p> </li> <li> <p>Convert CSV to JSON -- A Jupyter Notebook (written in Python) loads the CSV file and uses the MAP Holon JSON Generator to transform the rows into JSON-formatted Holon Definitions. These definitions conform to the MAP Holon Data Loader's expected schema.</p> </li> <li> <p>Run the JSON Schema Validator -- Before loading, the generated JSON input file is validated using a JSON Schema Validator. This ensures that the file:</p> </li> <li>Is structurally valid</li> <li>Uses valid type names and relationship formats</li> </ol> <p>The validated file represents well-formed Holons, Properties, and Relationships.</p> <ol> <li> <p>Parse and Prepare Holons  -- The validated JSON is parsed into in-memory data structures. The Holon Generator builds internal <code>HolonImportSpec</code> structs from the parsed data.</p> </li> <li> <p>Invoke the Holon Data Loader -- The Holon Generator passes the structured holon definitions to the Holon Data Loader, a Rust crate. This loader:</p> </li> <li>Handles all staging and relationship resolution</li> <li> <p>Works for both instance data and TypeDescriptors</p> </li> <li> <p>(Optional) Other Data Loaders -- Other data loaders may bypass JSON entirely and produce Rust-structured holon definitions directly. These are also accepted by the Holon Data Loader pipeline.</p> </li> <li> <p>Stage Holons -- The loader performs Pass 1, where each holon is:</p> </li> <li>Assigned a local ID or temp key</li> <li>Validated for syntactic structure</li> <li> <p>Staged with its properties only (relationships deferred)</p> </li> <li> <p>Stage Relationships -- The loader performs Pass 2, resolving all deferred relationships:</p> </li> <li>References to staged holons use <code>temp_key</code></li> <li>References to saved holons use keys or HolonIds</li> <li> <p>External references resolve via space proxies</p> </li> <li> <p>Commit Holons -- All staged holons are committed into the MAP space via the <code>holons_core</code> crate. This action triggers holochain\u2019s commit lifecycle.</p> </li> <li> <p>Trigger Validation -- As part of the commit, the Holochain Conductor invokes validation actions. These hit the HolonNode Validation Hooks in the <code>holons_integrity_zome</code>. The implementation of these hook functions converts the data into \"holochain-independent\" data structures in order to invoke the shared validation functions.</p> </li> <li> <p>Run Shared Validation Logic The hooks delegate to the Shared Holons Validator, which contains:</p> </li> <li>Validation against TypeDescriptors</li> <li>Enforcement of required properties and cardinalities</li> <li>No direct Holochain dependencies \u2014 enabling reuse of these validations from holons_core without pulling in holochain and its dependencies.</li> </ol>"},{"location":"core/holon-data-loader-design-spec/#design-philosophy","title":"\ud83e\udde0 Design Philosophy","text":"Principle Description Holonic Uniformity Everything \u2014 including types \u2014 is a holon Self-Describing Types The <code>type</code> and <code>key</code> fields provide identity and classification Declarative Imports Inverse relationships and embedded holons may be expressed naturally Keyed Reference Integrity Only keyed holons may be targeted by <code>$ref</code> Two-Pass Import Enables circular references and loose ordering in authoring Minimal, Consistent Format Supports both human authoring and automated generation"},{"location":"core/holon-data-loader-design-spec/#keyed-vs-keyless-holons","title":"\ud83d\udccc Keyed vs Keyless Holons","text":"<p>MAP distinguishes two structural categories of holons:</p> Feature Keyed Holons Keyless Holons Includes <code>key</code> \u2705 Yes \u274c No Unique within space \u2705 Yes \u274c Not applicable Can be referenced via <code>$ref</code> \u2705 Yes \u274c No Must be embedded in JSON \u274c Optional \u2705 Required Can be target of declared relationship \u2705 Yes \u274c No Must declare outgoing relationship to keyed holon \u274c Optional \u2705 Required <ul> <li>Keyed holons include a stable <code>key</code> (materialized from properties) and may be referenced by other holons via <code>$ref</code>.</li> <li>Keyless holons are contextual and must be embedded as part of another holon\u2019s relationship. They must not be referenced or stand alone.</li> </ul> <p>This pattern ensures clean graph semantics, staging integrity, and simplicity for authors.</p>"},{"location":"core/holon-data-loader-design-spec/#declared-vs-inverse-relationships-in-json","title":"\ud83d\udd01 Declared vs Inverse Relationships in JSON","text":"<p>MAP represents both Declared and Inverse relationships using SmartLinks, but only Declared Relationships are:</p> <ul> <li>Explicitly defined in schemas</li> <li>Directly populated and persisted</li> </ul> <p>Inverse Relationships are: - Inferred by the system - Automatically maintained as mirrors of their declared counterparts - Not directly writable in the storage layer</p>"},{"location":"core/holon-data-loader-design-spec/#ergonomic-authoring-support","title":"\u2728 Ergonomic Authoring Support","text":"<p>To improve JSON authoring, the Holon Data Loader supports:</p> <p>\u2705 Expressing inverse relationships in JSON \u2014 which are then automatically rewritten into their declared equivalents before staging</p> <p>For example, a JSON snippet like:</p> <pre><code>{\n  \"type\": \"#Schema\",\n  \"key\": \"LibrarySchema\",\n  \"relationships\": [\n    { \"name\": \"Components\", \"target\": [{ \"$ref\": \"BookType\" }] }\n  ]\n}\n</code></pre> <p>will be rewritten internally to:</p> <pre><code>{\n  \"type\": \"#BookType\",\n  \"relationships\": [\n    { \"name\": \"ComponentOf\", \"target\": { \"$ref\": \"LibrarySchema\" } }\n  ]\n}\n</code></pre> <p>This preserves the storage model while making authoring more intuitive.</p> <p>\ud83d\uded1 Note: If both directions of a relationship pair are expressed in the same import file, the loader will raise a warning or error.</p>"},{"location":"core/holon-data-loader-design-spec/#json-import-file-structure","title":"\ud83d\udcc2 JSON Import File Structure","text":"<p>Details about JSON formatting, required fields, reference expressions (<code>$ref</code>), embedded holons, and schema validation rules have been moved to the Holon Data Loader Guide.</p> <p>See: Holon Data Loader Guide \u2013 Authoring Valid JSON Files</p>"},{"location":"core/holon-data-loader-design-spec/#validation-lifecycle","title":"\ud83d\udd0d Validation Lifecycle","text":"<p>The Holon Data Loader and MAP system use multiple layers of validation to ensure correctness, schema alignment, and safe persistence.</p>"},{"location":"core/holon-data-loader-design-spec/#1-schema-validation-pre-load","title":"1. Schema Validation (Pre-Load)","text":"<p>Before holons are even staged, input files are validated using JSON Schema:</p> <ul> <li>The loader always begins by validating imports against the <code>bootstrap-import.schema.json</code> schema. This schema ensures:<ul> <li>Holons are properly structured</li> <li>Properties are well-formed</li> <li>Relationship targets follow required structure</li> <li>No invalid reference forms are present (e.g., unkeyed <code>$ref</code> targets)</li> </ul> </li> </ul>"},{"location":"core/holon-data-loader-design-spec/#cascading-schema-validation","title":"\ud83e\uddec Cascading Schema Validation","text":"<p>After loading the MAP Meta-Schema, additional JSON Schemas can be generated automatically for downstream validation:</p> <ul> <li>Meta-Schema \u2192 Used to validate Core Type imports (e.g., PropertyType, ValueType)</li> <li>Core Schema \u2192 Used to validate Domain-Specific Schema files</li> <li>Domain Schema \u2192 Used to validate Domain-Specific Data files</li> </ul> <p>This allows every import layer to be validated against a holon-based, introspected schema, enforcing MAP type rules long before runtime.</p>"},{"location":"core/holon-data-loader-design-spec/#2-runtime-validation-post-commit","title":"2. Runtime Validation (Post-Commit)","text":"<p>After holons are committed, Holochain's Conductor orchestrates the integrity checks by invoking validation callbacks defined in the <code>map_holons_integrity</code> zome.</p> <p>\u2757 Holons do not themselves trigger validation \u2014 the request to persist a holon causes the Conductor to invoke validation logic.</p> <p>The validation callbacks: - Receive Holochain-native types like <code>Record</code>, <code>Link</code>, <code>ActionHash</code> - Convert these into MAP-native, Holochain-independent structures:     - <code>Holon</code>     - <code>HolonRelationships</code>     - <code>LocalId</code>, etc.</p> <p>These converted forms are passed to shared validation functions (in <code>holons_core</code>) that enforce:</p> <ul> <li>Required and optional property rules</li> <li>Cardinality constraints on relationships</li> <li>Reference resolution and type compatibility</li> <li>Key and relationship uniqueness</li> <li>Schema-defined constraints (e.g., min/max values, enum values, etc.)</li> </ul> <p>This design allows the same validation logic to be reused across client tools, data loaders, and runtime validation \u2014 avoiding duplication and enabling introspection.</p>"},{"location":"core/holon-data-loader-design-spec/#3-loader-level-validations","title":"3. Loader-Level Validations","text":"<p>The Holon Data Loader performs additional checks during staging:</p> <ul> <li>Ensures no inverse relationship appears more than once (after rewriting)</li> <li>Validates that all <code>$ref</code> targets resolve to keyed holons or embedded holons</li> <li>Rejects direct references to keyless holons</li> <li>Ensures that all keyless holons are:<ul> <li>Embedded as relationship targets</li> <li>The source of at least one declared relationship</li> </ul> </li> <li>Ensures that keys (when present) are unique within the load scope</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#staging-and-commit-process","title":"\ud83d\udcbe Staging and Commit Process","text":""},{"location":"core/holon-data-loader-design-spec/#pass-1-stage-holons","title":"Pass 1: Stage Holons","text":"<ul> <li>Create in-memory Holon stubs for each input</li> <li>Only properties are staged; relationships are deferred</li> <li>Holons must include <code>type</code> (and <code>key</code>, if keyed)</li> <li>Relationships are stored for Pass 2</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#pass-2-stage-relationships","title":"Pass 2: Stage Relationships","text":"<ul> <li>Resolve all <code>relationships</code> from JSON</li> <li>References are resolved by <code>$ref</code>, <code>Type:Key</code>, or embedded inline</li> <li>Inverse relationships are rewritten to their declared form</li> <li>Embedded keyless holons are inlined into source holon relationships</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#commit-and-validate","title":"Commit and Validate","text":"<ul> <li>After all holons are staged, the loader invokes <code>holons_core</code> to commit</li> <li>Holochain callbacks are triggered</li> <li>Shared validation logic enforces type rules</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#schema-loading","title":"Schema Loading","text":"<p>As noted previously, the</p> Programming Concept MAP Base Type MAP <code>type_kind</code> <code>String</code> <code>MapStringValueType</code> <code>ValueString</code> <code>bool</code> <code>MapBooleanValueType</code> <code>ValueBoolean</code> <code>i64</code> / <code>number</code> <code>MapIntegerValueType</code> <code>ValueInteger</code> <code>Vec&lt;u8&gt;</code> / base64 <code>MapBytesValueType</code> <code>ValueBytes</code> Enum (string symbol) <code>MapEnumValueType</code> <code>ValueEnum</code> Holon descriptor <code>MapHolonType</code> <code>Holon</code> Relationship descriptor <code>MapRelationshipType</code> <code>Relationship</code> Property descriptor <code>MapPropertyType</code> <code>Property</code>"},{"location":"core/holon-data-loader-design-spec/#future-enhancements","title":"\ud83d\udd2e Future Enhancements","text":"<ul> <li>Add schema-based authoring for enum types, constraint types, and complex nested holons</li> <li>Expand support for symbolic references (<code>DanceRequest</code>)</li> <li>Enhance loader validation to support contextual awareness of target schemas</li> <li>Support streaming JSON parsing for very large imports</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#summary","title":"\ud83d\udcce Summary","text":"<p>The Holon Data Loader is the universal import engine for MAP Types and Instances. It supports:</p> <ul> <li>Bootstrap loading of MAP Meta-Schema and Core Schema</li> <li>Domain-specific extension imports</li> <li>Declarative instance creation with ergonomic syntax</li> <li>Unified graph population using a two-pass process</li> <li>Rewriting of inverse relationships for intuitive JSON authoring</li> <li>Holochain-independent shared validation</li> </ul> <p>Authors and tool builders can rely on a consistent, minimal JSON format while benefiting from full MAP introspection, validation, and schema enforcement.</p> <p>See also: Holon Data Loader Guide for JSON authoring rules and examples.</p>"},{"location":"core/holon-data-loader-design-spec/#obsolete-content","title":"========== OBSOLETE CONTENT ==============","text":"<p>Everything after this point is left-over from prior versions are targeted to be deleted.</p>"},{"location":"core/holon-data-loader-design-spec/#json-file-structure","title":"\ud83d\udd0e JSON File Structure","text":"<p>A JSON import file contains two top-level keys:</p> <pre><code>{\n   \"meta\": {\"... },\n   \"holons\": [ { ... }, { ... }, ... ]\n}\n</code></pre> <ul> <li><code>meta</code> contains metadata about the import (version, author, etc.).</li> <li><code>holons</code> contains the list of holons to be imported.</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#holon-structure","title":"Holon Structure","text":"<p>Each holon in the <code>holons</code> list is represented as a JSON object with the following keys:</p> <ul> <li><code>type</code> (string): Fully qualified <code>$ref</code> to the holon's type (e.g., <code>\"#MapStringValueType\"</code>). Replaces the older <code>DescribedBy</code> pattern.</li> <li><code>key</code> (optional): A unique identifier if the holon is keyed.</li> <li><code>temp_key</code> (optional): A temporary key for referencing other holons within the same import file.</li> <li><code>properties</code>: A map of property name to typed value.</li> <li><code>relationships</code>: A list of relationship objects, each containing:</li> <li><code>name</code>: Relationship name</li> <li><code>target</code>: Either a <code>$ref</code> string or an embedded holon</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#key-design-rules","title":"\ud83d\udd0e Key Design Rules","text":""},{"location":"core/holon-data-loader-design-spec/#type-implies-describedby","title":"\u2705 <code>type</code> Implies <code>DescribedBy</code>","text":"<ul> <li>Every holon must specify a <code>type</code> using <code>#Key</code> syntax.</li> <li>This replaces the need for an explicit <code>DescribedBy</code> relationship.</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#use-components-instead-of-iscomponentof","title":"\u2705 Use <code>Components</code> Instead of <code>IsComponentOf</code>","text":"<ul> <li>All imported holons are children of a <code>MapSchemaType</code> holon.</li> <li>The <code>Components</code> relationship replaces <code>IsComponentOf</code>.</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#declare-useskeyrule-for-keyed-holons","title":"\u2705 Declare <code>UsesKeyRule</code> for Keyed Holons","text":"<p>Each keyed holon must include a relationship: <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": {\n    \"type\": \"#FormatKeyRule\",\n    \"properties\": {\n      \"format\": \"$0\",\n      \"property_names\": [\"type_name\"]\n    }\n  }\n}\n</code></pre></p>"},{"location":"core/holon-data-loader-design-spec/#fully-qualified-keys-for-relationship-types","title":"\u2705 Fully Qualified Keys for Relationship Types","text":"<p>Use a <code>key</code> such as: <pre><code>(HolonType)-[DescribedBy]-&gt;(TypeDescriptor)\n</code></pre> This prevents ambiguity and supports inverse resolution.</p>"},{"location":"core/holon-data-loader-design-spec/#ref-is-the-only-reference-format","title":"\u2705 <code>$ref</code> Is the Only Reference Format","text":"<p>Reference targets in relationships must use <code>$ref</code> strings, such as: - <code>#temp-key</code> - <code>Type:Key</code> - <code>id:&lt;HolonId&gt;</code> - <code>@Proxy:Type:Key</code> - <code>ext:&lt;ProxyId&gt;:&lt;LocalId&gt;</code></p>"},{"location":"core/holon-data-loader-design-spec/#data-loader-flow","title":"\ud83d\udcca Data Loader Flow","text":"<ol> <li>Author Holons \u2013 Use Airtable or any editor</li> <li>Convert to JSON \u2013 Jupyter notebook or custom tool</li> <li>Validate \u2013 Run against JSON Schema</li> <li>Parse \u2013 Create internal <code>HolonImportSpec</code> structs</li> <li>Pass 1: Stage Holons<ul> <li>Assign temp_keys and validate shape</li> <li>Properties only; defer relationships</li> </ul> </li> <li>Pass 2: Stage Relationships<ul> <li>Resolve references using <code>$ref</code></li> </ul> </li> <li>Commit \u2013 Insert holons via <code>holons_core</code></li> <li>Validate \u2013 Trigger integrity zome and shared validators</li> </ol>"},{"location":"core/holon-data-loader-design-spec/#example-holon-with-relationships","title":"\ud83d\udd01 Example Holon with Relationships","text":"<pre><code>{\n  \"type\": \"#BookType\",\n  \"temp_key\": \"book-001\",\n  \"properties\": {\n    \"title\": { \"type\": \"#MapStringValueType\", \"value\": \"Future Primal\" }\n  },\n  \"relationships\": [\n    { \"name\": \"AUTHORED_BY\", \"target\": { \"$ref\": \"PersonType:charles-eisenstein\" } },\n    { \"name\": \"MENTORED_BY\", \"target\": { \"$ref\": \"#mentor-temp-001\" } }\n  ]\n}\n</code></pre>"},{"location":"core/holon-data-loader-design-spec/#meta-modeling-relationship-types","title":"\ud83c\udf93 Meta-Modeling: Relationship Types","text":""},{"location":"core/holon-data-loader-design-spec/#primary-vs-inverse-relationship-types","title":"\u2709\ufe0f Primary vs. Inverse Relationship Types","text":"<p>Use two types: - <code>MetaPrimaryRelationshipType</code>: explicitly declared by source - <code>MetaInverseRelationshipType</code>: inferred only</p>"},{"location":"core/holon-data-loader-design-spec/#inverse-links","title":"\ud83d\udd01 Inverse Links","text":"<p>Each relationship holon must link to its inverse using: <pre><code>{\n  \"name\": \"InverseOf\",\n  \"target\": { \"$ref\": \"#OtherRelationshipType\" }\n}\n</code></pre></p> <p>Only primary relationships are listed in <code>PRIMARY_SOURCE_FOR</code> of the source HolonType.</p>"},{"location":"core/holon-data-loader-design-spec/#key-rules-for-relationship-types","title":"\ud83d\udcc4 Key Rules for Relationship Types","text":"<pre><code>{\n  \"format\": \"($0)-[$1]-&gt;($2)\",\n  \"property_names\": [\"source_type\", \"type_name\", \"target_type\"]\n}\n</code></pre> <p>This ensures uniqueness and proper <code>$ref</code> resolution.</p>"},{"location":"core/holon-data-loader-design-spec/#validation-overview","title":"\ud83e\udd1d Validation Overview","text":"<ul> <li>Holon validation happens via Holochain callbacks</li> <li>Type validation uses shared holochain-independent logic</li> <li><code>$ref</code> entries must resolve in Pass 2 or trigger errors</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#design-philosophy_1","title":"\ud83c\udf10 Design Philosophy","text":"Principle Description Holonic Uniformity Everything (types, rules, instances) is a holon Self-Describing <code>type</code> and <code>key</code> provide all descriptor info Keyed Reference Integrity No reference unless <code>key</code> or <code>temp_key</code> defined Two-Pass Import Enables circular refs and easy authoring Minimal Format Concise JSON with embedded metadata"},{"location":"core/holon-data-loader-design-spec/#next-steps","title":"\ud83d\udd2e Next Steps","text":"<ul> <li>Add section on symbolic references via <code>DanceRequest</code></li> <li>Add schema examples for EnumType, PropertyType, etc.</li> <li>Publish complete reference <code>bootstrap-import.schema.json</code></li> </ul> <p>\u2e3b</p>"},{"location":"core/i18n-design-spec/","title":"Internationalization Design Spec","text":""},{"location":"core/i18n-design-spec/#map-internationalization-localized-holons-design","title":"\ud83c\udf0d MAP Internationalization &amp; Localized Holons Design","text":"<p>Version: August 2025 Status: Rough Consensus Architecture</p>"},{"location":"core/i18n-design-spec/#1-overview","title":"1. Overview","text":"<p>MAP\u2019s internationalization (i18n) model uses fully localized holons to support multilingual content and context-specific knowledge representation. Rather than extracting localized strings into separate holons or defining a specialized type, each holon is a complete locale-specific instance of a <code>HolonType</code>.</p> <p>Localization is modeled via relationships and properties directly on the core <code>HolonType</code>, enabling consistent treatment of localized holons as first-class data entities.</p>"},{"location":"core/i18n-design-spec/#terminology-internationalization-vs-localization","title":"\ud83e\udded Terminology: Internationalization vs. Localization","text":""},{"location":"core/i18n-design-spec/#internationalization-i18n","title":"Internationalization (i18n)","text":"<p>Internationalization is the process of designing software and data models in a way that makes them adaptable to multiple languages, regions, and cultures without requiring engineering changes for each new locale.</p> <p>In the context of MAP: - Internationalization enables holons to be stored, queried, and presented in multiple languages. - It introduces structural support for locale-specific resource pools, canonical representations, and fallback logic. - It ensures that holons, their properties, and relationships can vary by locale without breaking semantic or identity integrity.</p> <p>Mnemonic: \u201cDesign once, localize many times.\u201d</p>"},{"location":"core/i18n-design-spec/#localization-l10n","title":"Localization (l10n)","text":"<p>Localization is the process of adapting data or interface elements for a specific language, region, or cultural context. This includes translating human-readable strings and may involve restructuring or adapting content to fit local norms.</p> <p>In the context of MAP: - A localized holon is a full instance of a holon whose values and relationships are resolved in the context of a particular locale. - One holon per group is designated the canonical representation, and others reference it via a <code>CanonicalRepresentation</code> relationship. - Localization includes translated display names, descriptions, and possibly locale-specific relationships (e.g. tags, categorizations).</p> <p>Mnemonic: \u201cLocalization is applying the design to a specific place and language combination.\u201d</p> <p>These two processes are complementary: - Internationalization is an architectural concern. - Localization is a content and presentation concern.</p>"},{"location":"core/i18n-design-spec/#2-key-design-decisions","title":"2. Key Design Decisions","text":"<ul> <li>\u2705 Each localized representation is a full holon of the same <code>HolonType</code>, scoped to a specific locale</li> <li>\u2705 One representation per locale, grouped via <code>CanonicalRepresentation</code> relationship</li> <li>\u2705 One holon is designated as the canonical representation using <code>is_canonical_representation = true</code></li> <li>\u2705 All other localized holons declare a <code>CanonicalRepresentation</code> link to that canonical holon</li> <li>\u2705 All properties and relationships are resolved relative to locale context</li> <li>\u2705 Locale affiliation is modeled via a <code>LocalPool</code> relationship to a <code>LocalizedResourcePool</code></li> <li>\u2705 No <code>LocalizedString</code> holons or derived <code>LocalizedHolonType</code> subtype</li> </ul>"},{"location":"core/i18n-design-spec/#3-map-internationalization-structure","title":"3. MAP Internationalization Structure","text":"<p>A <code>LocalizedResourcePool</code> groups holons by a shared <code>locale</code> (e.g., <code>en</code>, <code>fr</code>, <code>fr-CA</code>).</p> <p>Each pool is associated with a single Locale (language/region combination)</p> <p>Each localized holon must belong to one such pool via <code>Pool</code>.</p> <p></p> <p>One localized holon is designated as the canonical representation, all others are designated LocalizedRepresentations of the canonical representation and have a relationship to it.</p>"},{"location":"core/i18n-design-spec/#3-holon-localization-semantics","title":"3. Holon Localization Semantics","text":""},{"location":"core/i18n-design-spec/#31-localized-holons","title":"3.1 Localized Holons","text":"<p>Each localized holon is a complete instance of its type (e.g., <code>Book</code>, <code>Person</code>, <code>Organization</code>) with values and links tailored to a specific locale. While string properties are typically the only materialized locale-specific values, all properties and relationships are conceptually locale-relative.</p> <p>Localized holons contain:</p> <ul> <li><code>Pool</code> relationship to their (single) locale-specific <code>LocalizedResourcePool</code></li> <li><code>is_canonical_representation</code> boolean property (true only for one holon per group)</li> <li>Fully materialized string values are expressed in the regional variant of their language (e.g., French Canadian)</li> <li>Relationships are resolved by the most appropriate representation of the target holon(s), given the source holon's locale.</li> </ul> <p>Consider the following example:</p> <p></p> <p>Le Petit Prince is the canonical representation of the Livre (fr:FR) and Antoine de Saint-Exup\u00e9ry is the canonical representation of a Personne. Both belong to the Un d\u00e9p\u00f4t de ressources en fran\u00e7ais pool (as does the Livre and Personne Type Descriptors) - Optional <code>CanonicalRepresentation</code> \u2192 reference to the canonical version (required for non-canonical variants)</p>"},{"location":"core/i18n-design-spec/#32-canonical-representation","title":"3.2 Canonical Representation","text":"<ul> <li>Exactly one localized holon per group should be flagged with <code>is_canonical_representation = true</code></li> <li>Updates should always be made to the canonical holon</li> <li>Other localized holons must eventually be kept in sync via explicit update/translation flows</li> <li>Each localized holon (except the canonical one) must declare a <code>CanonicalRepresentation</code> relationship</li> </ul>"},{"location":"core/i18n-design-spec/#4-locale-affiliation","title":"4. Locale Affiliation","text":"<p>All holons are scoped to a specific locale by including:</p> <pre><code>\"relationships\": {\n  \"LocalPool\": { \"$ref\": \"LocalizedResourcePool:fr-CA\" }\n}\n</code></pre> <p>This enables: - Organized partitioning of holons by language/culture - Locale-sensitive fallback resolution - Query and navigation behaviors that adapt to user preferences</p>"},{"location":"core/i18n-design-spec/#6-cross-locale-equivalence","title":"6. Cross-Locale Equivalence","text":"<p>Localized holons are grouped semantically via:</p> <ul> <li>Shared Type and conceptual identity</li> <li>One canonical representation identified via <code>is_canonical_representation = true</code></li> <li>All others linking back to that canonical holon via <code>CanonicalRepresentation</code></li> </ul> <p>This design supports: - Consistent object identity across languages - Round-trip translation and editing workflows - Clean integration with fallback logic and search resolution</p>"},{"location":"core/i18n-design-spec/#7-locale-precedence-and-fallback","title":"7. Locale Precedence and Fallback","text":"<p>Queries and navigation are executed with a contextual <code>locale_precedence</code> stack, e.g.:</p> <pre><code>{\n  \"requested_locale\": \"fr-CA\",\n  \"fallback_locales\": [\"fr-CA\", \"fr\", \"en-CA\", \"en\"]\n}\n</code></pre> <p>Used for: - Holon resolution - Property display and value substitution - Ranking search results</p>"},{"location":"core/i18n-design-spec/#8-heterogeneous-text-search","title":"8. Heterogeneous Text Search","text":""},{"location":"core/i18n-design-spec/#81-motivation","title":"8.1 Motivation","text":"<p>Text-based search is the first step in many MAP workflows (including AI-RAG). Users should be able to query across all types of holons, e.g. \"Tom Hanks\" \u2192 <code>Person</code>, <code>Film</code>, <code>Author</code>, etc.</p>"},{"location":"core/i18n-design-spec/#82-indexing-scope","title":"8.2 Indexing Scope","text":"<p>Each localized holon is indexed based on: - Locale-tagged <code>display_name</code>, <code>description</code>, <code>type_name</code>, etc. - Any string-bearing property - Relationship labels (for guidance/navigation)</p>"},{"location":"core/i18n-design-spec/#83-search-behavior","title":"8.3 Search Behavior","text":"<ul> <li>Query is matched against all localized holons</li> <li>Locale context guides scoring and fallback</li> <li>Results are enriched with type metadata and <code>DanceLink</code>s for structured navigation</li> </ul>"},{"location":"core/i18n-design-spec/#9-dance-query-integration","title":"9. Dance &amp; Query Integration","text":""},{"location":"core/i18n-design-spec/#91-locale-context","title":"9.1 Locale Context","text":"<p>All queries execute with a <code>locale_context</code>, which influences: - Holon resolution - Relationship traversal - Search indexing and scoring</p>"},{"location":"core/i18n-design-spec/#92-dance-integration","title":"9.2 Dance Integration","text":"<ul> <li><code>DANCE(\"viewBook\")</code> resolves to the localized holon variant matching the context</li> <li><code>DANCE(\"editBook\")</code> may route to the canonical version for source-of-truth editing</li> <li>Queries do not need to manually specify locale \u2014 fallback is automatic</li> </ul>"},{"location":"core/i18n-design-spec/#10-example","title":"10. Example","text":"Locale Holon Key <code>display_name</code> <code>is_canonical_representation</code> Pool Canonical Ref en-US Book:1@en-US \"Book\" true <code>LocalizedResourcePool:en-US</code> \u2014 fr Book:1@fr \"Livre\" false <code>LocalizedResourcePool:fr</code> \u2192 Book:1@en-US fr-CA Book:1@fr-CA \"Livre\" false <code>LocalizedResourcePool:fr-CA</code> \u2192 Book:1@en-US"},{"location":"core/i18n-design-spec/#11-implementation-roadmap","title":"11. Implementation Roadmap","text":"Phase Features \u2705 MVP Canonical holons, embedded string props \u23f3 v1 Localized holons + <code>LocalPool</code> relationships \u23f3 v2 Canonical representation logic (<code>is_canonical_representation</code>, <code>CanonicalRepresentation</code>) \u23f3 v3 Locale-aware fallback resolution \u23f3 v4 Indexed multilingual search \u23f3 v5 Dance integration + canonical update tooling"},{"location":"core/i18n-design-spec/#12-open-design-questions","title":"12. Open Design Questions","text":"<ul> <li>Should canonical holons be excluded from a <code>LocalizedResourcePool</code>, or have a special <code>canonical</code> pool? NO</li> <li>Should properties like <code>is_canonical_representation</code> be enforced at the type level? NO</li> <li>How are canonical updates tracked and propagated (e.g. via translation queues)? TBD</li> <li>How should locale-specific validation be applied to ensure completeness and fidelity? TBD</li> </ul>"},{"location":"core/i18n-design-spec/#13-summary","title":"13. Summary","text":"<p>MAP\u2019s localized holon design enables a powerful, consistent, and high-performance internationalization strategy that:</p> <ul> <li>Keeps all holons in a uniform representation</li> <li>Avoids fragmentary or per-property lookup logic</li> <li>Fully supports multilingual search and navigation</li> <li>Integrates seamlessly with canonical edit flows and localization workflows</li> </ul> <p>This architecture is designed to scale with complexity while remaining intuitive and developer-friendly across all layers of the MAP platform.</p>"},{"location":"core/map-catalist-security-models/","title":"Proposal: Migrating from Catalist\u2019s Fine-Grained Security to MAP\u2019s Group-Oriented Model","text":""},{"location":"core/map-catalist-security-models/#1-core-dimensions-of-security","title":"1. Core Dimensions of Security","text":"<p>Both Catalist and MAP need to address the same underlying dimensions: - Who (agents/people/groups) - What Data (holons, attributes, views)  - What Actions (verbs/Dances) - Entitlements vs. Permissions (purchased rights vs. delegated rights)</p> <p>Catalist encodes these as fine-grained decisions at the level of individuals and attributes. MAP lifts them into higher-order groupings:</p> Dimension Catalist (fine-grain) MAP (group-oriented) Who Each person has direct grants People belong to Groups Actions Each verb toggled per person Actions grouped into Roles Entitlements Tied to specific individuals Entitled actions bundled into Products Data Attributes assigned per person Attributes bundled into Views"},{"location":"core/map-catalist-security-models/#2-simplifying-the-decision-surface","title":"2. Simplifying the Decision Surface","text":"<p>Instead of N\u00d7M\u00d7K\u00d7L micro-decisions (people \u00d7 attributes \u00d7 actions \u00d7 contexts), MAP collapses the surface area:</p> <ul> <li>Grant = (Group, Role, View)<ul> <li>Which group has which role over which view?</li> </ul> </li> <li>Entitlements = (Product \u2192 Role associations)<ul> <li>Purchasing a product expands the action set for associated roles.</li> </ul> </li> </ul> <p>This makes permissioning a macro-level governance decision rather than an endless stream of micro-decisions.</p>"},{"location":"core/map-catalist-security-models/#3-change-management-and-migration-path","title":"3. Change Management and Migration Path","text":"<ul> <li>Step 1: Define canonical Groups, Roles, Products, Views   Translate existing Catalist entitlements/permissions into these higher-order bundles.</li> <li>Step 2: Map existing fine-grained grants into group memberships   (e.g., \u201cFrank has access to X, Y, Z\u201d \u2192 Frank is in Group A, which carries Role B over View C).</li> <li>Step 3: Retire individual grants in favor of group membership operations   Adding/removing people from groups now handles churn events (onboarding, offboarding, role shifts).</li> </ul>"},{"location":"core/map-catalist-security-models/#4-alignment-with-map-security-model","title":"4. Alignment with MAP Security Model","text":"<p>This approach fits cleanly with MAP\u2019s core security principles:</p> <ul> <li>Membrane-based boundaries \u2014 Groups correspond to AgentSpace membranes </li> <li>Consent-based access \u2014 Views and Products are exposed only via explicit Agreements </li> <li>Sovereign custody \u2014 All data lives in private Data Groves, shared only through Information Access Agreements </li> <li>Role-based actions \u2014 Roles map directly to permitted Dances within the Uniform API </li> </ul>"},{"location":"core/map-catalist-security-models/#5-benefits","title":"5. Benefits","text":"<ul> <li>Reduces cognitive load for administrators and members.</li> <li>Improves resilience by making permissions more transparent and auditable.</li> <li>Supports migration: existing fine-grained Catalist grants can be bulk-mapped into initial groups/roles/views without losing fidelity.</li> <li>Future-proof: easily maps into MAP\u2019s holistic model of Promises, Agreements, and Vital Capital flows </li> </ul> <pre><code>flowchart LR\n  subgraph Inputs[Normalized Inputs]\n    SM[SpaceMembership (user \u2208 Group@Space)]\n    RP[RolePolicy (Group \u2192 can_*)]\n    PUB[Publish/Unpublish (Thing \u2194 Space)]\n    OWN[Home Transfer]\n    ENT[Entitlement (Plan@Space)]\n    ASG[EntitlementAssignment (seat)]\n    PF[Plan/Feature/Action mapping]\n    TREF[ThingEntitlementRef (Thing \u2194 Entitlement)]\n    AS[Audience Set (Space:is_audience_set)]\n  end\n\n  subgraph Compiler[Backend \"Compiler\" Workflows]\n    P1[Recompute eff_perm_* for impacted Things]\n    E1[Recompute eff_ent_* for impacted Things]\n    I1[(Optional) Write eff_allowed_* = \u2229]\n  end\n\n  subgraph Outputs[Thing Runtime Lists]\n    EPV[eff_perm_view]\n    EPA[eff_perm_annotate]\n    EPE[eff_perm_edit]\n    EPM[eff_perm_manage]\n    EEV[eff_ent_view]\n    EEA[eff_ent_annotate]\n    EEE[eff_ent_edit]\n    EAL[(optional) eff_allowed_*]\n  end\n\n  SM --&gt; P1\n  RP --&gt; P1\n  PUB --&gt; P1\n  OWN --&gt; P1\n  ENT --&gt; E1\n  ASG --&gt; E1\n  PF --&gt; E1\n  TREF --&gt; E1\n  AS --&gt; P1\n\n  P1 --&gt; EPV &amp; EPA &amp; EPE &amp; EPM\n  E1 --&gt; EEV &amp; EEA &amp; EEE\n  I1 --&gt; EAL\n\n  style EPM fill:#ffd8bf,stroke:#c44,color:#222\n  style AS fill:#eef,stroke:#88a,color:#222\n</code></pre>"},{"location":"core/map-deployment-arch/","title":"MAP Rust-API Developer Guide","text":"<p>The Rust-API is the boundary between your application code and the underlying holon store and services. It provides:</p> <ul> <li>Uniform handles (\u201creferences\u201d) to holons, regardless of whether they are transient, staged, or cached/saved.</li> <li>A small, consistent read/write API that hides internal manager and phase differences.</li> <li>High-level operations for staging, committing, and deleting.</li> <li>A curated prelude for ergonomic imports and a stable public API.</li> </ul> <p>This guide explains the API surface and shows how to perform the most common tasks.</p>"},{"location":"core/map-deployment-arch/#part-i-foundations","title":"Part I \u2013 Foundations","text":""},{"location":"core/map-deployment-arch/#1-prelude","title":"1. Prelude","text":"<p>To simplify imports, use the MAP prelude:</p> <p>```rust,ignore use holons_prelude::prelude::*; <pre><code>This brings into scope:\n\n* Core value and identifier types (`BaseValue`, `MapString`, `HolonId`)\n* Reference traits and types (`HolonReference`, `ReadableHolon`, `WritableHolon`, `TransientReference`, `StagedReference`, `SmartReference`)\n* Context traits (`HolonsContextBehavior`)\n* Common operations (`stage_new_holon_api`, `commit_api`, etc.)\n* Type-name helpers (`CorePropertyTypeName`, `CoreRelationshipTypeName`, `ToPropertyName`, `ToRelationshipName`)\n* Dance protocol builders (`holon_dance_builders::*`)\n* Query types (`Node`, `NodeCollection`, `QueryExpression`)\n\n&gt; Use `holons_prelude::prelude::v1::*` if you need to pin to a stable prelude version.\n\n---\n\n## 2. Context: your execution environment\n\nEvery holon operation in MAP runs within a **context** that implements the `HolonsContextBehavior` trait. This context is the execution environment for all read, write, and commit actions\u2014it provides access to the active workspace where your holons live.\n\nAs a developer, you don\u2019t create or manage the context yourself. Your mApp receives it from the runtime whenever you perform operations that touch holons.  \nYou simply pass it along to each API call that needs it.\n\nExample \u2014 staging and committing a holon:\n\n```rust,no_run\nuse holons_prelude::prelude::*;\n\nfn create_and_commit(\n    context: &amp;dyn HolonsContextBehavior,\n) -&gt; Result&lt;(), HolonError&gt; {\n    // Create a new transient holon of a given type\n    let transient = new_holon(context, MapString(\"ExampleType\".into()));\n    transient.with_property_value(context, P::Key, \"example-1\".into())?;\n\n    // Stage it for persistence\n    let _staged = stage_new_holon_api(context, transient)?;\n\n    // Commit all staged changes\n    let response = commit_api(context)?;\n    println!(\"Committed {} holons.\", response.commits_attempted);\n\n    Ok(())\n}\n</code></pre></p>"},{"location":"core/map-deployment-arch/#key-points-for-developers","title":"Key points for developers","text":"<ul> <li> <p>The context is always the first parameter to any read or write call.    It carries all the state needed to resolve references, access relationships, and enforce permissions.</p> </li> <li> <p>You can think of it as your \u201csession\u201d or \u201cworkspace.\u201d    Everything that happens during a transaction\u2014reads, writes, staging, commits\u2014occurs within this context.</p> </li> <li> <p>The context automatically routes requests to the right implementation based on the holon\u2019s phase (transient, staged, or saved).  You never need to know which storage or cache layer is involved.</p> </li> <li> <p>Contexts are lightweight and short-lived. They are passed around as immutable references (<code>&amp;dyn HolonsContextBehavior</code>), so you can safely use them in async or concurrent flows.</p> </li> </ul> <p>In short: the context is your gateway to the MAP. You use it everywhere, but you don\u2019t manage or configure it\u2014just pass it through to the reference-layer API.</p>"},{"location":"core/map-deployment-arch/#3-reference-kinds","title":"3. Reference Kinds","text":"<p><code>HolonReference</code> is the universal handle for accessing any holon in MAP\u2014whether it\u2019s newly created, staged for commit, or already persisted. It abstracts over three underlying reference types that represent different lifecycle phases of a holon.</p> <ul> <li><code>TransientReference</code> \u2014 in-memory, mutable, not yet persisted.</li> <li><code>StagedReference</code> \u2014 managed by the staging layer and ready to commit.</li> <li><code>SmartReference</code> \u2014 read-only, backed by a saved holon in cache or storage.</li> </ul> <p>All three implement the <code>ReadableHolon</code> trait; <code>TransientReference</code> and <code>StagedReference</code> additionally implement <code>WritableHolon</code>.</p> Type Backing store Read Write Commit Notes <code>HolonReference</code> Delegates to underlying phase \u2705 \u2705 / \u274c \u2705 / \u274c Unified handle that wraps any reference type. Enforces access rules automatically. <code>TransientReference</code> In-memory \u2705 \u2705 \u274c Must be staged before commit. <code>StagedReference</code> Staging area \u2705 \u2705 \u2705 Prepared for persistence. <code>SmartReference</code> Saved/cache \u2705 \u274c \u274c Read-only view of a saved holon."},{"location":"core/map-deployment-arch/#unified-trait-implementation","title":"Unified trait implementation","text":"<p><code>HolonReference</code> implements both <code>ReadableHolon</code> and <code>WritableHolon</code>. This means you can call read or write methods directly on a <code>HolonReference</code> without downcasting to its internal variant.</p> <p>However, write access is phase-dependent:</p> <ul> <li>If the reference wraps a <code>TransientReference</code> or <code>StagedReference</code>, write operations (e.g., <code>with_property_value</code>, <code>add_related_holons</code>) will succeed normally.</li> <li>If the reference wraps a <code>SmartReference</code>, any attempt to modify it will result in <code>HolonError::NotAccessible</code>.</li> </ul> <p>This design provides ergonomic consistency while maintaining strict access guarantees.</p>"},{"location":"core/map-deployment-arch/#typical-usage-pattern","title":"Typical usage pattern","text":"<p>```rust,ignore // Works regardless of phase let title = holon_ref.property_value(context, &amp;P::Title)?;</p> <p>// Safe to call; will fail gracefully if reference is read-only holon_ref.with_property_value(context, P::Title, \"Updated\".into())?; <pre><code>In short:  \n**`HolonReference` provides a single, uniform API for all holon phases**, while the combination of context and reference phase determines which operations are actually permitted.\n\n---\n\n# Part II \u2013 Holon Operations (HolonOperationsApi)\n\nThe **HolonOperationsApi** provides high-level functions for creating, staging, committing, and deleting holons.  It serves as the main entry point for mApp developers who need to persist holons, abstracting away the lower-level service lookups handled by the `HolonSpaceManager`. Where the `ReadableHolon` and `WritableHolon` traits focus on *individual holon content*, the operations in this API focus on *holon lifecycle actions* \u2014 such as preparing holons for persistence, committing them to storage, and querying what\u2019s currently staged.\n\n---\n\n## 4. Creating and staging holons\n\nHolons can be created or staged in several ways, depending on the source and intent. All staging operations result in a `StagedReference`, representing a holon managed by the **Nursery** and ready for commit.\n\n### A. Creating a new transient holon\n\nUse `new_holon` to create a new, empty transient holon. Once created, you can use its TransientReference to et its properties or relationships (see `WritableHolon` operations below).\n\n```rust,ignore\nlet transient = new_holon(context, MapString(\"BookType\".into()))?;\ntransient.with_property_value(context, P::Title, \"The Rustonomicon\".into())?;\n</code></pre></p> <p>Transient holons are purely in-memory \u2014 they can be used ephemerally (e.g., as temporary parameters in a Dance), or later staged for persistence.</p>"},{"location":"core/map-deployment-arch/#b-staging-a-new-holon-from-scratch","title":"B. Staging a new holon from scratch","text":"<p>To prepare a transient holon for persistence, call <code>stage_new_holon</code>. This registers it in the Nursery and returns a <code>StagedReference</code>.</p> <p>```rust,ignore let transient = new_holon(context, MapString(\"BookType\".into()))?; transient.with_property_value(context, P::Key, \"example-1\".into())?;</p> <p>let staged = stage_new_holon(context, transient)?; <pre><code>The newly staged holon now participates in commit operations and can have relationships or properties safely modified.\n\n---\n\n### C. Staging a holon by cloning another\n\nUse `stage_new_from_clone` to create a new staged holon based on an existing one. The `original_holon` may be a transient, staged, or saved holon.  NOTE: stage_new_from_clone on a Transient HolonReference is equivalent to `stage_new_holon`. To distinguish the new holon from the holon it is being cloned from, pass the \"key\" for the new holon as a parameter.\n\n```rust,ignore\nlet staged_clone = stage_new_from_clone(context, existing_ref, MapString(\"copy-001\".into()))?;\n</code></pre></p> <p>Use this form when you want to derive a new holon from an existing one without creating a lineage relationship.</p>"},{"location":"core/map-deployment-arch/#d-staging-a-new-version-of-a-saved-holon","title":"D. Staging a new version of a saved holon","text":"<p>Saved holons (accessed via <code>SmartReference</code>) are immutable. To \u201cupdate\u201d one, you must stage a new holon that explicitly declares the saved holon as its predecessor. This ensures historical lineage and preserves auditability.</p> <p>```rust,ignore let staged_version = stage_new_version(context, saved_ref)?; staged_version.with_property_value(context, P::Status, \"Revised\".into())?; <pre><code>&gt; Conceptually, `stage_new_version` is the canonical \u201cupdate\u201d mechanism in MAP.  \n&gt; Instead of mutating data, it creates a new holon with lineage continuity.\n\n---\n\n### Summary of staging options\n\n| Use case                      | Input reference kind | Function               | Result            | Lineage | Notes                                |\n|-------------------------------|----------------------|------------------------|-------------------|---------|--------------------------------------|\n| Create new holon from scratch | None (new)           | `stage_new_holon`      | `StagedReference` | \u274c       | Typical create workflow              |\n| Derive holon from another     | Any                  | `stage_new_from_clone` | `StagedReference` | \u274c       | Copy data from any source            |\n| Create new version (update)   | `SmartReference`     | `stage_new_version`    | `StagedReference` | \u2705       | Adds predecessor link for versioning |\n\nAll three return `StagedReference`, ready to commit.\n\n---\n\n## 5. Committing staged holons\n\nOnce one or more holons have been staged, you can persist them together using `commit`.\n\n```rust,ignore\nlet response = commit(context)?;\nprintln!(\n    \"Saved: {}, Abandoned: {}, Attempted: {}\",\n    response.saved_holons.len(),\n    response.abandoned_holons.len(),\n    response.commits_attempted\n);\n</code></pre></p>"},{"location":"core/map-deployment-arch/#commitresponse-contents","title":"CommitResponse contents","text":"<ul> <li><code>saved_holons</code> \u2014 list of successfully persisted holons.</li> <li><code>abandoned_holons</code> \u2014 holons that were skipped or invalidated.</li> <li><code>commits_attempted</code> \u2014 total count of staged holons processed.</li> </ul> <p>A complete commit satisfies: <code>(saved + abandoned == attempted)</code></p>"},{"location":"core/map-deployment-arch/#commit-outcomes","title":"Commit outcomes","text":"<p>Complete Commit \u2013 All staged holons and relationships persisted successfully. The Nursery is cleared of committed entries.</p> <p>Partial Commit \u2013 Some holons committed successfully, others remain staged with error details. No staged holons are automatically removed, allowing retries.</p> <p>Failure \u2013 System-level issue prevented commit; no changes persisted.</p>"},{"location":"core/map-deployment-arch/#e-counting-and-retrieving-staged-holons","title":"E. Counting and retrieving staged holons","text":"<p>Helper methods are available for diagnostics or introspection:</p> <p>```rust,ignore let staged_total = staged_count(context); let transient_total = transient_count(context); println!(\"Currently staged: {}, transient: {}\", staged_total, transient_total); <pre><code>You can also look up specific holons by key:\n\n```rust,ignore\nlet staged_by_key = get_staged_holon_by_base_key(context, &amp;MapString(\"example-1\".into()))?;\n</code></pre></p>"},{"location":"core/map-deployment-arch/#f-deleting-holons","title":"F. Deleting holons","text":"<p>Holons can be deleted via <code>delete_holon</code>, but only local (i.e., space-owned) saved holons may be deleted.</p> <p>```rust,ignore delete_holon(context, local_id)?; <pre><code>Deletion removes the holon from the current holon space and, if invoked from the guest side, from the DHT as well.\n\n---\n\n### Conceptual overview\n\nThe **HolonOperationsApi** provides the primary bridge between mApp logic and the MAP storage layer.  \nIt\u2019s designed for developer clarity and consistency:\n\n* **`new_holon`** \u2192 Creates new in-memory holons.\n* **`stage_new_*`** \u2192 Moves holons into the staging area, ready for commit.\n* **`commit`** \u2192 Persists all staged holons atomically.\n* **`delete_holon`** \u2192 Removes holons permanently.\n\nTogether, these functions represent the canonical workflow for managing holon persistence.\n\n---\n\n# Part III \u2013 Individual Holons (ReadableHolon, WritableHolon)\n\n## 7. Reading holons (ReadableHolon)\n\nEvery `HolonReference` implements `ReadableHolon`.  \nReads are *kind-safe* and work consistently across transient, staged, and saved holons.\n\n---\n\n### Core reads\n\n`key(context) -&gt; Option&lt;MapString&gt;`\n\nThe human-meaningful identifier for the holon, if defined.  \nSome holon kinds are keyless, so this may return `None`.\n\nExample:\n```rust,ignore\nlet key_opt = reference.key(context)?;\n</code></pre></p> <p><code>versioned_key(context) -&gt; MapString</code></p> <p>A stable, fully-qualified identifier that includes the base key plus version information (when applicable). Since saved holons are immutable, updating a saved holon creates a new version with a distinct <code>versioned_key</code>. If the update doesn\u2019t alter the underlying key properties, the new holon will share the same base key.</p> <p>Example: ```rust,ignore let vkey = reference.versioned_key(context)?; <pre><code>---\n\n`property_value(context, name) -&gt; Option&lt;PropertyValue&gt;`\n\nReads a property by name using **ergonomic inputs**:  \n`&amp;str`, `String`, `MapString`, `PropertyName`, or a core enum such as `CorePropertyTypeName::Title`.  \nReturns `None` if the property is absent.\n\nExample:\n```rust,ignore\nlet title_opt = reference.property_value(context, \"title\")?;\n</code></pre></p> <p><code>related_holons(context, name) -&gt; HolonCollection</code></p> <p>Navigates an outgoing relationship and returns a collection of <code>HolonReference</code>s to the linked holons. Accepts <code>&amp;str</code>, <code>String</code>, <code>MapString</code>, <code>RelationshipName</code>, or a core enum. Always returns a <code>HolonCollection</code> (possibly empty), never <code>None</code>.</p> <p>Example: ```rust,ignore let children = reference.related_holons(context, \"HAS_CHILD\")?; <pre><code>---\n\n### When to use which\n\n| Method               | Purpose                                                                                                        |\n|----------------------|----------------------------------------------------------------------------------------------------------------|\n| **`key`**            | Retrieve or display a meaningful base key. Use for routing, URLs, and user-facing identifiers.                 |\n| **`versioned_key`**  | Generate stable identifiers for logging, caching, and cross-system references.                                 |\n| **`property_value`** | Read domain fields (e.g., `title`, `status`). Use ergonomic names: `\"title\"` or `CorePropertyTypeName::Title`. |\n| **`related_holons`** | Traverse graph links (e.g., `\"HAS_CHILD\"`, `CoreRelationshipTypeName::HasChild`) and iterate results.          |\n\n---\n\n### Ergonomic property and relationship access\n\nMAP\u2019s ergonomic wrapper traits make property and relationship access feel natural:\n\n* **`ToPropertyName`** \u2014 allows property lookups using core enums, strings, or `MapString`s.\n* **`ToRelationshipName`** \u2014 allows relationship lookups using core enums or strings.\n\nThese remove the need to manually construct `PropertyName(MapString(...))` or `BaseValue::StringValue(...)` and unify access across core and dynamic names.\n\n#### Examples\n\n**Before (verbose):**\n```rust,ignore\nlet title = reference.property_value(\n    context,\n    PropertyName(MapString(\"title\".into())),\n)?;\n</code></pre></p> <p>Now (ergonomic): ```rust,ignore let title = reference.property_value(context, \"title\")?; let author = reference.property_value(context, CorePropertyTypeName::Author)?; let children = reference.related_holons(context, CoreRelationshipTypeName::HasChild)?; <pre><code>All inputs are normalized internally (e.g., `\"friends\"`, `\"Friends\"`, and `\"FRIENDS\"` are equivalent).\n\n---\n\n### Example: Reading a property with a default\n\n```rust,ignore\nlet title = item.property_value(context, \"title\")?\n    .and_then(|v| v.as_string())\n    .unwrap_or_else(|| \"Untitled\".to_string());\n</code></pre></p> <p>This retrieves the <code>\"title\"</code> property, converts it to a string if possible, and falls back to <code>\"Untitled\"</code> when the property is missing or not a string.</p> <p>Step-by-step: 1. <code>property_value</code> returns a <code>Result&lt;Option&lt;PropertyValue&gt;, HolonError&gt;</code>.    The <code>?</code> operator unwraps the <code>Result</code>, leaving an <code>Option&lt;PropertyValue&gt;</code>. 2. <code>.and_then(|v| v.as_string())</code> converts the property to a <code>String</code> if it\u2019s string-typed. 3. <code>.unwrap_or_else(|| \"Untitled\".to_string())</code> substitutes a default when missing.</p> <p>In plain language:</p> <p>\u201cGet the holon\u2019s title if available; otherwise use <code>'Untitled'</code>.\u201d</p>"},{"location":"core/map-deployment-arch/#example-traversing-relationships","title":"Example: Traversing relationships","text":"<p>```rust,ignore let children = reference.related_holons(context, \"HAS_CHILD\")?; for child in children.iter() {     let ck = child.key(context)?;     println!(\"Child key: {:?}\", ck); } <pre><code>This fetches and iterates through all linked child holons using an ergonomic relationship lookup.\n\n## 8. Writing holons (WritableHolon)\n\nThe `WritableHolon` trait provides mutation APIs for holons that can be modified \u2014 namely,  \n**`TransientReference`** and **`StagedReference`**.  \nAttempting to call any of these methods on a `SmartReference` (saved holon) will return  \n`HolonError::NotAccessible`.\n\nWritable methods are kind-safe: they automatically update both the in-memory property/relationship maps and any synchronization state used during staging or commit.\n\n---\n\n### Setting property values\n\n`with_property_value(context, name, value) -&gt; Result&lt;(), HolonError&gt;`\n\nAssigns or replaces a property value.  \nAccepts property names using ergonomic `ToPropertyName` conversions (e.g., string literals or core enums) and automatically wraps primitive Rust types into their appropriate `PropertyValue`.\n\nExample:\n```rust,ignore\nreference.with_property_value(context, \"title\", \"Hello World\")?;\nreference.with_property_value(context, CorePropertyTypeName::Status, \"Draft\")?;\n</code></pre></p> <p>You can pass Rust primitives such as <code>&amp;str</code>, <code>String</code>, <code>bool</code>, <code>i64</code>, or <code>f64</code>. Internally these are converted into the appropriate MAP <code>BaseValue</code> variant.</p>"},{"location":"core/map-deployment-arch/#removing-properties","title":"Removing properties","text":"<p><code>remove_property_value(context, name) -&gt; Result&lt;(), HolonError&gt;</code></p> <p>Removes the specified property, if present.</p> <p>Example: ```rust,ignore reference.remove_property_value(context, \"obsolete\")?; <pre><code>If the property does not exist, the method simply returns `Ok(())`.\n\n---\n\n### Managing relationships\n\n`add_related_holons(context, name, targets) -&gt; Result&lt;(), HolonError&gt;`\n\nAdds one or more related holons under the given relationship name.  \nEach target is a `HolonReference`.  \nThe relationship name accepts the same ergonomic types as property names.\n\nExample:\n```rust,ignore\nreference.add_related_holons(\n    context,\n    CoreRelationshipTypeName::HasChild,\n    vec![child_ref],\n)?;\n</code></pre></p> <p><code>remove_related_holons(context, name, targets) -&gt; Result&lt;(), HolonError&gt;</code></p> <p>Removes one or more holons from a relationship set. Has no effect if the target references are not already related.</p> <p>Example: ```rust,ignore reference.remove_related_holons(     context,     \"HAS_CHILD\",     vec![child_ref], )?; <pre><code>&gt; Relationship mutations automatically update the holon\u2019s local relationship map.  \n&gt; The changes become durable only after commit.\n\n---\n\n### Setting the descriptor\n\n`with_descriptor(context, descriptor_ref) -&gt; Result&lt;(), HolonError&gt;`\n\nSets or replaces the holon\u2019s **descriptor**, which declares its type.  \nDescriptors are always holons themselves (of a `HolonType` kind).  \nThis call is uncommon in normal app code \u2014 it\u2019s primarily used by loaders or editors creating new holons from schema types.\n\nExample:\n```rust,ignore\nreference.with_descriptor(context, descriptor_ref)?;\n</code></pre></p>"},{"location":"core/map-deployment-arch/#setting-the-predecessor","title":"Setting the predecessor","text":"<p><code>with_predecessor(context, predecessor_ref) -&gt; Result&lt;(), HolonError&gt;</code></p> <p>Establishes a lineage relationship between the current holon and its immediate predecessor. Used mainly in versioned workflows to record \u201cwhat this holon was derived from.\u201d</p> <p>Example: ```rust,ignore reference.with_predecessor(context, Some(prev_ref))?; <pre><code>To clear a predecessor link, pass `None`.\n\n---\n\n### Summary of writable operations\n\n| Operation               | Purpose                    | Typical use                                                 |\n|-------------------------|----------------------------|-------------------------------------------------------------|\n| `with_property_value`   | Set or replace a property. | Create or edit domain fields before staging or commit.      |\n| `remove_property_value` | Remove a property.         | Clean up unused or obsolete fields.                         |\n| `add_related_holons`    | Add linked holons.         | Associate new relationships (e.g., add tasks to a project). |\n| `remove_related_holons` | Remove linked holons.      | Detach related entities.                                    |\n| `with_descriptor`       | Assign a type descriptor.  | Loader-level operation for schema-driven creation.          |\n| `with_predecessor`      | Record lineage.            | Used in versioned updates (`stage_new_version`).            |\n\n---\n\n### Example workflow\n\nHere\u2019s a typical editing flow for a staged holon:\n\n```rust,ignore\n// 1. Stage a new version of an existing holon\nlet staged = stage_new_version(context, saved_ref)?;\n\n// 2. Update its properties\nstaged.with_property_value(context, \"title\", \"Updated Title\")?;\nstaged.with_property_value(context, CorePropertyTypeName::Status, \"Revised\")?;\n\n// 3. Add and remove related holons\nstaged.add_related_holons(context, \"HAS_CHILD\", vec![child_a])?;\nstaged.remove_related_holons(context, \"HAS_CHILD\", vec![child_b])?;\n\n// 4. Commit all staged changes\nlet resp = commit(context)?;\nprintln!(\"{} holons saved.\", resp.saved_holons.len());\n</code></pre></p> <p>This demonstrates the complete writable lifecycle: create or stage \u2192 modify \u2192 commit.</p>"},{"location":"core/map-deployment-arch/#error-conditions","title":"Error conditions","text":"<p>All writable operations return <code>Result&lt;(), HolonError&gt;</code>. Common error cases:</p> <ul> <li><code>HolonError::NotAccessible</code> \u2014 write attempted on a read-only holon (<code>SmartReference</code>).</li> <li><code>HolonError::InvalidHolonReference</code> \u2014 target or relationship not resolvable in the current context.</li> <li><code>HolonError::InvalidType</code> \u2014 provided value type doesn\u2019t match the property\u2019s declared type.</li> <li><code>HolonError::UnexpectedValueType</code> \u2014 incompatible runtime conversion.</li> </ul> <p>Writable APIs follow a fail-fast design \u2014 operations either succeed immediately or return a specific <code>HolonError</code> explaining what went wrong.</p> <p>In summary: WritableHolon methods make it easy to set, update, and link holons safely, with ergonomic property and relationship access, automatic type conversion, and strong context enforcement.</p>"},{"location":"core/map-deployment-arch/#part-iv-collections-holoncollectionapi","title":"Part IV \u2013 Collections (HolonCollectionApi)","text":""},{"location":"core/map-deployment-arch/#9-working-with-collections-of-holons","title":"9. Working with collections of holons","text":"<p>A <code>HolonCollection</code> represents an unordered set of holon references\u2014often returned when traversing relationships.</p>"},{"location":"core/map-deployment-arch/#access-and-iteration","title":"Access and iteration","text":"<p>```rust,ignore let count   = tasks.len(); let first   = tasks.first(); let by_index  = tasks.get(2); for holon_ref in &amp;tasks {     println!(\"{:?}\", holon_ref.key(context)?); } <pre><code>### Membership and lookup\n```rust,ignore\nif tasks.contains(&amp;some_ref) {\n    println!(\"Already linked!\");\n}\n</code></pre></p> <p>```rust,ignore if let Some(found) = tasks.get_by_key(&amp;MapString(\"task-42\".into())) {     println!(\"Found task 42: {:?}\", found.key(context)?); } <pre><code>### Mutation\nAvailable only for transient and staged holons.\n\n```rust,ignore\ntasks.add(context, HolonReference::Transient(new_task_ref))?;\ntasks.remove(context, HolonReference::Smart(old_task_ref))?;\n</code></pre></p>"},{"location":"core/map-deployment-arch/#part-v-queries","title":"Part V \u2013 Queries","text":""},{"location":"core/map-deployment-arch/#10-querying-holons","title":"10. Querying holons","text":"<p>The query layer provides a high-level way to search for holons that meet specific criteria.</p>"},{"location":"core/map-deployment-arch/#example","title":"Example","text":"<p>```rust,ignore let expr = QueryExpression::property_equals(P::Title, \"Hello\".into()); let nodes: NodeCollection = run_query(context, expr)?; for node in nodes {     println!(\"Found: {:?}\", node.key(context)?); } <pre><code>&gt; Note: The query API is evolving and currently supports basic property and relationship predicates.\n\n---\n\n# Part VI \u2013 Cross-cutting Topics\n\n## 11. Access Control\n\n| AccessType | Transient | Staged | Smart |\n|------------|-----------|--------|-------|\n| Read       | \u2705         | \u2705      | \u2705     |\n| Write      | \u2705         | \u2705      | \u274c     |\n| Clone      | \u2705         | \u2705      | \u2705     |\n| Commit     | \u274c         | \u2705      | \u274c     |\n| Abandon    | \u2705         | \u2705      | \u274c     |\n\nUnauthorized actions raise `HolonError::NotAccessible`.\n\n---\n\n## 12. Error Handling\n\nAll MAP API functions return `Result&lt;_, HolonError&gt;`.  This unified error type is used consistently across the reference layer and ensures that mApp code can handle errors uniformly\u2014whether they originate in the local runtime, the staging layer, or a distributed DHT operation.\n\n---\n\n### How errors propagate\n\n1. **Local logic errors** (e.g., missing property, invalid type) are raised directly by reference-layer methods.\n2. **Access control errors** are enforced by context and reference kind before reaching service layers.\n3. **Service errors** (e.g., during commit or DHT access) bubble up through the same `HolonError` type for consistent handling.\n\nWhen using `?`, errors automatically propagate to the caller; explicit matches can be used for fine-grained control.\n\nExample:\n\n```rust,ignore\nmatch reference.property_value(context, \"title\") {\n    Ok(Some(val)) =&gt; println!(\"Title: {:?}\", val.as_string()),\n    Ok(None) =&gt; println!(\"Title missing.\"),\n    Err(HolonError::NotAccessible) =&gt; println!(\"You do not have read access.\"),\n    Err(err) =&gt; eprintln!(\"Unexpected error: {:?}\", err),\n}\n</code></pre></p>"},{"location":"core/map-deployment-arch/#error-categories","title":"Error categories","text":"Category Typical causes Handling strategy Access Attempted write or read on an inaccessible holon or context. Verify reference kind and permissions. Resolution Reference could not be found or resolved. Check that the target holon exists in the current space. Schema / Type Property value type mismatches or missing required fields. Validate property types before assignment; use defaults for missing values. Persistence / Service Errors during staging, commit, or DHT operations. Retry commit or surface to user; check <code>CommitResponse</code> for details. Internal Unexpected internal conditions or bugs. Log and escalate."},{"location":"core/map-deployment-arch/#mapping-to-responsestatuscode","title":"Mapping to ResponseStatusCode","text":"<p>When holon operations are invoked through Dances, <code>HolonError</code> variants are automatically mapped to appropriate <code>ResponseStatusCode</code> values (e.g., <code>BadRequest</code>, <code>Conflict</code>, <code>ServerError</code>). This allows API clients to interpret results consistently across in-process and distributed boundaries.</p>"},{"location":"core/map-deployment-arch/#best-practices","title":"Best practices","text":"<ul> <li>Use pattern matching to handle expected errors gracefully (e.g., missing properties).</li> <li>Use the <code>?</code> operator when you want errors to bubble up.</li> <li>Always log or display <code>HolonError::message()</code> when debugging.</li> <li>Treat <code>HolonError::InternalError</code> as a bug indicator \u2014 report it.</li> </ul> <p>For a complete list of <code>HolonError</code> variants, see Appendix B \u2013 HolonError Reference.</p>"},{"location":"core/map-deployment-arch/#13-style-conventions","title":"13. Style &amp; Conventions","text":"<ul> <li>Use explicit suffixes (<code>*_reference</code>) for reference variables.</li> <li>When APIs expect <code>Vec&lt;HolonReference&gt;</code>, wrap explicitly:</li> </ul> <p>```rust,ignore HolonReference::Transient(transient_reference) <pre><code>---\n\n## 14. Where to Look\n\n* **Prelude:** `holons_prelude::prelude`\n* **Context behavior:** `reference_layer/context_behavior.rs`\n* **Operations API:** `reference_layer/holon_operations_api.rs`\n* **Reference traits and types:** `reference_layer/holon_reference.rs`, `readable_holon.rs`, `writable_holon.rs`, `staged_reference.rs`, `transient_reference.rs`\n* **Access and state:** `core_shared_objects/holon/state.rs`\n* **Dance builders:** `holon_dance_builders`\n* **Query layer:** `reference_layer/query_api.rs`\n\n---\n\n## 15. Evolving Areas\n\n* Validation runs primarily at commit.\n* Fluent chaining (`&amp;Self`) is being standardized in setters.\n* The query API will expand to richer predicates.\n* Additional Dances (Loader, Validation) will reuse the same reference layer interface.\n\n---\n\n# Appendix A \u2013 API Quick Reference Card\n\n## HolonOperationsApi\n\n```rust,ignore\nfn new_holon(\n    context: &amp;dyn HolonsContextBehavior,\n    type_name: MapString,\n) -&gt; TransientReference;\n\nfn stage_new_holon_api(\n    context: &amp;dyn HolonsContextBehavior,\n    transient: TransientReference,\n) -&gt; Result&lt;StagedReference, HolonError&gt;;\n\nfn stage_new_version(\n    context: &amp;dyn HolonsContextBehavior,\n    current_version: SmartReference,\n) -&gt; Result&lt;StagedReference, HolonError&gt;;\n\nfn stage_new_from_clone(\n    context: &amp;dyn HolonsContextBehavior,\n    original_holon: HolonReference,\n    new_key: MapString,\n) -&gt; Result&lt;StagedReference, HolonError&gt;;\n\nfn commit_api(\n    context: &amp;dyn HolonsContextBehavior,\n) -&gt; Result&lt;CommitResponse, HolonError&gt;;\n</code></pre></p>"},{"location":"core/map-deployment-arch/#readableholon","title":"ReadableHolon","text":"<p>```rust,ignore fn key(&amp;self, context: &amp;dyn HolonsContextBehavior)     -&gt; Result, HolonError&gt;; <p>fn versioned_key(&amp;self, context: &amp;dyn HolonsContextBehavior)     -&gt; Result; <p>fn property_value(     &amp;self,     context: &amp;dyn HolonsContextBehavior,     property_name: &amp;PropertyName, ) -&gt; Result, HolonError&gt;; <p>fn related_holons(     &amp;self,     context: &amp;dyn HolonsContextBehavior,     relationship_name: &amp;RelationshipName, ) -&gt; Result; <p>fn all_related_holons(     &amp;self,     context: &amp;dyn HolonsContextBehavior, ) -&gt; Result, HolonError&gt;; <p>fn holon_id(&amp;self, context: &amp;dyn HolonsContextBehavior)     -&gt; Result; <p>fn predecessor(&amp;self, context: &amp;dyn HolonsContextBehavior)     -&gt; Result, HolonError&gt;; <p>fn essential_content(&amp;self, context: &amp;dyn HolonsContextBehavior)     -&gt; Result; <pre><code>---\n\n## WritableHolon\n\n```rust,ignore\nfn with_property_value(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n    property_name: CorePropertyTypeName,\n    value: PropertyValue,\n) -&gt; Result&lt;(), HolonError&gt;;\n\nfn remove_property_value(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n    property_name: CorePropertyTypeName,\n) -&gt; Result&lt;(), HolonError&gt;;\n\nfn add_related_holons(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n    relationship_name: RelationshipName,\n    targets: Vec&lt;HolonReference&gt;,\n) -&gt; Result&lt;(), HolonError&gt;;\n\nfn remove_related_holons(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n    relationship_name: RelationshipName,\n    targets: Vec&lt;HolonReference&gt;,\n) -&gt; Result&lt;(), HolonError&gt;;\n\nfn with_descriptor(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n    descriptor_ref: HolonReference,\n) -&gt; Result&lt;(), HolonError&gt;;\n\nfn with_predecessor(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n    predecessor_ref: Option&lt;HolonReference&gt;,\n) -&gt; Result&lt;(), HolonError&gt;;\n</code></pre>"},{"location":"core/map-deployment-arch/#holoncollectionapi","title":"HolonCollectionApi","text":"<p>```rust,ignore fn len(&amp;self) -&gt; usize; fn is_empty(&amp;self) -&gt; bool; fn first(&amp;self) -&gt; Option&lt;&amp;HolonReference&gt;; fn get(&amp;self, index: usize) -&gt; Option&lt;&amp;HolonReference&gt;; fn get_by_key(&amp;self, key: &amp;MapString) -&gt; Option&lt;&amp;HolonReference&gt;; fn contains(&amp;self, target: &amp;HolonReference) -&gt; bool; fn to_vec(&amp;self) -&gt; Vec; fn add(     &amp;self,     context: &amp;dyn HolonsContextBehavior,     target: HolonReference, ) -&gt; Result&lt;(), HolonError&gt;; fn remove(     &amp;self,     context: &amp;dyn HolonsContextBehavior,     target: HolonReference, ) -&gt; Result&lt;(), HolonError&gt;; <pre><code>---\n\n## Query Layer\n\n```rust,ignore\nfn property_equals(\n    property_name: CorePropertyTypeName,\n    value: PropertyValue,\n) -&gt; QueryExpression;\n\nfn run_query(\n    context: &amp;dyn HolonsContextBehavior,\n    expr: QueryExpression,\n) -&gt; Result&lt;NodeCollection, HolonError&gt;;\n</code></pre> <p>This appendix serves as a concise signature-only reference for all key API areas, grouped by their functional domains.</p>"},{"location":"core/map-deployment-arch/#appendix-b-holonerror-reference","title":"Appendix B \u2013 HolonError Reference","text":"<p>The <code>HolonError</code> enum defines all possible error conditions that may occur while working with holons. Each variant captures a distinct failure domain within the MAP reference layer.</p> Variant Description Common Origin <code>NotAccessible</code> Operation not permitted under current context/kind combination. Attempting to modify a <code>SmartReference</code>; restricted access context. <code>InvalidHolonReference</code> Reference cannot be resolved or is malformed. Dangling or out-of-scope references; deleted holons. <code>InvalidType</code> The provided value or descriptor does not match the expected type. Assigning the wrong <code>ValueType</code> or <code>Descriptor</code>. <code>UnexpectedValueType</code> Runtime value type mismatch (e.g., expected string, found integer). Property read or write with incompatible type. <code>EmptyField</code> A required field or property is missing or empty. Validation of incomplete holon data. <code>MissingDescriptor</code> The holon lacks an associated type descriptor. Loader or schema definition error. <code>MissingRelationship</code> A requested relationship does not exist. Using an undefined relationship name. <code>DuplicateKey</code> Attempted to create or stage a holon with a key that already exists. Staging or import conflicts. <code>StagingConflict</code> Two staged holons conflict on lineage or key. Concurrent edits in the Nursery. <code>CommitFailure</code> One or more holons failed to commit. DHT or persistence layer error. <code>Abandoned</code> The holon was marked abandoned during commit. Validation failure during persistence. <code>InvalidContext</code> The provided context is invalid or no longer active. Using an expired or mismatched context reference. <code>SerializationError</code> Failure to encode or decode a holon or property value. Cross-boundary transmission or storage. <code>DeserializationError</code> Failure to parse persisted data into a holon. Import or cache corruption. <code>NetworkError</code> Communication failure with remote service or DHT. Distributed commit or fetch. <code>InternalError</code> Unexpected internal condition. Logic bugs or invariant violations."},{"location":"core/map-deployment-arch/#example-usage-in-pattern-matches","title":"Example usage in pattern matches","text":"<p><code>rust,ignore match commit(context) {     Ok(resp) if resp.is_complete() =&gt; println!(\"Commit succeeded!\"),     Ok(resp) =&gt; eprintln!(\"Partial commit: {:?}\", resp.summary()),     Err(HolonError::CommitFailure) =&gt; eprintln!(\"Commit failed.\"),     Err(HolonError::NetworkError) =&gt; eprintln!(\"Network issue, retry later.\"),     Err(e) =&gt; eprintln!(\"Unhandled error: {:?}\", e), }</code></p>"},{"location":"core/map-deployment-arch/#notes","title":"Notes","text":"<ul> <li>Most variants are recoverable \u2014 for example, <code>StagingConflict</code> and <code>DuplicateKey</code> can be retried after correction.</li> <li>Use <code>HolonError::to_string()</code> for concise error summaries in logs.</li> <li><code>InternalError</code> and <code>InvalidContext</code> indicate deeper systemic problems that typically warrant investigation.</li> </ul> <p>Together, these definitions provide a full picture of how the MAP reference layer communicates problems \u2014 predictably, type-safely, and with context.</p>"},{"location":"core/map-holons-testing-strategy/","title":"MAP testing follows two general approaches:","text":"<ol> <li>Sweetests leverage Rust's rstest testing framework.</li> <li>Tryorama tests leverages Holochain's Tryorama JavaScript-based testing framework.</li> </ol>"},{"location":"core/map-holons-testing-strategy/#sweetest-integration-tests","title":"Sweetest Integration Tests","text":""},{"location":"core/map-holons-testing-strategy/#test-contexts","title":"Test Contexts","text":"<p>The <code>HolonsContextBehavior</code> trait provides access to a space manager.</p> <pre><code>pub trait HolonsContextBehavior {\n    /// Provides access to the holon space manager for interacting with holons and their relationships.\n    fn get_space_manager(&amp;self) -&gt; Rc&lt;&amp;dyn HolonSpaceBehavior&gt;;\n}\n</code></pre> <p>Concrete implementations of that trait provide access to a HolonSpaceManager that has been configured for either client-side or guest-side use. Note that HolonSpaceManager is a holons_core component, so the source code is the same for both client and guest space managers. They differ in the HolonService they have been injected with upon initialization of their context.</p> <p>The <code>HolonSpaceBehavior</code> trait implemented by HolonSpaceManager provides access to a set of services.</p> <pre><code>pub trait HolonSpaceBehavior {\n    fn get_cache_access(&amp;self) -&gt; Arc&lt;dyn HolonCacheAccess&gt;;\n    fn get_holon_service(&amp;self) -&gt; Arc&lt;dyn HolonServiceApi&gt;;\n    fn get_nursery_access(&amp;self) -&gt; Arc&lt;RefCell&lt;dyn NurseryAccess&gt;&gt;;\n    fn get_space_holon(&amp;self) -&gt; Option&lt;HolonReference&gt;;\n    fn get_staging_behavior_access(&amp;self) -&gt; Arc&lt;RefCell&lt;dyn HolonStagingBehavior&gt;&gt;;\n    fn export_staged_holons(&amp;self) -&gt; SerializableHolonPool;\n    fn import_staged_holons(&amp;self, staged_holons: SerializableHolonPool);\n    fn get_transient_state(&amp;self) -&gt; Rc&lt;RefCell&lt;dyn HolonCollectionApi&gt;&gt;;\n}\n</code></pre> <p>There are three different contexts relevant to sweetests.</p>"},{"location":"core/map-holons-testing-strategy/#fixture_context-client-side","title":"fixture_context (client-side)","text":"<ul> <li> <p>Test fixtures are responsible for setting up the test steps for a given test case along with the test data (holons and relationships) those steps require. Notice that relationships are expressed via <code>HolonReferences</code>. The <code>fixture_context</code> allows access to the actually holon they being references by providing access to the services that resolve them: <code>CacheAccess</code> (for <code>SmartReferences</code>) or <code>NurseryAccess</code> (for <code>StagedReferences</code>).</p> </li> <li> <p>An empty context is initialized by each fixture and goes out of scope when the fixture ends. Fixture contexts are never shipped between client and guest and their <code>Nursery's</code> are never committed.</p> </li> </ul>"},{"location":"core/map-holons-testing-strategy/#test_context-client-side","title":"test_context (client-side)","text":"<ul> <li> <p>Each test case executes within its own client-side context. Test step executors (i.e., the rust functions that implement test steps), use the test_context to stage holons and their relationships (via the NurseryAccess service) and to get persisted holons and their relationships (via the CacheAccess service).</p> </li> <li> <p>an empty context is initialized by the <code>rstest_dance_test</code> function at the beginning of each test case execution and a reference to it (as a <code>&amp;dyn HolonsContextBehavior</code> trait object) is passed as a parameter to each test step executor.   if a test step invokes a dance, its <code>Nursery</code> is shipped to the guest-side via the <code>session_state</code> field on <code>DanceRequest</code>.</p> </li> <li>when the dance result is returned the <code>test_context</code> is restored from <code>session_state</code> so that any changes to the <code>Nursery</code> that were made by the guest are now reflected back in the client's <code>Nursery</code>.</li> <li>the <code>commit_dance</code> persists any staged holons in the <code>Nursery</code>. Once completed successfully, it clears the staged holons and keyed_index from the Nursery, making it available to stage additional holons and relationships.</li> </ul>"},{"location":"core/map-holons-testing-strategy/#guest_context-guest-side","title":"guest_context (guest-side)","text":"<ul> <li>The guest_context is used by dance implementation functions that rely on the space manager and the services it provides.</li> <li>When Dancer's dance function is invoked for a new DanceRequest, it initializes the guest_context from the session_state passed via the DanceRequest.</li> <li>The dancer passes a reference to the context (as a <code>&amp;dyn HolonsContextBehavior</code> trait object) to the DanceFunction it dispatches to handle the dance request.</li> <li>DanceFunctions may perform operations that add, remove, update or clear the Nursery.</li> <li>The dancer is responsible for including the updated Nursery via the session_state field in the DanceResponse.</li> </ul>"},{"location":"core/map-holons-testing-strategy/#rstest_dance_tests-function","title":"rstest_dance_tests Function","text":"<p>Sweetests are organized around a set of test cases. Since the external API to the MAP guest is organized around dances, all integration testing is driven from the dances crate -- specifically, the <code>rstest_dance_tests</code> function defined in the <code>dances_tests.rs</code> module.</p> <pre><code>#[rstest]\n#[case::simple_undescribed_create_holon_test(simple_create_holon_fixture())]\n#[case::simple_add_related_holon_test(simple_add_remove_related_holons_fixture())]\n\n#[tokio::test(flavor = \"multi_thread\")]\nasync fn rstest_dance_tests(#[case] input: Result&lt;DancesTestCase, HolonError&gt;)\n</code></pre> <p>Notice this function is parameterized by <code>#[case]</code>. Preceding the function declaration with one or more <code>#[case]</code> statements allows selective control over which test cases are invoked in any given test run. For example, the following code will result in the <code>rstest_dance_tests</code> function being invoked twice -- once for the <code>simple_undescribed_create_holon_test</code> case and once for the <code>simple_add_related_holon_test</code> case. Each test case is invoked asynchronously and independently from other test cases.</p> <p>Each case has an associated fixture function that sets up the test steps and associated data for that test case and returns a <code>DancesTestCase</code> object that is passed as an input parameter to the <code>rstest_dance_tests</code> function. Every test case follows the same basic flow: 1. Initialization -- sets up tracing, a mock conductor, an empty <code>HolonsContext</code>, and an empty <code>test_state</code>. Note that <code>test_context</code> is different from the <code>fixture_context</code> used by the fixture and the <code>guest_context</code> used by the back-end (guest-side) during dance execution (as described above). 2. Test Step Execution. Unpack the test case and iterate through the steps for that test case. Matching on the test step allows different <code>execute_xxx</code> functions to be dispatched for each kind of test step.</p> <p>The <code>test_state</code> accumulates state as the test case progresses and a mutable reference to it is passed into every test step executor.</p> <pre><code>// from dances/tests/shared_test/test_data_types.rs\npub struct DanceTestState {\n    pub session_state: SessionState,\n    pub created_holons: BTreeMap&lt;MapString, Holon&gt;,\n}\n</code></pre> <p>The <code>session_state</code> field holds the state that is ping-ponged back and forth between client and guest. The <code>created_holons</code> map allows holons that have been successfully committed during the execution of this test case to be retrieved via their key in later test steps.</p> <pre><code>// from dances/src/session_state.rs\npub struct SessionState {\n    staging_area: StagingArea,\n    local_holon_space: Option&lt;HolonReference&gt;,\n}\n\n// from dances/src/staging_area.rs\npub struct StagingArea {\n    staged_holons: Vec&lt;Holon&gt;,         // Contains all holons staged for commit\n    index: BTreeMap&lt;MapString, usize&gt;, // Allows lookup by key to staged holons for which keys are defined\n}\n</code></pre> <p>The <code>session_state</code> is included as part of the <code>DanceRequest</code> by the <code>build_xxx_</code> function. It is part of every dance call and is restored from the <code>DanceResponse</code> when a response is received.</p> <p>```let response: DanceResponse = conductor.call(&amp;_cell.zome(\"dances\"), \"dance\", valid_request).await; _test_state.session_state = response.state.clone(); <pre><code>## Test Fixtures\nEach case has an associated fixture function that sets up the test steps and associated data for that test case and returns a `DancesTestCase` object that is passed as an input parameter to the `rstest_dance_tests` function. The fixture can stage a set of holons and relationships in its `fixture_context`. Such holons can be supplied to the `test_steps` the fixture is setting up in order to supply the data required by that `test_step`.\n\n## Test Data Types\n\nWe have defined a set of data structures and protocols designed to make it easier to quickly define test cases.\n\n### DanceTestStep\n\nEach test case is composed of a set of test steps. Test steps are defined independently so that may be reused in different test cases. The `DanceTestStep` enum defines the set of available test steps and the data associated with each test step. Here is an excerpt:\n</code></pre> pub enum DanceTestStep {   AbandonStagedChanges(StagedReference, ResponseStatusCode), // Marks a staged Holon as 'abandoned'     AddRelatedHolons(         StagedReference,         RelationshipName,         Vec,         ResponseStatusCode,         Holon,     ), // Adds relationship between two Holons     Commit,       <p>} <pre><code>Each test step generally invokes one or more dances.\n\n### DancesTestCase\n\nEach test case is defined by an instance of DancesTestCase:\n</code></pre> pub struct DancesTestCase {     pub name: String,     pub description: String,     pub steps: VecDeque,     pub test_session_state: TestSessionState, } <p>pub struct TestSessionState {     transient_holons: SerializableHolonPool, } <pre><code>Including `test_session_state` in the `DancesTestCase` allows the TransientHolons created by a fixture to be passed from the `fixture_context` into the `test_context`. As part of its initialization sequence, the `rstest_dance_tests` function initializes its `test_context` from the `test_session_state`. This means the `test_context's` TransientHolonManager will start with its HolonPool in the same state as the `fixture_context's` HolonPool. **_Key Takeaway: any TransientReferences created by the fixture are resolvable within the test_context_**. However, the fixtures Nursery is NOT passed into the test context. This means that StagedReferences created in the fixture are NOT resolvable in the `test_context`. For this reason, _**fixtures should NOT, themselves, stage any holons.**_\n\nNotice that the test case defines a sequential set of steps. `DancesTestCase` offers a set of `add_xxx_step` methods that allow test steps to be added to the test case, where xxx specifies a particular a specific test step. For example, the following method adds a stage_holon_step to test case.\n</code></pre>  pub fn add_stage_holon_step(&amp;mut self, holon: TransientReference) -&gt; Result&lt;(), HolonError&gt; {         self.steps.push_back(DanceTestStep::StageHolon(holon));         Ok(())     } <pre><code>Notice the holon to be staged is identified via its TransientReference. Since this reference will resolve in the test_context, the test_stage_new_holon function can resolve that reference during test execution.\n\n### Referencing Holons Staged or Saved within a Test Case Execution\n\nSome test cases require the ability to refer to holons staged or saved in earlier test steps. For example, suppose I want to add related holons (either staged or saved) to a holon staged in a prior step. Likewise, in the `stage_new_from_clone` test case we want to test the ability so clone a transient holon, staged holon, and saved holon (to make sure all three possibilities are tested).\n\nThe fixture doesn't know what temporary id the test executor will assign for the holons staged during the test, nor does it know what HolonId will be assigned by holochain for holons committed to the DHT during the test. **_So how can it pass references to those holon to subsequent steps it is adding to the test case?_**\n\n\n### Current Approach: Test References and DanceTestExecutionState\n\nOur current solution was implemented prior to the introduction of the TransientHolonManager. This section describes the current approach and is then followed by a proposed approach.\n</code></pre> pub struct DanceTestExecutionState {     context: Arc,     pub dance_call_service: Arc&gt;,     pub created_holons: BTreeMap, } <pre><code>### TestReference\n\n`TestReferences` are created by fixtures. They are used to pass references to holons created in prior test steps to be passed into subsequent test steps. For example, the `simple_stage_new_from_clone_fixture`:\n\n1. Stages several holons into the fixture's Nursery\n2. Adds a `stage_new_from_clone_step` to the TestCase that (during execution phase) will stage a new holon that is a clone of one of the previously staged holons.\n2. Adds a stageClones the staged holon\n3. Phase 2 clones a saved holon, changes some of its\\n\\\n   properties, adds a relationship, commits it and then compares essential content of existing \\n\\\n   holon and cloned holon\n</code></pre> pub enum TestReference {     SavedHolon(MapString),     StagedHolon(StagedReference),     TransientHolon(TransientReference), } ```"},{"location":"core/map-holons-testing-strategy/#tryorama-tests-tbd","title":"Tryorama Tests (TBD)","text":""},{"location":"core/map-type-system-revised/","title":"MAP Type System","text":"<p>The MAP Type System provides a holonic, self-describing, and extensible foundation for representing knowledge in an agent-centric world. Every type in MAP is a holon \u2014 a versioned, queryable, and linkable unit of meaning. Every holon is, in turn, typed \u2014 grounded in a rich schema of interrelated descriptors.</p> <p>This holonic approach means:</p> <ul> <li>Types can describe types.</li> <li>Types can inherit from other types.</li> <li>Types can be extended, queried, and versioned just like data.</li> </ul> <p>The MAP Type System enables agents to: - Define their own schemas and vocabularies - Share and evolve types collaboratively - Validate, introspect, and visualize holons at runtime</p> <p></p> <p>This document introduces the architecture of the MAP Type System, structured into three foundational layers and supported by unified schema import, key rules, and introspection semantics.</p>"},{"location":"core/map-type-system-revised/#1-introduction-what-is-the-map-type-system","title":"1. Introduction: What Is the MAP Type System?","text":"<p>The MAP Type System is: - \ud83e\udde0 Self-describing \u2014 Every type is a holon, and every holon can describe itself. - \ud83e\uddf1 Compositional \u2014 Holons can be connected through typed relationships to build meaningful graphs. - \ud83d\udd0d Introspectable \u2014 Any holon can answer:   \u2192 What kind of Holon am I?   \u2192 What properties do I have?   \u2192 What relationships do I participate in? - \ud83c\udf31 Extensible \u2014 Agents can define new types without altering the core codebase.</p>"},{"location":"core/map-type-system-revised/#maps-ontology-as-data-meta-modeling-approach","title":"MAP\u2019s Ontology-as-Data Meta-Modeling Approach","text":"<p>The Memetic Activation Platform (MAP) models its entire ontology as data\u2014not as code, not as syntax-bound models, but as a fully introspectable, declarative system of holons. Every type, property, relationship, and rule in the MAP ecosystem is represented as a holon\u2014a data entity described by other data entities\u2014creating a self-describing, semantically rigorous system.</p>"},{"location":"core/map-type-system-revised/#what-it-is","title":"What It Is","text":"<ul> <li>Ontology-as-data: All type system elements (e.g. <code>BookType</code>, <code>MetaEnumValueType</code>, <code>MapStringValueType</code>) are modeled as structured data instances. These are holons described by <code>TypeDescriptor</code> holons, forming a fully reflective type graph.</li> <li>Declarative architecture: Relationships, constraints, and inheritance are declared explicitly, rather than implied by code or assumed by syntax. Examples include <code>Extends</code>, <code>InstanceProperties</code>, and <code>UsesKeyRule</code>.</li> <li>Syntax-independent: The data model is not coupled to any specific concrete syntax like OWL, LinkML, JSON Schema, or Ecore. This allows MAP to remain neutral and flexible.</li> <li>Portable and generative: Because the ontology is described entirely in data, it can be programmatically transformed into any number of target modeling formats, including OWL (RDF), Ecore, LinkML, JSON Schema, or domain-specific APIs.</li> </ul>"},{"location":"core/map-type-system-revised/#why-this-matters","title":"Why This Matters","text":"<ul> <li>Interoperability: By remaining syntax-agnostic, MAP avoids vendor lock-in and promotes compatibility across tooling ecosystems.</li> <li>Transparency and introspection: Every element of the type system is visible and inspectable\u2014users and systems can query, reason about, and validate types and their relationships using the same underlying structures.</li> <li>Extensibility: New type kinds, validation rules, or relationship semantics can be introduced declaratively without requiring changes to core code or parsers.</li> <li>Automation: The data-native structure supports auto-generation of syntax-bound schemas, documentation, forms, validators, and converters across ecosystems.</li> <li>Evolvability: Standards, formats, and tools evolve over time. By anchoring the MAP ontology in a neutral, declarative core, it remains resilient to external changes. New representations can be generated as needed, without requiring redefinition of the underlying semantics.</li> </ul>"},{"location":"core/map-type-system-revised/#a-foundation-for-federated-semantics","title":"A Foundation for Federated Semantics","text":"<p>This architecture positions MAP not just as a platform, but as a semantic engine capable of supporting fluid translation between formal modeling environments. It is particularly well-suited to decentralized systems, federated knowledge graphs, and commons-oriented technology\u2014where semantic clarity, flexibility, and sovereignty are paramount.</p>"},{"location":"core/map-type-system-revised/#2-organizing-the-map-type-system","title":"2. Organizing the MAP Type System","text":"<p>At the heart of the MAP architecture is a self-describing type system built entirely from data. The foundational building block of this system is the TypeDescriptor\u2014a holon that defines the structure, semantics, and constraints of a particular type within MAP. These TypeDescriptors describe not only data instances, but also other types, enabling a fully introspectable and evolvable modeling framework.</p> <p>A relatively small number of these type descriptors are \"built-in\" to the MAP. These provide the foundation from which an open-ended set of types can be derived.</p> <p>TypeDescriptors are grouped into schemas, which are cohesive collections of related type definitions. Each schema defines its own conceptual namespace and boundary of meaning. In turn, every schema is stewarded within a single HolonSpace, anchoring it in a governance and trust context. While a schema belongs to exactly one HolonSpace, it may be referenced by types or instances across other spaces, supporting reuse and interoperability without centralization.</p> <p>This layered organization follows a clear pattern:</p> <ul> <li>TypeDescriptors define types.</li> <li>Schemas group TypeDescriptors.</li> <li>HolonSpaces steward schemas.</li> </ul> <p>This structure allows types to evolve in well-bounded contexts while participating in broader federated semantics.</p>"},{"location":"core/map-type-system-revised/#type-kind-a-semantic-organizing-principle","title":"Type Kind: A Semantic Organizing Principle","text":"<p>Every TypeDescriptor in MAP declares a type kind\u2014a high-level classification that serves dual purposes:  1. Organizational: They help group and reason about types across schemas. All <code>Relationship</code> types, for instance, share common structural expectations and validation behavior. 2. Semantic: They convey the ontological category of the type\u2014what kind of \"thing\" it is in the MAP worldview.</p> <p>In this way, Type Kind functions as a semantic meta-tag that informs how a type is expected to behave, how it is validated, and how it can be composed within other types. While it doesn't encode structure directly (like <code>DescribedBy</code> or <code>Extends</code>), <code>type_kind</code> plays a central role in how types are declared, introspected, and extended across the system.</p>"},{"location":"core/map-type-system-revised/#complete-list-of-type-kinds","title":"$ \ud83d\udcda Complete List of Type Kinds","text":"<p>The current set of supported Type Kinds is listed in the following table. This set will continue to evolve as the MAP matures. Adding Type Kinds (e.g., adding support for a Value(Video) Type Kind) requires a new MAP release. Adding <code>TypeDescriptors</code> does not. </p> Type Kind Category Description <code>Holon</code> Structural Describes a type that classifies data-bearing holons <code>Property</code> Structural Describes a scalar property of a holon <code>Relationship</code> Structural Describes a directed link between holons <code>EnumVariant</code> Structural Describes a variant in a defined enum <code>Collection</code> Structural Describes a named group or set of holons <code>Dance</code> Behavioral Describes an interactive protocol or workflow <code>Value(String)</code> Scalar Value A scalar value based on a string <code>Value(Integer)</code> Scalar Value A scalar value based on an integer <code>Value(Boolean)</code> Scalar Value A scalar value based on a boolean <code>Value(Enum)</code> Scalar Value A scalar value selected from a known enumeration <code>Value(Bytes)</code> Scalar Value A binary value serialized as base64 <code>ValueArray(String)</code> Scalar Array An array of strings <code>ValueArray(Integer)</code> Scalar Array An array of integers <code>ValueArray(Boolean)</code> Scalar Array An array of booleans <code>ValueArray(Enum)</code> Scalar Array An array of enum values <code>ValueArray(Bytes)</code> Scalar Array An array of binary values"},{"location":"core/map-type-system-revised/#3-four-level-model","title":"3. Four-Level Model","text":"<p>To support full self-description, schema extensibility, and type safety, MAP organizes its entire type system using a four-level model. This layered structure spans from abstract meta-concepts to concrete, instantiable types and data.</p> <p></p> \ud83d\udd17 Compositional Inheritance via <code>Extends</code> <p>MAP embraces compositional inheritance as its primary structuring mechanism. Rather than relying on rigid class hierarchies, MAP types declare structure by extending other types \u2014 combining properties, relationships, and semantic expectations through composition.</p> <pre><code>The `Extends` relationship is used throughout the type system to:\n- Declare that a type fulfills the obligations of a more general type\n- Inherit shared properties and relationship definitions\n- Align a descriptor with the structural pattern of its kind\n\nThis enables:\n- Meta-types to declare required features (Level 1)\n- Abstract types to specialize those features per TypeKind (Level 2)\n- Concrete types to fulfill both (Level 3)\n\n&gt; Compositional inheritance keeps MAP types modular, transparent, and incrementally extensible \u2014 without locking them into brittle class hierarchies.\n</code></pre>"},{"location":"core/map-type-system-revised/#level-1-meta-types","title":"\ud83e\uddf1 Level 1: Meta-Types","text":"<p>Meta-types define the structural obligations for categories of types. Each meta-type declares: - Required <code>InstanceProperties</code> and <code>InstanceRelationships</code> (and, soon, <code>Validations</code> and <code>Dances</code>) - The <code>type_kind</code> it governs</p> <p>Examples: - <code>MetaPropertyType</code> defines the structure of all <code>PropertyType</code> descriptors - <code>MetaRelationshipType</code> defines shared expectations for relationship descriptors - <code>MetaTypeDescriptor</code> defines common expectations for all descriptor types</p> <p>These are the most abstract holons. They describe the kinds of type descriptors MAP supports.</p> <p>Top-Level Meta-types themselves extend nothing \u2014 their obligations are fulfilled for them, not by them. Meta-Types can have sub-meta types that <code>Extend</code> them (e.g., <code>MetaInverseRelationship</code> <code>Extends</code> <code>MetaRelationship</code>).</p>"},{"location":"core/map-type-system-revised/#level-2-abstract-type-descriptors","title":"\ud83e\udde9 Level 2: Abstract Type Descriptors","text":"<p>Abstract type descriptors <code>Extend</code> meta-types and anchor relationships for a type kind. </p> <p>Examples: - <code>PropertyType</code> extends <code>MetaPropertyType</code> - <code>HolonType</code> extends <code>MetaHolonType</code> - <code>EnumValueType</code> extends <code>MetaEnumValueType</code></p> <p>These abstract types are not instantiated directly. They serve as category-specific templates for concrete descriptors and provide end-points for core relationships.</p>"},{"location":"core/map-type-system-revised/#level-3-concrete-typedescriptors","title":"\ud83d\udce6 Level 3: Concrete TypeDescriptors","text":"<p>Concrete <code>TypeDescriptor</code> holons define actual, instantiable MAP types. These are the types agents use to define schemas and classify holons. Concrete type descriptors <code>Extend</code> (and fulfill the obligations of) BOTH <code>TypeDescriptor</code> AND the Abstract Type specific to their TypeKind</p> <p>Each concrete descriptor: - Extends both an Abstract Type and TypeDescriptor - Is a holon that participates in schemas - Carries metadata (<code>type_name</code>, <code>description</code>, etc.) - Declares structure via <code>InstanceProperties</code> and <code>InstanceRelationships</code></p> <p>Examples: - <code>BookType</code> extends <code>TypeDescriptor</code> and <code>HolonType</code> - <code>MapStringValueType</code> extends <code>TypeDescriptor</code> and <code>StringValueType</code> - <code>HAS_AUTHOR</code> extends <code>TypeDescriptor</code> and <code>DeclaredRelationshipType</code></p> <p>Every concrete type in MAP is described by a single, self-contained <code>TypeDescriptor</code>.</p>"},{"location":"core/map-type-system-revised/#level-4-instances-of-types","title":"\ud83d\udd01 Level 4: Instances of Types","text":"<p>These are the actual holons that populate MAP Spaces. They: - Are typed by one of the concrete type descriptors (via <code>DescribedBy</code>) - Include values for properties and relationships specified by their type - May be keyed or keyless, depending on the <code>UsesKeyRule</code> of their type</p> <p>Examples: - <code>\"Future Primal\"</code> is an instance of <code>BookType</code> - <code>\"title\"</code> is an instance of <code>PropertyName</code> - <code>\"LibrarySchema\"</code> is an instance of <code>SchemaName</code></p> <p>Holons in this layer are the data-level objects that conform to a schema.</p>"},{"location":"core/map-type-system-revised/#typedescriptor-the-keystone-type","title":"\ud83e\udde0 TypeDescriptor: The Keystone Type","text":"<p>The <code>TypeDescriptor</code> holon plays a special dual role in this hierarchy:</p> <ul> <li>It is a concrete type descriptor (Level 3)</li> <li>It is the type used to describe all other type descriptors, including itself (Level 4)</li> <li>It extends both <code>MetaTypeDescriptor</code> and <code>HolonType</code>, fulfilling the obligations of both</li> </ul> <p>This elegant recursion prevents infinite regress and anchors MAP\u2019s fully self-describing architecture.</p>"},{"location":"core/map-type-system-revised/#abstract-types-as-anchors","title":"\ud83e\udde9 Abstract Types as Anchors","text":"<p>In MAP, every relationship type (such as <code>DescribedBy</code>, <code>InstanceProperties</code>, or <code>ValueType</code>) must declare a <code>SourceType</code> and a <code>TargetType</code>. These define which types of holons a relationship is valid between.</p> <p>To support reusable relationships across many schemas and domains, MAP anchors relationship types to abstract type descriptors. For example: - The <code>DescribedBy</code> relationship has <code>HolonType</code> (abstract) as its <code>TargetType</code> - The <code>ValueType</code> relationship has <code>PropertyType</code> (abstract) as its <code>SourceType</code></p> <p>While these abstract types are not instantiable, they are valid, referenceable holons in their own right\u2014each described by a <code>TypeDescriptor</code>. This means they can serve as targets in relationships, enabling relationship types to be defined at the abstract level and reused across all concrete types that extend them.</p> <p>\ud83d\udd0d In practice: when a concrete type descriptor (like <code>BookType</code>) declares a relationship such as <code>HAS_AUTHOR</code>, the validation logic walks the <code>Extends</code> chain to ensure that the concrete type conforms to the <code>SourceType</code> and <code>TargetType</code> expectations anchored in the abstract layer.</p> <p>This leads to a clean separation: - Core relationships are defined once and anchored to abstract types. - Concrete descriptors, whether core or domain-specific, extend those abstract types and automatically participate in those relationships.</p>"},{"location":"core/map-type-system-revised/#validation-behavior","title":"Validation Behavior","text":"<p>The use of abstract types as anchors supports a flexible but robust validation model: - Holon instances must be <code>DescribedBy</code> a concrete type descriptor. - Relationship instances (e.g., SmartLinks) are validated by:   1. Looking up the <code>SourceType</code> and <code>TargetType</code> of the relationship's descriptor   2. Ensuring the instance's actual types extend (or are equal to) those expected types</p> <p>This allows core relationships to be broadly defined and applied without coupling them to specific schemas or concrete descriptors.</p>"},{"location":"core/map-type-system-revised/#domain-extensions","title":"Domain Extensions","text":"<p>Domain-specific types (e.g., <code>BookType</code>, <code>FilmType</code>) are: - <code>DescribedBy</code> \u2192 <code>TypeDescriptor</code> - <code>Extend</code> \u2192 their TypeKind's abstract template (e.g., <code>HolonType</code>)</p> <p>These extension types never extend a concrete core type like <code>HolonType</code>; instead, they instantiate their own concrete descriptors aligned with the abstract templates.</p> <p>This means that application developers never need to deal with meta-types or abstract scaffolding directly\u2014they simply define concrete types that extend templates and conform to a known pattern.</p>"},{"location":"core/map-type-system-revised/#design-principles-recap","title":"\ud83d\udccc Design Principles Recap","text":"<ul> <li>Each Type Kind has a single (top-level) Meta Type </li> <li>Meta Types declare a Type Kind\u2019s obligations via instance properties and instance relationships.</li> <li>Top-level Meta Types do not <code>Extend</code> anything \u2014 their obligations are fulfilled for them, not by them.</li> <li>Meta Types may have sub\u2013meta types that <code>Extend</code> them (e.g., <code>MetaInverseRelationship</code> <code>Extends</code> <code>MetaRelationship</code>).</li> <li>Abstract type descriptors <code>Extend</code> Meta Types and anchor core relationship types for a Type Kind.</li> <li>Each MAP type is <code>DescribedBy</code> a single concrete Type Descriptor.</li> <li><code>TypeDescriptor</code> declares the instance properties and instance relationships shared by all type descriptors (including itself).</li> <li><code>TypeDescriptor</code> is a concrete Type Descriptor that <code>Extends</code> both <code>MetaTypeDescriptor</code> and the abstract <code>HolonType</code>. It acts as both an abstract and a concrete type, preventing infinite regress.</li> <li>Concrete Type Descriptors <code>Extend</code> both the general <code>TypeDescriptor</code> and the Abstract Type for their Type Kind, fulfilling both.</li> </ul> <p>This 4-level model ensures that types, schemas, and even schema-of-schemas are composable, inspectable, and extensible \u2014 enabling MAP to support open-ended, agent-defined semantics.</p>"},{"location":"core/map-type-system-revised/#map-type-system-design-abstract-types-as-anchors","title":"\ud83e\udded MAP Type System Design: Abstract Types as Anchors","text":"<p>This document formalizes the design principle that abstract types serve as anchors for relationship definitions within the MAP type system. This approach preserves both the structural integrity of the type system and the flexibility needed for large-scale domain modeling.</p>"},{"location":"core/map-type-system-revised/#starting-premises","title":"\u2705 Starting Premises","text":"Concept Clarification Abstract types Are real holons with referenceable identity. They are <code>TypeDescriptor</code> instances with <code>is_abstract_type = true</code>. They are not instantiable (i.e., no holon may declare <code>DescribedBy \u2192 [abstract type]</code>). Concrete types Are also <code>TypeDescriptor</code>s, but with <code>is_abstract_type = false</code>. They can be used in <code>DescribedBy</code> to describe holons. Relationship types Are concrete <code>DeclaredRelationshipType</code> holons that declare their expected <code>SourceType</code> and <code>TargetType</code>. SmartLink validation Ensures that the holons involved in a SmartLink conform to the type constraints of the relationship type. This requires comparing the <code>DescribedBy</code> of the source/target holons to the relationship type\u2019s <code>SourceType</code> and <code>TargetType</code>."},{"location":"core/map-type-system-revised/#design-principle-abstract-types-as-anchors","title":"\ud83e\udde9 Design Principle: Abstract Types as Anchors","text":""},{"location":"core/map-type-system-revised/#core-concept","title":"\ud83d\udcd0 Core Concept","text":"<p>Abstract types (e.g., <code>HolonTypeTemplate</code>, <code>PropertyType</code>, <code>ValueType</code>) are used as the <code>SourceType</code> and <code>TargetType</code> in the declaration of relationship types.</p> <p>Validation is based not on strict equality, but on type conformance: A holon is valid as the source or target of a SmartLink if its <code>DescribedBy</code> extends the relationship\u2019s <code>SourceType</code> or <code>TargetType</code>.</p>"},{"location":"core/map-type-system-revised/#smartlink-validation-rule","title":"\u2705 SmartLink Validation Rule","text":"<p>When validating a SmartLink instance:</p> <ul> <li>Let <code>R</code> be the <code>DeclaredRelationshipType</code> describing the link</li> <li>Let <code>S</code> be the source holon</li> <li>Let <code>T</code> be the target holon</li> <li>Then the SmartLink is valid if:</li> <li><code>S.DescribedBy</code> Extends <code>R.SourceType</code></li> <li><code>T.DescribedBy</code> Extends <code>R.TargetType</code></li> </ul> <p>This preserves the non-instantiability of abstract types while still allowing them to define broad, reusable relationship categories.</p>"},{"location":"core/map-type-system-revised/#why-this-matters_1","title":"\ud83e\udde0 Why This Matters","text":"<ul> <li>Abstract types define type-kind-specific obligations via their <code>InstanceProperties</code> and <code>InstanceRelationships</code>.</li> <li>They act as anchors for relationships such as:</li> <li><code>(PropertyType)-[ValueType]-&gt;(ValueType)</code></li> <li><code>(HolonType)-[InstanceProperties]-&gt;(PropertyType)</code></li> <li><code>(RelationshipType)-[SourceType]-&gt;(HolonType)</code></li> <li>Domain-specific concrete types (e.g., <code>Book.HolonType</code>) extend these abstract types and inherit their structural expectations.</li> </ul>"},{"location":"core/map-type-system-revised/#example-author-relationship","title":"\ud83d\udd17 Example: Author Relationship","text":""},{"location":"core/map-type-system-revised/#relationship-definition","title":"Relationship Definition","text":"<pre><code>{\n  \"key\": \"(Holon)-[AuthorOf]-&gt;(Holon)\",\n  \"type\": \"#TypeDescriptor\",\n  \"properties\": {\n    \"type_name\": \"AuthorOf\",\n    \"type_kind\": \"Relationship\",\n    \"is_abstract_type\": false\n  },\n  \"relationships\": [\n    { \"name\": \"Extends\", \"target\": \"#DeclaredRelationshipType\" },\n    { \"name\": \"SourceType\", \"target\": \"#Person.HolonTypeTemplate\" },\n    { \"name\": \"TargetType\", \"target\": \"#CreativeWork.HolonTypeTemplate\" }\n  ]\n}\n</code></pre>"},{"location":"core/map-type-system-revised/#valid-smartlink","title":"Valid SmartLink","text":"<pre><code>{\n  \"key\": \"person123-authorOf-book456\",\n  \"type\": \"#AuthorOf\",\n  \"source\": \"#person123\",\n  \"target\": \"#book456\"\n}\n</code></pre> <p>Where:</p> <ul> <li><code>person123.DescribedBy \u2192 Person.HolonType</code></li> <li> <p><code>Person.HolonType Extends \u2192 Person.HolonTypeTemplate</code></p> </li> <li> <p><code>book456.DescribedBy \u2192 Book.HolonType</code></p> </li> <li><code>Book.HolonType Extends \u2192 CreativeWork.HolonTypeTemplate</code></li> </ul> <p>\u2705 The validation passes: the SmartLink conforms because both source and target types extend the expected abstract anchors.</p>"},{"location":"core/map-type-system-revised/#summary","title":"\u2705 Summary","text":"<p>This approach provides: - A unified, extensible model of type descriptors - Support for validation against abstract categories - Clean modeling of relationship expectations without sacrificing type safety - A clear separation between instantiable and non-instantiable types</p> <p>By anchoring relationships in abstract types and validating against the extension hierarchy, MAP maintains both strict type safety and maximal reuse of schema structures.</p> <p>Several of the <code>type_kind</code> variants \u2014 such as <code>Value(String)</code>, <code>Value(Boolean)</code>, or <code>ValueArray(Enum)</code> \u2014 correspond to scalar value types. These are backed by a fixed set of Base Types that define how values are represented, stored, and validated across environments. Let\u2019s look next at the Base Types and Base Values that support these value type kinds.</p>"},{"location":"core/map-type-system-revised/#base-types-and-base-values","title":"Base Types and Base Values","text":"<p>BaseTypes are the foundational, portable types in the MAP system. A Base Type determines how a given value is represented across programming environments \u2014 such as Rust on the backend and TypeScript or JSON on the client. The Base Types layer includes scalar types (e.g., MapInteger, MapString) and compound types (e.g., MapBytes). The set of Base Types is fixed for any given version of the MAP. Changes or additions to any of these types requires a recompile of the MAP code and an evolution of the persistent data stored using a prior version of the MAP.</p> <p>\u2705 Principle: Preserve Type Identity Across Platforms * The Base Type name should be treated as portable name, used consistently across environments, and interpretable as such by the MAP type system. * In Rust, we get this via <code>pub struct MapString(pub String)</code> \u2014 which gives us a unique type identity at the compiler level. * In TypeScript, and even JSON, we can do similar things \u2014 not with strong typing, but through type aliases, tagging, or enforced schema constraints.</p>"},{"location":"core/map-type-system-revised/#current-base-types-with-portable-name-bindings","title":"Current Base Types with Portable Name Bindings","text":"<p>The following table shows each MAP Base Type alongside its language-specific bindings and its portable JSON representation.</p> Base Type Rust Binding TypeScript Binding JSON Binding (Tagged Format) <code>MapString</code> <code>pub struct MapString(pub String)</code> <code>export type MapString = string;</code> <code>{ \"type\": \"MapString\", \"value\": \"...\" }</code> <code>MapBoolean</code> <code>pub struct MapBoolean(pub bool)</code> <code>export type MapBoolean = boolean;</code> <code>{ \"type\": \"MapBoolean\", \"value\": true }</code> <code>MapInteger</code> <code>pub struct MapInteger(pub i64)</code> <code>export type MapInteger = number;</code> <code>{ \"type\": \"MapInteger\", \"value\": 42 }</code> <code>MapEnumValue</code> <code>pub struct MapEnumValue(pub String)</code> <code>export type MapEnumValue = string;</code> <code>{ \"type\": \"MapEnumValue\", \"value\": \"DRAFT\" }</code> <code>MapBytes</code> <code>pub struct MapBytes(pub Vec&lt;u8&gt;)</code> <code>export type MapBytes = string; // base64</code> <code>{ \"type\": \"MapBytes\", \"value\": \"aGVsbG8=\" }</code>"},{"location":"core/map-type-system-revised/#base-values","title":"Base Values","text":"<p>MAP represents actual runtime values using the <code>BaseValue</code> enum. This enum wraps each of the base types, enabling them to be used uniformly in property maps, serialized holons, and validation contexts.</p> <pre><code>pub enum BaseValue {\n    StringValue(MapString),\n    BooleanValue(MapBoolean),\n    IntegerValue(MapInteger),\n    EnumValue(MapEnumValue),\n    BytesValue(MapBytes),\n}\n</code></pre> <p>Each variant corresponds to a specific MAP Base Type. This allows property values to be stored and inspected in a type-safe and introspectable way.</p> <p>Only <code>BaseValue</code> variants may be used as <code>PropertyValue</code>s within a holon's <code>PropertyMap</code>:</p> <pre><code>pub type PropertyValue = BaseValue;\npub type PropertyMap = BTreeMap&lt;PropertyName, Option&lt;PropertyValue&gt;&gt;;\n</code></pre> <p>By wrapping all scalar values in a unified enum, MAP ensures that holon properties are portable, self-describing, and easy to serialize and deserialize across environments.</p>"},{"location":"core/map-type-system-revised/#notes","title":"Notes","text":"<ul> <li> <p>Rust bindings use the newtype pattern (e.g. <code>pub struct MapString(pub String)</code>) to distinguish each base type with a unique identity while still leveraging native Rust primitives. This allows custom trait implementations, typed serialization, and compile-time safety.</p> </li> <li> <p>All types derive <code>Clone</code>, <code>PartialEq</code>, and other basic traits, ensuring they are usable in Holochain entry types, maps, and standard logic.</p> </li> <li> <p>Display implementations are provided for all base types and for <code>BaseValue</code>, with formatting that is human-readable and variant-specific. This is especially helpful for debugging, logging, or visualization.</p> </li> <li> <p><code>BaseValue</code> acts as the unified runtime representation of scalar values. Its variant names are aligned with the base type wrappers (e.g., <code>StringValue(MapString)</code>), and it includes:</p> </li> <li>A method <code>into_bytes()</code> for deterministic binary encoding</li> <li>A <code>Display</code> implementation</li> <li> <p>A <code>From&lt;&amp;BaseValue&gt; for String</code> conversion (via <code>Into&lt;String&gt;</code>)</p> </li> <li> <p>TypeScript bindings are currently defined as simple aliases (e.g., <code>type MapString = string</code>) for interoperability with JSON and browser-based UIs. This preserves the MAP naming scheme in typed code.</p> </li> <li> <p>JSON bindings assume a tagged format for clarity and round-tripping, such as:</p> </li> </ul> <p>{   \"type\": \"StringValue\",   \"value\": \"Hello\"   }</p> <ul> <li> <p><code>ValueType</code> defines the kind of scalar value a property can hold, and is used within type descriptors to constrain values semantically (e.g., enforce that a field is a <code>String</code>, <code>Integer</code>, etc.).</p> </li> <li> <p>The previously defined <code>BaseType</code> enum has been removed. Its responsibilities are now handled more cleanly by:</p> </li> <li><code>TypeKind</code> \u2014 for classifying descriptors at the schema level (e.g., <code>Property</code>, <code>Value</code>, <code>Relationship</code>)</li> <li><code>ValueType</code> \u2014 for describing scalar semantics in descriptors</li> <li><code>BaseValue</code> \u2014 for representing actual runtime values</li> </ul>"},{"location":"core/map-type-system-revised/#older-stuff-ignore-everything-that-follows","title":"OLDER STUFF -- Ignore everything that follows","text":"<p>MAP distinguishes types by their role in the type system. Each layer builds on the one below it:</p> Layer Role Example Types Meta Types Describe types themselves <code>MetaPropertyType</code>, <code>MetaHolonType</code> Core Types Used by MAP system logic and behavior <code>PropertyType</code>, <code>SchemaName</code> Extension Types Defined by agents to model domains <code>BookType</code>, <code>LibrarySchema</code> <ul> <li>Meta Types form the introspective backbone of MAP \u2014 they define how all other types are structured and understood.</li> <li>Core Types provide the foundational categories and semantic roles that MAP depends on to validate, model, and interpret holons.</li> <li>Extension Types let agents build on the core by defining their own reusable, introspectable structures \u2014 without any need to modify system logic.</li> </ul> <p>Each type in MAP is a holon, and every holon is typed by another holon \u2014 its TypeDescriptor \u2014 via the <code>DescribedBy</code> relationship. That descriptor defines the holon\u2019s properties, relationships, and structural expectations. This self-describing pattern ensures that every holon carries with it enough semantic metadata to be interpreted, validated, and extended \u2014 without relying on external schemas.</p> <p>Together, these layers support a fully self-aware, agent-defined ecosystem of meaning.</p>"},{"location":"core/map-type-system-revised/#3-meta-types-holons-that-describe-types","title":"3. Meta Types: Holons That Describe Types","text":"<p>Every holon in MAP is DescribedBy a <code>TypeDescriptor</code>. That descriptor serves two essential roles:</p> <ul> <li>It classifies the holon as a specific type (e.g., <code>BookHolonType</code>, <code>SchemaHolonType</code>)</li> <li>It describes the structure that instances of that type must or may include \u2014 such as properties, relationships, and (eventually) dances</li> </ul> <p>But each <code>TypeDescriptor</code> is itself a holon. For example, <code>BookHolonType</code> and <code>SchemaHolonType</code> are both type descriptors \u2014 and also holons that can be queried, versioned, and linked.</p> <p>So what describes a type descriptor?</p> <p>The types that describe other types are known as meta-types.</p>"},{"location":"core/map-type-system-revised/#31-map-meta-schema","title":"3.1 MAP Meta-Schema","text":"<ul> <li><code>MetaHolonType</code>, <code>MetaTypeDescriptor</code>, <code>MetaSchemaType</code></li> <li><code>DescribedBy</code>, <code>Extends</code>, <code>InstanceProperties</code></li> <li>\ud83d\udcca Diagram: Meta-Schema Graph</li> </ul>"},{"location":"core/map-type-system-revised/#311-typedescriptor-anatomy-and-inheritance","title":"3.1.1 TypeDescriptor Anatomy and Inheritance","text":"<ul> <li>Holon structure: <code>type</code>, <code>properties</code>, <code>relationships</code></li> <li>Semantic role of <code>Extends</code></li> <li>Reflexive closure of the type system</li> </ul>"},{"location":"core/map-type-system-revised/#32-map-meta-value-schema","title":"3.2 MAP Meta-Value Schema","text":"<ul> <li><code>MetaValueType</code>, <code>MetaStringValueType</code>, <code>MetaEnumValueType</code>, etc.</li> <li>\ud83d\udcca Diagram: Meta-Value Schema</li> </ul>"},{"location":"core/map-type-system-revised/#33-map-keyrule-schema","title":"3.3 MAP KeyRule Schema","text":"<ul> <li><code>KeyRuleType</code> and its subtypes:<ul> <li><code>Format.KeyRuleType</code>, <code>None.KeyRuleType</code>, <code>Relationship.KeyRuleType</code></li> </ul> </li> <li>\ud83d\udcca Diagram: KeyRule Schema</li> </ul>"},{"location":"core/map-type-system-revised/#331-keyed-vs-keyless-holon-types","title":"3.3.1 Keyed vs. Keyless Holon Types","text":"<ul> <li>Structural rules and constraints</li> <li>Key derivation formats and <code>UsesKeyRule</code></li> <li>Bootstrapping with materialized keys</li> </ul>"},{"location":"core/map-type-system-revised/#34-semantic-vs-structural-inheritance-in-the-map-type-system","title":"3.4 Semantic vs Structural Inheritance in the MAP Type System","text":"<p>The MAP <code>Extends</code> relationship enables a flexible form of type composition and lineage. But the meaning and effect of <code>Extends</code> depends on whether the type being extended is abstract or concrete.</p> <p>This section distinguishes semantic vs structural inheritance, and clarifies how <code>Extends</code> behaves in each case.</p>"},{"location":"core/map-type-system-revised/#semantic-inheritance-extending-abstract-types","title":"\ud83d\udd39 Semantic Inheritance (Extending Abstract Types)","text":"<p>Abstract types in MAP define expectations, not structure. They play a role similar to Interfaces in Java and Traits in Rust.</p> <ul> <li>They specify what kinds of properties and relationships their concrete subtypes must declare.</li> <li>But, abstract types are not instantiated; they do not automatically contribute structural content to the types that extend them.</li> <li>In MAP, the first instantiable subtype in the Extends chain must explicitly declare the union of all InstanceProperties and InstanceRelationships expected by its abstract ancestors. This means its instances that it describes must populate values for those properties and relationships.</li> </ul>"},{"location":"core/map-type-system-revised/#example","title":"\u2705 Example","text":"<p><pre><code>MetaTypeDescriptor  (abstract) with InstanceProperties: TypeName, Description, etc.\n  \u2191 Extends\nMetaHolonType       (abstract) with InstanceRelationships: DescribedBy and OwnedBy\n  \u2191 Extends\nTypeDescriptor      (concrete)\n  \u2191 Describe\n BookHolonType\n</code></pre> TypeDescriptor is the first concrete type descriptor in the chain and therefore must declare the union of all InstanceProperties and InstanceRelationships required by its abstract ancestors (MetaTypeDescriptor, MetaHolonType).</p> <p>Likewise, BookType \u2014 a concrete extension of HolonType \u2014 fulfills the expectations declared by HolonType. - <code>TypeDescriptor</code> must declare its own <code>InstanceProperties</code> and <code>InstanceRelationships</code> that are the union of those declared by all the abstract types up its Extends chain, because those expectations come from its ancestors.</p> <p>This pattern supports: - Schema validation rules (e.g., \"all MetaHolonType subtypes must declare <code>InstanceRelationships</code>\") - Introspection tools that identify \u201cWhat kind of thing is this descriptor?\u201d</p> <p>\ud83e\udde0 Think of semantic inheritance as interface or trait conformance.</p>"},{"location":"core/map-type-system-revised/#structural-inheritance-extending-concrete-types","title":"\ud83d\udd39 Structural Inheritance (Extending Concrete Types)","text":"<p>Concrete types in MAP define structure \u2014 real properties and relationships that apply to all instances of the type.</p> <p>When a concrete type <code>A</code> extends another concrete type <code>B</code>: - A new holon instance is created for each \u2014 one for <code>A</code>, one for <code>B</code>. - The holon instance of <code>A</code> populates the <code>InstanceProperties</code> and <code>InstanceRelationships</code> declared by <code>A</code>. - The holon instance of <code>B</code> populates the structure declared by <code>B</code>.</p> <p>Together, these form a compositional chain of holons, and the effective structure of a holon is the combined result of traversing the <code>Extends</code> chain.</p>"},{"location":"core/map-type-system-revised/#example_1","title":"\u2705 Example","text":"<p>Consider a library containing lots of different kinds of items -- magazines, tools, books, CD's, DVD's, etc. There are some characteristics shared by all of these items and additional charactertistics that are specific to the kind of element.</p> <pre><code>LibraryItemType       (concrete)\n  \u2191\nBookType              (concrete)\n</code></pre> <ul> <li>An instance of <code>BookType</code>:</li> <li>Is its own holon</li> <li>Declares and populates properties like <code>author</code>, <code>publisher</code>, <code>isbn</code></li> <li>It also <code>Extends</code> an instance of <code>LibraryItemType</code>, which:</li> <li>Is a separate holon</li> <li>Declares and populates properties like <code>title</code>, <code>language</code>, <code>identifier</code></li> </ul> <p>The full shape of the book holon is realized by composing these layered instances. Each contributes to the structure through its declared type.</p> <p>\ud83e\udde0 Think of structural inheritance in MAP as compositional layering \u2014 not property flattening.</p>"},{"location":"core/map-type-system-revised/#summary-table","title":"\u2705 Summary Table","text":"Feature Abstract Type Concrete Type Declares expectations \u2705 Yes \u274c No Declares structure \u274c No \u2705 Yes Must be re-declared \u2705 (by subtypes) \u274c (structure accumulates) Used for validation rules \u2705 Yes \u2705 Yes Used for type conformance \u2705 Yes \u2705 Yes Affects instance shape \u274c No \u2705 Yes Produces a holon instance \u274c No \u2705 Yes"},{"location":"core/map-type-system-revised/#design-principle","title":"\ud83e\udde0 Design Principle","text":"<p>In MAP, inheritance is explicit and introspectable. - Abstract types guide what must be declared. - Concrete types contribute actual structure. - Each concrete type produces its own holon instance. - The effective holon shape is the result of traversing the Extends chain.</p> <p>This makes the MAP type system composable, schema-validatable, and fully self-describing \u2014 with no hidden inheritance or magical behavior.</p>"},{"location":"core/map-type-system-revised/#4-core-types-semantic-foundations-of-map","title":"4. Core Types: Semantic Foundations of MAP","text":"<ul> <li><code>PropertyType</code>, <code>RelationshipType</code>, <code>EnumVariantType</code></li> <li><code>PropertyName</code>, <code>RelationshipName</code>, <code>SchemaName</code></li> <li>Core enum types (e.g. <code>DeletionSemantic</code>)</li> <li>Role in validation, schema definition, and system behavior</li> </ul>"},{"location":"core/map-type-system-revised/#5-extension-types-agent-defined-semantics","title":"5. Extension Types: Agent-Defined Semantics","text":"<ul> <li>Instances of core types</li> <li>Examples: <code>BookType</code>, <code>\"HAS_AUTHOR\"</code>, <code>\"LibrarySchema\"</code></li> <li>Dual role: type + data</li> <li>Cross-schema interoperability and reuse</li> </ul>"},{"location":"core/map-type-system-revised/#6-base-types-language-portable-value-kinds","title":"6. Base Types: Language-Portable Value Kinds","text":"<ul> <li><code>MapString</code>, <code>MapBoolean</code>, <code>MapInteger</code>, etc.</li> <li><code>BaseValue</code> enum</li> <li>Rust, TypeScript, JSON bindings</li> <li>Tagged JSON format and display conventions</li> <li>Open design questions</li> </ul>"},{"location":"core/map-type-system-revised/#7-self-describing-holons","title":"7. Self-Describing Holons","text":"<p>Transition section: from types to instances</p> <ul> <li>Introspection via <code>DescribedBy</code>, <code>InstanceProperties</code>, etc.</li> <li>Aggregating inherited structure through <code>Extends</code></li> <li>How any holon reveals:<ul> <li>What kind of thing it is</li> <li>What properties it has</li> <li>What relationships it participates in</li> <li>(Future) what dances it supports</li> </ul> </li> </ul>"},{"location":"core/map-type-system-revised/#8-authoring-and-importing-types","title":"8. Authoring and Importing Types","text":"<ul> <li>JSON structure: <code>key</code>, <code>type</code>, <code>properties</code>, <code>relationships</code></li> <li><code>$ref</code> and embedding</li> <li>Key rules and validation</li> <li>Authoring conventions and import-time enforcement</li> </ul>"},{"location":"core/meta-value-types-import-guide/","title":"Meta-Value Import Guide","text":""},{"location":"core/meta-value-types-import-guide/#starting-point-types-as-holons","title":"\ud83e\uddec Starting Point: Types as Holons","text":"<p>In MAP, every type description is, itself, a holon.</p> <p>This means that every type must: - Be described by a <code>TypeDescriptor</code> - Be owned by a <code>HolonSpace</code></p> <p>These aren't optional conventions \u2014 they are defining structural obligations of being a holon.</p> <p>\u2705 Every type in MAP is a holon. Therefore: every type must have <code>DescribedBy</code> and <code>OwnedBy</code> relationships.</p>"},{"location":"core/meta-value-types-import-guide/#modeling-map-value-types","title":"Modeling MAP Value Types","text":""},{"location":"core/meta-value-types-import-guide/#example-mapstringvaluetype-and-propertynamevaluetype","title":"\ud83d\udd20 Example: MapStringValueType and PropertyNameValueType","text":"<p>Consider two value types:</p> <ul> <li><code>MapStringValueType</code>: A general-purpose string type</li> <li><code>PropertyNameValueType</code>: A string type used specifically for property names</li> </ul> <p>They both represent strings at the data level, but differ in usage and constraint.</p> <p>Both are:</p> <ul> <li>Holons \u2192 Must be <code>DescribedBy</code> and <code>OwnedBy</code></li> <li>TypeDescriptors \u2192 Must be instances of <code>MetaValueType</code></li> </ul> <p>So the following relationships apply:</p> <pre><code>MapStringValueType \u2014[DescribedBy]\u2192 MetaValueType  \nPropertyNameValueType \u2014[DescribedBy]\u2192 MetaValueType\n</code></pre> <p>At this point, we know these two holons are not just any holons \u2014 they are type descriptors used in the schema.</p>"},{"location":"core/meta-value-types-import-guide/#shared-constraints-via-compositional-inheritance","title":"\ud83e\uddf1 Shared Constraints via Compositional Inheritance","text":"<p>Different value types require different constraints:</p> <ul> <li>Strings \u2192 min/max length, format, case convention</li> <li>Integers \u2192 min/max values</li> <li>Enums \u2192 allowed variants</li> <li>Bytes \u2192 fixed length, encoding</li> </ul> <p>But many types share these constraints. For example:</p> <pre><code>MapStringValueType        \u2500\u2510\n                          \u251c\u2500[Extends]\u2192 StringValueConstraints\nPropertyNameValueType     \u2500\u2518\n</code></pre> <p>In this pattern:</p> <ul> <li><code>MapStringValueType</code> and <code>PropertyNameValueType</code> are both holons and descriptors.</li> <li><code>StringValueConstraints</code> is just a constraint facet \u2014 it contributes properties like <code>min_length</code>, <code>max_length</code>, or <code>case_convention</code>.</li> </ul> <p>Importantly:</p> <p><code>StringValueConstraints</code> is not a type. It\u2019s not a descriptor. It doesn\u2019t have a <code>type_name</code>, doesn\u2019t need to be <code>DescribedBy</code>, and doesn\u2019t appear in any schema.</p> <p>It just extends the value type it\u2019s associated with, in a purely compositional way.</p>"},{"location":"core/meta-value-types-import-guide/#why-keys-matter","title":"\ud83e\uddf7 Why Keys Matter","text":"<p>Semantic keys are foundational to the MAP architecture \u2014 not just for expressing relationships during import, but for enabling retrieval, referencing, and bootstrapping in a decentralized, descriptor-driven system.</p> <p>They enable holons to be meaningfully identified and linked across the full lifecycle \u2014 from initial import to runtime introspection \u2014 even before they've been committed to the system or assigned a permanent ID.</p>"},{"location":"core/meta-value-types-import-guide/#staged-relationships-without-ids","title":"\ud83d\udd04 Staged Relationships Without IDs","text":"<p>In staged or import workflows, holons frequently reference other holons that haven\u2019t yet been committed \u2014 and therefore lack a system-assigned ID (e.g., a Holochain <code>ActionHash</code>).</p> <p>Keys solve this by allowing holons to be referenced using <code>$ref: \"key\"</code> rather than relying on fragile temporary identifiers or rigid load ordering.</p> <p>\u2705 Keys enable: - Cross-file linkage between staged holons - ID-free <code>$ref</code> expressions in JSON - Relationship validation prior to commit - Deduplication and merging of equivalent entries</p> <p>\ud83d\udcd8 Example: <pre><code>{\n  \"type_name\": \"RelationshipType\",\n  \"key\": \"(PersonType)-[MentoredBy]-&gt;(PersonType)\",\n  \"relationships\": [\n    { \"name\": \"SOURCE_FOR\", \"target\": [{ \"$ref\": \"PersonType\" }] },\n    { \"name\": \"TARGET_FOR\", \"target\": [{ \"$ref\": \"PersonType\" }] }\n  ]\n}\n</code></pre></p> <p>This relationship type can be referenced by other holons using its <code>key</code>, without requiring an ID to exist yet.</p>"},{"location":"core/meta-value-types-import-guide/#bootstrapping-descriptors-before-descriptor-logic-exists","title":"\ud83e\uddf1 Bootstrapping Descriptors Before Descriptor Logic Exists","text":"<p>Many MAP behaviors \u2014 including validation, inverse relationship population, and declarative key generation \u2014 depend on descriptors like <code>PropertyType</code>, <code>RelationshipType</code>, or <code>HolonType</code>.</p> <p>But you can\u2019t run logic that depends on descriptors until descriptors are present.</p> <p>By requiring materialized <code>key</code> fields in the JSON of Keyed Holons, we can: - Import descriptors without requiring key generation logic - Reference them from other holons in the same import graph - Stage and introspect schemas and data prior to persistence</p> <p>This makes it possible to: - Import the MAP Meta-Schema - Import domain-specific schema extensions - Import valid data instances   ...all in a single, unified process.</p>"},{"location":"core/meta-value-types-import-guide/#associative-retrieval-in-distributed-systems","title":"\ud83d\udd0d Associative Retrieval in Distributed Systems","text":"<p>In distributed architectures like Holochain, data is stored in Distributed Hash Tables (DHTs) \u2014 meaning:</p> <ul> <li>You cannot \u201cquery the whole database\u201d as you would in a centralized store</li> <li>You typically need a known hash or path to locate content efficiently</li> </ul> <p>Materialized keys provide the critical link between semantic meaning and retrieval paths:</p> <p>\u2705 They support: - Associative lookup: finding content based on associated properties (e.g., type, relationship role) - Path-based indexing: storing holons under DHT paths that reflect their keys (e.g., <code>path!((\"HolonType\", key))</code>) - Declarative retrieval APIs: enabling callers to say \u201cget me the [MentoredBy] relationship\u201d without knowing its ID</p> <p>Without keys: - Content is only retrievable via opaque identifiers - Queries become tightly coupled to global indexes or full scans (inefficient or unavailable in DHTs) - Schema introspection and semantic queries are significantly harder</p>"},{"location":"core/meta-value-types-import-guide/#summary","title":"\ud83e\udde0 Summary","text":"<p>Keys are not just syntactic sugar \u2014 they are critical infrastructure for:</p> <ul> <li>Declarative, schema-linked imports</li> <li>ID-free reference resolution across files</li> <li>Bootstrapping descriptors before runtime logic is available</li> <li>Efficient, semantic-based retrieval in distributed systems</li> <li>Federated schema evolution and shared introspection</li> </ul> <p>By embracing materialized, semantically meaningful keys, MAP achieves a powerful combination of:</p> <ul> <li>Structural clarity</li> <li>Introspectable relationships</li> <li>Decentralized operability</li> <li>Self-hosted schema evolution</li> </ul> <p>This makes keys one of the most essential capabilities in the MAP Type System.</p>"},{"location":"core/meta-value-types-import-guide/#layered-inheritance-the-value-type-stack","title":"\ud83d\udcd0 Layered Inheritance: The Value Type Stack","text":"<pre><code>MetaValueType \u2014[Describes]\u2192 MapStringValueType \u2014[Extends]\u2192 StringValueConstraints\n</code></pre> <p>This gives us three clear layers:</p> <ol> <li>Meta Descriptor Level \u2014 defines what a value type must contain</li> <li>Descriptor Level \u2014 a value type like <code>MapStringValueType</code> or <code>PropertyNameValueType</code></li> <li>Constraint Layer \u2014 reusable modular constraints via <code>Extends</code></li> </ol> Layer Holon Purpose Meta <code>MetaValueType</code> Describes value type descriptors Type <code>MapStringValueType</code> Actual TypeDescriptor Constraint <code>StringValueConstraints</code> Adds constraint properties"},{"location":"core/meta-value-types-import-guide/#pattern-repeats-for-all-primitive-types","title":"\ud83d\udd01 Pattern Repeats for All Primitive Types","text":"<p>Here\u2019s the same pattern across other type kinds:</p> ValueType DescribedBy ExtendedBy Constraints Provided <code>MapStringValueType</code> <code>MetaValueType</code> <code>StringValueConstraints</code> <code>min_length</code>, <code>max_length</code>, etc. <code>PropertyNameValueType</code> <code>MetaValueType</code> <code>StringValueConstraints</code> Custom limits, <code>case_convention</code> <code>MapIntegerValueType</code> <code>MetaValueType</code> <code>IntegerValueConstraints</code> <code>min_value</code>, <code>max_value</code> <code>MapBytesValueType</code> <code>MetaValueType</code> <code>BytesValueConstraints</code> <code>length</code>, <code>encoding</code>, <code>format_hint</code> <code>MapEnumValueType</code> <code>MetaValueType</code> <code>EnumValueConstraints</code> <code>Variants</code> relationship <code>MapBooleanValueType</code> <code>MetaValueType</code> (none needed) (no constraints required)"},{"location":"core/meta-value-types-import-guide/#are-meta-types-holons-too","title":"\ud83e\udde9 Are Meta Types Holons Too?","text":"<p>Yes \u2014 and this is where the architectural recursion becomes elegant.</p> <p>Just as <code>MapStringValueType</code> is a holon and needs to be <code>DescribedBy</code>, so too does <code>MetaValueType</code>.</p> <p>Let\u2019s follow the thread:</p> <pre><code>MetaValueType         \u2014[DescribedBy]\u2192 MetaTypeDescriptor  \nMetaIntegerValueType  \u2014[DescribedBy]\u2192 MetaValueType\n</code></pre> <p>So: \ud83d\udd01 Meta types themselves are holons \ud83d\udd01 They need to be described \ud83d\udd01 They participate in the same system they define</p>"},{"location":"core/meta-value-types-import-guide/#recursion-meets-structure-metatypedescriptor-extends-metaholontype","title":"\ud83d\udd04 Recursion Meets Structure: MetaTypeDescriptor Extends MetaHolonType","text":"<p>To avoid repeating the structural obligations of all holons (like needing <code>DescribedBy</code> and <code>OwnedBy</code>) across every Meta type\u2026</p> <p>We simply declare:</p> <pre><code>MetaTypeDescriptor \u2014[Extends]\u2192 MetaHolonType\n</code></pre> <p>Now, every Meta type (like <code>MetaValueType</code>, <code>MetaPropertyType</code>, etc.) that is an instance of <code>MetaTypeDescriptor</code> inherits from <code>MetaHolonType</code>, which defines the baseline expectations for all holon types.</p> <p>\u2705 Every Meta type becomes both a type descriptor and a holon \u2705 DRY design: <code>MetaHolonType</code> captures shared structural rules \u2705 Recursive closure: the system defines itself in clean, layered cycles</p>"},{"location":"core/meta-value-types-import-guide/#summary-of-the-pattern","title":"\ud83e\udde0 Summary of the Pattern","text":"Concept Relationship Notes ValueType <code>DescribedBy \u2192 MetaValueType</code> Marks as a valid type holon ValueType <code>Extends \u2192 ValueConstraints</code> Adds constraints modularly MetaValueType <code>DescribedBy \u2192 MetaTypeDescriptor</code> Makes it a descriptor of type descriptors MetaValueType <code>Extends \u2192 MetaHolonType</code> Inherits holon-level expectations Constraints (e.g. StringValueConstraints) (no type) Purely compositional constraint layer"},{"location":"core/meta-value-types-import-guide/#bonus-how-you-might-use-this-in-validation-or-import","title":"\ud83e\uddf0 Bonus: How You Might Use This in Validation or Import","text":"<p>When validating a <code>PropertyType</code> that refers to a ValueType:</p> <ol> <li>Confirm the target is a holon</li> <li>Confirm it\u2019s <code>DescribedBy</code> <code>MetaValueType</code></li> <li>Confirm it satisfies the constraints from any <code>Extends</code> facets</li> </ol> <p>This lets you:</p> <ul> <li>Reuse constraints</li> <li>Compose constraint types</li> <li>Keep descriptors clean and minimal</li> <li>Keep validation DRY and generalizable</li> </ul> <p>================ OLDER ATTEMPTS FOLLOW</p>"},{"location":"core/meta-value-types-import-guide/#starting-point-types-as-holons_1","title":"\ud83e\uddec Starting Point: Types as Holons","text":"<p>In MAP, every type \u2014 including value types \u2014 is a holon.</p> <p>Because every type is a holon, it must:</p> <ul> <li>Be described by a <code>TypeDescriptor</code></li> <li>Be owned by a <code>HolonSpace</code></li> </ul>"},{"location":"core/meta-value-types-import-guide/#layer-1-descriptor-level-meta-types","title":"\ud83e\uddf1 Layer 1: Descriptor Level (Meta Types)","text":"<p>This is the type of types level \u2014 Meta types describe what type descriptors are.  </p> <p>For example:</p> <ul> <li><code>MetaValueType</code> is a <code>TypeDescriptor</code></li> <li>It specifies properties and relationships common to all ValueTypes<ul> <li>e.g., <code>type_name</code>, <code>ValueType</code> relationship from <code>PropertyType</code>, <code>type_kind</code>, etc.</li> </ul> </li> </ul> <p>So:</p> <pre><code>MapStringValueType \u2014[DescribedBy]\u2192 MetaValueType  \nPropertyNameValueType \u2014[DescribedBy]\u2192 MetaValueType\n</code></pre> <p>Now these holons are known to be TypeDescriptors and are expected to provide things like <code>type_name</code>, and be usable in <code>ValueType</code> relationships from <code>PropertyType</code>.</p> <p>But because every type is also a holon, the types themselves need to be <code>DescribedBy</code> a <code>TypeDescriptor</code> and <code>OwnedBy</code> a <code>HolonSpace</code>. So TypeDescriptor needs to <code>Extend</code> Me</p>"},{"location":"core/meta-value-types-import-guide/#layer-2-constraint-types-via-extends","title":"\ud83e\uddf1 Layer 2: Constraint Types via <code>Extends</code>","text":"<p>Some ValueTypes want to specify type-kind-specific constraints \u2014 but you don\u2019t want to bake those constraints into every ValueType. You want a modular, reusable structure.</p> <p>That\u2019s where <code>Extends</code> comes in.</p> <p>Let\u2019s take an example:</p> <pre><code>MapStringValueType \u2014[Extends]\u2192 StringValueConstraints  \nPropertyNameValueType \u2014[Extends]\u2192 StringValueConstraints\n</code></pre> <p>Here:</p> <ul> <li><code>MapStringValueType</code> defines the general-purpose string value type.</li> <li><code>PropertyNameValueType</code> is a specialized string type, e.g., requiring <code>snake_case</code>, specific min/max lengths, etc.</li> <li>Both share the constraint logic defined in <code>StringValueConstraints</code>.</li> </ul> <p>The key insight is that <code>StringValueConstraints</code> is not a type itself. It doesn\u2019t need a <code>type_name</code>, <code>DescribedBy</code>, etc. It simply adds constraint properties like:</p> <ul> <li><code>min_length</code></li> <li><code>max_length</code></li> <li><code>case_convention</code></li> <li><code>format_hint</code></li> </ul> <p>It's a constraint facet, not a descriptor.</p>"},{"location":"core/meta-value-types-import-guide/#parallel-pattern-for-other-type-kinds","title":"\ud83d\udd04 Parallel Pattern for Other Type Kinds","text":"<p>You\u2019d follow this same pattern for other primitive types:</p> ValueType Extends Constrains via\u2026 <code>MapIntegerValueType</code> <code>IntegerValueConstraints</code> <code>min_value</code>, <code>max_value</code> <code>MapBytesValueType</code> <code>BytesValueConstraints</code> <code>length</code>, <code>encoding</code> <code>MapBooleanValueType</code> (no constraints) (no extra facet needed) <code>MapEnumValueType</code> <code>EnumValueConstraints</code> <code>Variants</code> relationship"},{"location":"core/meta-value-types-import-guide/#layered-design-overview","title":"\ud83d\udcd0 Layered Design Overview","text":"<pre><code>          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502     MetaValueType          \u2502 \u25c4\u2500\u2500 Describes all ValueType descriptors\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502 DescribedBy\n                       \u25bc\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502   MapStringValueType       \u2502 \u25c4\u2500\u2500 A TypeDescriptor\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502 Extends\n                       \u25bc\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502   StringValueConstraints   \u2502 \u25c4\u2500\u2500 Holds constraint properties only\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>You can generalize this:</p> <ul> <li>Any <code>MetaType</code> describes a descriptor</li> <li>Any actual <code>TypeDescriptor</code> may <code>Extend</code> a constraint holon</li> <li>Constraint holons are not TypeDescriptors \u2014 they don\u2019t get keys, <code>DescribedBy</code>, or <code>OwnedBy</code></li> </ul>"},{"location":"core/meta-value-types-import-guide/#benefits-of-this-pattern","title":"\u2705 Benefits of This Pattern","text":"<ul> <li>Clarity: Descriptors describe types. Constraints constrain them.</li> <li>DRY: Reuse constraints across many types (e.g., <code>StringValueConstraints</code>)</li> <li>Composability: Add further <code>Extends</code> layers if needed, e.g., <code>StringWithRegexConstraints</code></li> <li>Separation of Concerns: Keep metadata (<code>type_name</code>, etc.) distinct from behaviorally meaningful constraints</li> </ul>"},{"location":"core/meta-value-types-import-guide/#optional-schema-organization","title":"\ud83d\udca1 Optional: Schema Organization","text":"<p>You may wrap the constraint holons (like <code>StringValueConstraints</code>) in their own schema:</p> <pre><code>{\n  \"key\": \"MAP Value Constraints Schema\",\n  \"type\": \"Schema\",\n  \"relationships\": [\n    {\n      \"name\": \"Components\",\n      \"target\": [\n        { \"$ref\": \"#StringValueConstraints\" },\n        { \"$ref\": \"#IntegerValueConstraints\" },\n        ...\n      ]\n    }\n  ]\n}\n</code></pre> <p>Would you like to sketch out the JSON structure for one of these examples (e.g., <code>PropertyNameValueType</code> extending <code>StringValueConstraints</code>) using this approach?</p>"},{"location":"core/meta-value-types-import-guide/#annotated-example-map-strings","title":"Annotated Example -- MAP Strings","text":"<p><code>MapStringValueType</code> is an instance of <code>MetaValueType</code>. Thus, it can be the target of a Property's <code>ValueType</code> relationship. It may often be the case that the <code>ValueType</code> for a property is simply <code>MapString</code>. But sometimes we want more specific types. For example, the <code>PropertyNameValueType</code> is specifically intended to be the type used for <code>property_names</code> in the MAP. As a value type, it is ALSO an instance of <code>MetaValueType</code> (i.e., its \"type\" is <code>MetaValueType</code>). Note that <code>MapString</code> and <code>PropertyNameValueType</code> both have <code>instance_type_kind</code> of <code>String</code>, so they would both be represented in Rust by the MapString type. But <code>PropertyNameValueType</code> might want to specify its own case_convention (snake_case), and length restrictions that differ from the more generic <code>MapStringValueType</code>.  And, other than sharing the same type kind, MapStringValueType and PropertyNameValueType have no direct relationship to each other.</p> <p>Different value type kinds require different kinds of constraints. For example, <code>Strings</code> have min and max length and perhaps a format type or template. Integers have min/max values. So the definition of each ValueType has a common facet (in its role as a TypeDescriptor) and a type-kind-specific facet (its constraints.</p> <p>We can use compositional inheritance to model this. Thus,</p> <p>(MetaValueType) &lt;- [Extends] - (MapValueConstraintsType) and (MapStringValueType) &lt;- [Extends] - (StringValueConstraints) and (PropertyNameValueType) &lt;- [Extends] - (StringValueConstraints)</p> <p>At first, I thought MapValueConstraintsType should perhaps be MetaValueConstraintsType -- but then I realized it is not describing another type. For example, StringValueConstraints is not (itself) a type definition. It specifies the constraints for the ValueType that it extends. Values for the type_name property (and all other TypeDescriptor properties) are set on the ValueType it extends. In other words, the PropertyNameValueType is the actual TypeDescriptor.</p>"},{"location":"core/meta-value-types-import-guide/#metavaluetype","title":"MetaValueType","text":"<ul> <li>Is the type that <code>Describes</code> <code>MapValueType</code>, so its <code>type</code> is <code>TypeDescriptor</code></li> </ul> <p>Each instance of <code>MapValueType</code> describes a single ValueType. It is a <code>TypeDescriptor</code> that provides values for the standard <code>TypeDescriptor</code> properties (e.g, <code>type_name</code>, <code>display_name_plural</code>, <code>instance_type_kind</code>, etc.).</p> <p>MetaValueType is an instance of TypeDescriptor that describes MapValueType MapValueType is an instance of MetaValueType (i.e., its \"type\" is \"MetaValueType\") -- SINGLETON? MapStringType is an instance of MapValueType (or MetaValueType)</p> <p>An XxxValueType consists of a TypeDescriptor that is ExtendedBy an XxxConstraintType The X StringConstraints Extends MapStringType</p> <p>As such it provides values for the <code>TypeDescriptor</code> <code>properties</code>:</p> <ul> <li>\"type_name\": \"MetaValueType\",</li> <li>\"type_name_plural\": \"MetaValueTypes\",</li> <li>\"display_name\": \"Meta Value Type\",</li> <li>\"display_name_plural\": \"Meta Value Types\",</li> <li>\"description\": \"Describes the types that can be used as the target of a <code>Property</code>'s <code>ValueType</code> relationship.\"</li> <li>\"instance_type_kind\": \"Holon\"</li> </ul> <p>All Meta types describe types and all type definitions are, themselves, Holons. So the instance_type_kind for all Meta types is \"Holon\"</p> <ul> <li>\"UsesKeyRule\": { \"$ref\": \"#TypeName.KeyRule\" }</li> <li>instance_type_kind tells you the storage type (i.e., the BaseType) of instances of the type being described</li> <li>MapValueType is the TypeDescriptor for all value types</li> <li>MetaStringConstraints Extends MetaValueType and</li> </ul> <pre><code> {\n              \"key\": \"MetaPropertyType\",\n              \"type\": \"#TypeDescriptor\",\n              \"properties\": {\n                \"type_name\": \"MetaPropertyType\",\n                \"type_name_plural\": \"MetaPropertyTypes\",\n                \"display_name\": \"Meta Property Type\",\n                \"display_name_plural\": \"Meta Property Types\",\n                \"description\": \"Describes the types of scalar properties that holons can possess.\"\n              },\n              \"relationships\": [\n                {\n                  \"name\": \"Extends\",\n                  \"target\": {\n                    \"$ref\": \"#MetaTypeDescriptor\"\n                  }\n                },\n                {\n                  \"name\": \"UsesKeyRule\",\n                  \"target\": {  $ref\": \"#TypeName.KeyRule\" }\n                },\n                {\n                  \"name\": \"InstanceRelationships\",\n                  \"target\": [\n                    {\n                      \"$ref\": \"#(PropertyType)-[ValueType]-&gt;(ValueType)\"\n                    },\n                    {\n                      \"$ref\": \"#(PropertyType)-[ComponentOf]-&gt;(Schema)\"\n                    },\n                    {\n                      \"$ref\": \"#(PropertyType)-[DescribedBy]-&gt;(TypeDescriptor)\"\n                    }\n                  ]\n                }\n              ]\n            },\n</code></pre> <pre><code> {\n              \"key\": \"MetaPropertyType\",\n              \"type\": \"#TypeDescriptor\",\n              \"properties\": {\n                \"type_name\": \"MetaPropertyType\",\n                \"type_name_plural\": \"MetaPropertyTypes\",\n                \"display_name\": \"Meta Property Type\",\n                \"display_name_plural\": \"Meta Property Types\",\n                \"description\": \"Describes the types of scalar properties that holons can possess.\"\n              },\n              \"relationships\": [\n                {\n                  \"name\": \"Extends\",\n                  \"target\": {\n                    \"$ref\": \"#MetaTypeDescriptor\"\n                  }\n                },\n                {\n                  \"name\": \"UsesKeyRule\",\n                  \"target\": {\n                    \"$ref\": \"#TypeName.KeyRule\"\n                  }\n                },\n                {\n                  \"name\": \"InstanceRelationships\",\n                  \"target\": [\n                    {\n                      \"$ref\": \"#(PropertyType)-[ValueType]-&gt;(ValueType)\"\n                    },\n                    {\n                      \"$ref\": \"#(PropertyType)-[ComponentOf]-&gt;(Schema)\"\n                    },\n                    {\n                      \"$ref\": \"#(PropertyType)-[DescribedBy]-&gt;(TypeDescriptor)\"\n                    }\n                  ]\n                }\n              ]\n            },\n</code></pre>"},{"location":"core/meta-value-types-import-guide/#mapvaluetype","title":"MapValueType","text":"<pre><code>{\n  \"key\": \"MapValueType\",\n  \"type\": \"#TypeDescriptor\"\n}\n</code></pre>"},{"location":"core/on-boarding/","title":"Agent, I-Space, and Computing Node Onboarding","text":"<p>This document describes the technical process by which a new user onboards into the Memetic Activation Platform (MAP), with emphasis on the relationship between I-Space, computing nodes, agents, and the identity/authority structures binding them together.</p>"},{"location":"core/on-boarding/#1-key-concepts","title":"1. Key Concepts","text":""},{"location":"core/on-boarding/#i-space","title":"I-Space","text":"<ul> <li>An I-Space is a user\u2019s personal agent-space within Planetary Space.</li> <li>It is a Holochain agent space (flattened inheritance: <code>I-Space \u2282 Holochain Space</code>).</li> <li>Conceptually represents the user\u2019s:<ul> <li>Personal computing cloud</li> <li>Personal data cloud</li> <li>Core identity</li> </ul> </li> <li>Acts as the parent membrane for all of the user\u2019s sub-agents (e.g. computing devices).</li> </ul>"},{"location":"core/on-boarding/#computing-node","title":"Computing Node","text":"<ul> <li>A computing node is a user\u2019s device (laptop, desktop, tablet, etc.) running the MAP software.</li> <li>Each computing node is instantiated as a Holochain agent within the user\u2019s I-Space.</li> <li>Provisioned with applications (\u201cthe Gift\u201d = Nine core apps).</li> <li>Executes MAP applications and participates in the user\u2019s personal services layer.</li> </ul>"},{"location":"core/on-boarding/#data-grove","title":"Data Grove","text":"<ul> <li>The user\u2019s personal data cloud, formed by the aggregation of application-specific DHTs.</li> <li>Conceptualized as a concentric layer surrounding core identity in the I-Space diagram.</li> <li>Data is distributed across the user\u2019s computing nodes.</li> </ul>"},{"location":"core/on-boarding/#core-identity","title":"Core Identity","text":"<ul> <li>The user\u2019s personal identity within Planetary Space.</li> <li>Materialized via a cryptographic keypair (or complement of keypairs) created at onboarding.</li> <li>Distributed across the user\u2019s computing nodes, but logically represented as a singular identity.</li> </ul>"},{"location":"core/on-boarding/#2-onboarding-flow","title":"2. Onboarding Flow","text":""},{"location":"core/on-boarding/#step-1-invitation-gift","title":"Step 1. Invitation &amp; Gift","text":"<ul> <li>User downloads MAP (free, open-source software).</li> <li>On first run, the MAP presents the user with an invitation to join Planetary Space.</li> <li>The \u201cgift\u201d is disclosed gradually:<ol> <li>Free installation.</li> <li>Presentation of invitation.</li> <li>Acceptance generates I-Space and identity.</li> </ol> </li> </ul>"},{"location":"core/on-boarding/#step-2-identity-creation","title":"Step 2. Identity Creation","text":"<ul> <li>Upon acceptance:<ul> <li>The MAP requests Holochain to generate:<ul> <li>A core identity keypair for the user.</li> <li>A sub-agent keypair for the initial computing node.</li> </ul> </li> </ul> </li> <li>Result: both user identity and computing node identity are established in Planetary Space.</li> </ul>"},{"location":"core/on-boarding/#step-3-sub-agent-relationship","title":"Step 3. Sub-Agent Relationship","text":"<ul> <li>The computing node is recorded as a sub-agent of the user\u2019s I-Space.</li> <li>A membership agreement is created:<ul> <li>Grants the user full stewardship/admin privileges over the computing node.</li> <li>Establishes mutual recognition (key exchange).</li> <li>Agreement is inherently mutual (signed by both parties).</li> </ul> </li> </ul>"},{"location":"core/on-boarding/#step-4-activation","title":"Step 4. Activation","text":"<ul> <li>The computing node is provisioned with the Nine core applications.</li> <li>Applications run inside computing nodes, not directly in the I-Space.</li> <li>The I-Space view displays:<ul> <li>Core Identity (center).</li> <li>Data Grove (personal cloud).</li> <li>Sub-agents (computing nodes) around the ring.</li> </ul> </li> </ul>"},{"location":"core/on-boarding/#3-temporal-sequence-protocol-vs-conceptual","title":"3. Temporal Sequence: Protocol vs. Conceptual","text":"<p>There is a subtle but important distinction between how onboarding must occur at the protocol level (Holochain mechanics) versus how it is best understood at the conceptual level (MAP narrative).</p>"},{"location":"core/on-boarding/#protocol-sequence-holochain-view","title":"Protocol Sequence (Holochain View)","text":"<ol> <li>Compute node identity is generated first.<ul> <li>A device cannot participate in a DHT without an agent keypair.</li> </ul> </li> <li>I-Space (personal identity) is generated.<ul> <li>A keypair is created for the human\u2019s core identity.</li> </ul> </li> <li>Agreement is recorded between the two.<ul> <li>Membership establishes the compute node as a sub-agent of the I-Space.</li> </ul> </li> </ol>"},{"location":"core/on-boarding/#conceptual-sequence-map-view","title":"Conceptual Sequence (MAP View)","text":"<ol> <li>I-Space exists first as the enclosing membrane.<ul> <li>Represents the person\u2019s personal cloud and identity.</li> </ul> </li> <li>Computing node is ingested into the I-Space.<ul> <li>The I-Space \u201cabsorbs\u201d the node into its membrane, making it a sub-agent.</li> </ul> </li> <li>Agreement is mutual but is understood as the I-Space granting stewardship authority to the person over the node.</li> </ol>"},{"location":"core/on-boarding/#reconciliation","title":"Reconciliation","text":"<ul> <li>Protocol necessity: Device keys come first (Holochain requirement).</li> <li>Conceptual truth: The I-Space envelops its computing nodes (MAP metaphor).</li> <li>Documentation implication: Both sequences are valid; developers must follow the protocol, storytellers should communicate the conceptual.</li> </ul>"},{"location":"core/on-boarding/#4-open-questions","title":"4. Open Questions","text":"<ol> <li> <p>Key Generation for Hardware</p> <ul> <li>How exactly are compute node identities derived?</li> <li>Is device hardware entropy/identifier hashed into the keypair?</li> <li>Best practice for bootstrapping Holochain agent keys to hardware?</li> </ul> </li> <li> <p>Sequential Dependencies</p> <ul> <li>Does Holochain strictly enforce \u201cnode-first then I-Space,\u201d or can the appearance be reversed through orchestration?</li> <li>What does this mean for cross-device identity joining?</li> </ul> </li> </ol>"},{"location":"core/on-boarding/#5-storytelling-alignment","title":"5. Storytelling Alignment","text":"<p>For non-technical onboarding presentations: - Start from the user experience:     - Download gift \u2192 Accept invitation \u2192 Receive I-Space. - Emphasize simplicity:     - \u201cYour personal cloud\u201d     - \u201cYour devices become part of it\u201d - Reveal computing nodes and applications only as necessary. - Avoid algebraic notation (letters like A, B, C) \u2014 use relatable examples (Laptop, Phone, Tablet).</p>"},{"location":"core/transaction-model/","title":"\ud83e\uddfe MAP Transaction Model Specification","text":"<p>This document proposes a design for a Transaction Model used in the Memetic Activation Platform (MAP), grounding it in MAP\u2019s architectural principles and comparing it to event sourcing, Holochain, and CRDT systems.</p>"},{"location":"core/transaction-model/#overview-what-is-a-transaction-in-map","title":"\ud83d\udd39 Overview: What Is a Transaction in MAP?","text":"<p>A Transaction in MAP is a semantically meaningful, multi-operation commit unit that:</p> <ul> <li>Encapsulates one or more staged holon or relationship updates.</li> <li>Records validation outcomes, operation logs, and possible compensating operations.</li> <li>Results in either a validated commit, an invalid provisional state, or a rollback.</li> </ul> <p>Transactions serve both as: - A logical unit of change (semantic granularity), - And a backbone for undo, validation, and resolution semantics.</p>"},{"location":"core/transaction-model/#structure-of-a-transaction-holon","title":"\ud83e\uddf1 Structure of a Transaction Holon","text":"<pre><code>{\n  \"type\": \"#TransactionType\",\n  \"properties\": {\n    \"transaction_id\": \"txn:2025-08-19T17:54Z:87af0\",\n    \"timestamp\": \"2025-08-19T17:54:33Z\",\n    \"initiated_by\": \"Agent:alice\",\n    \"final_state\": \"CommittedWithWarnings\"  // or \"Validated\", \"Failed\", \"RolledBack\"\n  },\n  \"relationships\": {\n    \"Updated\": [ \"$ref\": \"Holon:book:MAP\" ],\n    \"HasValidationResult\": [ \"$ref\": \"#validation-too-many-tags\" ],\n    \"HasOperationLog\": [ \"$ref\": \"#op-1\", \"$ref\": \"#op-2\" ],\n    \"Compensates\": [ \"$ref\": \"#Transaction:txn-original\" ]\n  }\n}\n</code></pre>"},{"location":"core/transaction-model/#key-properties","title":"Key Properties","text":"Property Description <code>transaction_id</code> Unique identifier for the transaction. <code>initiated_by</code> Agent or process that initiated the commit. <code>final_state</code> Enum: <code>Validated</code>, <code>CommittedWithWarnings</code>, <code>Failed</code>, <code>RolledBack</code>, etc. <code>timestamp</code> When the transaction was created."},{"location":"core/transaction-model/#key-relationships","title":"Key Relationships","text":"Relationship Target Purpose <code>Updated</code> Holon(s) All holons affected in the transaction. <code>HasValidationResult</code> ValidationResult Records rule checks applied post-commit. <code>HasOperationLog</code> OperationLog Stores user-facing or compensatory operation sequences. <code>Compensates</code> Transaction Links to the prior transaction being rolled back."},{"location":"core/transaction-model/#best-practices-integrated-into-the-transaction-model","title":"\ud83d\udcda Best Practices Integrated into the Transaction Model","text":""},{"location":"core/transaction-model/#event-sourcing-practices","title":"\u2705 Event Sourcing Practices","text":"Event Sourced Concept MAP Equivalent Event stream per aggregate <code>StagedHolon</code> per entry Append-only log <code>OperationLog</code> attached to Transaction Optimistic concurrency (OCC) OCC applied at commit time using version check Snapshot for materialized state Materialized <code>StagedHolon</code> represents final state Sagas for long transactions <code>Transaction</code> + <code>Compensates</code> + Agreement policies Read model projection Nursery maintains a transient, fully materialized view of all holons in the Transaction scope"},{"location":"core/transaction-model/#key-takeaway","title":"Key Takeaway","text":"<p>MAP treats the Transaction Holon as the bounded event stream unit, aggregating property/relationship changes into a single validation and commit phase. The Nursery functions as an ephemeral read model or projection layer, allowing efficient access to the current state during staged editing and commit processing \u2014 much like a projection in traditional event-sourced systems.</p>"},{"location":"core/transaction-model/#holochain-comparisons","title":"\ud83c\udf00 Holochain Comparisons","text":"Holochain Concept MAP Layer <code>create_entry</code>, <code>update_entry</code> ops Underlying backing store for Holons Action Hash graph Reflected in <code>SemanticVersion</code> and <code>Updated</code> links DHT validation callbacks Wrapped into MAP\u2019s third-pass commit validation Branching via multiple updates Tracked and resolved via <code>ValidationResult</code> + <code>ConflictsWith</code>"},{"location":"core/transaction-model/#key-takeaway_1","title":"Key Takeaway","text":"<p>MAP extends Holochain\u2019s \u201cvalidation-on-each-op\u201d model by layering transaction-level, type-aware, and agreement-aware validation atop the raw chain mechanics.</p>"},{"location":"core/transaction-model/#crdt-perspective","title":"\ud83d\udd01 CRDT Perspective","text":"CRDT Trait MAP Position Automatic conflict resolution Not automatic \u2014 requires rule- or agreement-based merge logic Merge-on-receipt Delayed, semantic resolution during validation or review Convergence guarantee Conditional \u2014 governed by AgreementScope and policies Operation deltas Represented via fine-grained <code>OperationLog</code> commands Composability Holon structure is the merge target, not the CRDT state itself"},{"location":"core/transaction-model/#key-takeaway_2","title":"Key Takeaway","text":"<p>MAP\u2019s Transaction Model prioritizes semantic correctness over blind convergence. It supports CRDT-style operational tracking but rejects automatic merging unless declared via policy.</p>"},{"location":"core/transaction-model/#strategic-benefits-of-this-model","title":"\ud83e\udde0 Strategic Benefits of This Model","text":"<ul> <li>Enables fine-grained UX undo without polluting the DHT.</li> <li>Supports event sourcing patterns while maintaining a clean, materialized model.</li> <li>Adds semantic structure on top of Holochain\u2019s low-level operation model.</li> <li>Leaves room for application- and agreement-scoped conflict resolution, aligning with MAP\u2019s governance-first design.</li> </ul>"},{"location":"core/transaction-model/#open-extensions-future","title":"\ud83d\udccc Open Extensions (Future)","text":"<ul> <li><code>ResolutionPolicy</code> holons linked to <code>AgreementScope</code> and <code>ApplicationScope</code></li> <li><code>MergeResolution</code> holons for explicit fork merging</li> <li>Automatic detection of unresolved forks and triggering of merge workflows</li> <li>Parallel Transaction Streams per AgreementSpace</li> </ul>"},{"location":"core/transaction-model/#comparison-to-event-sourced-systems-holochain-crdts-and-mvcc_","title":"Comparison to Event-Sourced Systems, Holochain, CRDTs, and MVCC_","text":""},{"location":"core/transaction-model/#the-map-transaction-model","title":"\ud83c\udf31 The MAP Transaction Model","text":"<p>In the Memetic Activation Platform (MAP), every set of proposed changes to holons is staged in a local Nursery before being committed. A Transaction holon represents this unit of change. It is created at commit time and holds:</p> <ul> <li>Relationships to a set of ValidationResult holons</li> <li>Links to all updated Holons (via those results)</li> <li>State transitions such as <code>Unvalidated</code> \u2192 <code>Validated</code> \u2192 <code>Committed</code> or <code>RolledBack</code></li> <li>Optional logging of fine-grained operations to support undo/redo and compensating transactions</li> </ul> <p>The MAP\u2019s layered design separates validation (ensuring semantic correctness and consistency) from persistence (recording changes in the source of truth). Validation is performed before commit using rules scoped by both application logic and shared agreements (e.g. cardinality checks, role consistency, semantic integrity, etc.).</p>"},{"location":"core/transaction-model/#nursery-as-a-read-model-projection-layer","title":"\ud83e\udeb5 Nursery as a Read Model (Projection Layer)","text":"<p>In Event Sourced systems, projections (also called read models) are derived views of the event stream, optimized for user interaction. The MAP Nursery serves this role during a transaction:</p> <ul> <li>It maintains a materialized view of holons after every staged change.</li> <li>Ergonomic client APIs (e.g. <code>with_property</code>, <code>add_relationship</code>) mutate this staged state.</li> <li>These lightweight operations can be logged as Commands, enabling undo/redo support.</li> <li>Only at commit time is the transaction finalized and written as an immutable update.</li> </ul>"},{"location":"core/transaction-model/#comparison-to-event-sourcing-systems","title":"\ud83d\udd01 Comparison to Event Sourcing Systems","text":"Aspect Event Sourcing MAP Transaction Model Core Persistence Model Append-only event log Append-only holon updates (via DHT) Aggregates Derived from replaying events Materialized holons in nursery projections Validation Done before/after event persistence Done in the nursery, before commit Transaction Representation Often lacks explicit transaction Explicit <code>Transaction</code> holon Undo/Redo By reversing events or snapshots Via logged staged operations in nursery Compensating Transactions Application-defined Tracked via new Transaction holons Concurrency Control Typically OCC or snapshot isolation MVCC + Agreement-Scoped Conflict Resolution"},{"location":"core/transaction-model/#mvcc-in-map-vs-other-concurrency-strategies","title":"\u2699\ufe0f MVCC in MAP vs Other Concurrency Strategies","text":""},{"location":"core/transaction-model/#map-uses-multi-version-concurrency-control-mvcc","title":"\u2705 MAP uses Multi-Version Concurrency Control (MVCC)","text":"<ul> <li>Each holon update produces a new immutable version</li> <li>Writers do not block each other \u2014 they create parallel branches</li> <li>Version history is preserved and traceable</li> <li>Conflict detection is deferred, and resolution is semantic (not structural)</li> </ul>"},{"location":"core/transaction-model/#not-optimistic-concurrency-control-occ","title":"\u274c Not Optimistic Concurrency Control (OCC)","text":"<ul> <li>OCC would reject commits if the read version was outdated</li> <li>MAP instead accepts the write, creating a new fork</li> <li>This branching behavior supports collaborative divergence before reconciliation</li> </ul>"},{"location":"core/transaction-model/#conflict-resolution-strategies-crdts-vs-holochain-vs-map","title":"\ud83e\udde0 Conflict Resolution Strategies: CRDTs vs Holochain vs MAP","text":"Feature CRDTs Holochain MAP Conflict-Free? Claims \"conflict-free\" via auto-merge Leaves resolution to the application Explicitly supports semantic conflicts Merge Strategy Structural (e.g. last-write-wins, ORSet) None by default Application + Agreement-Scoped Semantics Determinism Always converges No built-in convergence Resolution logic is pluggable per domain Lost Updates Possible? Yes (e.g. in LWW) Yes Yes \u2014 but tracked and resolvable Undo Support Limited Manual Fine-grained undo via operation log Update Representation Per-property, tombstones, deltas Entry-level action history Per-holon, with ergonomic staging granularity Versioning Model Conflict-resolution per data type Full action chain (via hashes) Holon-level branches tracked via hashes <p>\ud83d\udd0d Note: While CRDTs automatically resolve structural conflicts, they often do so at the cost of semantic predictability. MAP preserves all branches and delegates resolution to shared agreements and application logic.</p>"},{"location":"core/transaction-model/#agreement-scopes-and-application-scopes","title":"\ud83d\udcdc Agreement Scopes and Application Scopes","text":"<p>To support meaningful conflict resolution:</p> <ul> <li>Agreement Scope: Specifies the participants and rules (e.g. communities, working groups) that govern semantic resolution.</li> <li>Application Scope: Defines the data boundaries (e.g. all holons in a shared Space) to which resolution applies.</li> </ul> <p>Resolution logic is therefore anchored in both the social commitments and the data model \u2014 ensuring that divergent updates are reconciled in a trustworthy, context-aware way.</p>"},{"location":"core/transaction-model/#summary","title":"\ud83e\udde9 Summary","text":"<p>MAP\u2019s Transaction model offers:</p> <ul> <li>A clear separation of staging, validation, and commit phases</li> <li>Fine-grained operation tracking for undo/redo and compensation</li> <li>Explicit MVCC-style version branching with later reconciliation</li> <li>A hybrid model blending Event Sourcing, Holochain DHT consistency, and semantic conflict resolution that goes beyond CRDTs</li> </ul> <p>This design supports both a robust technical foundation and the social contracts required for trustworthy, collaborative data stewardship.</p>"},{"location":"core/trust-channel-design-spec/","title":"MAP Trust Channel \u2014 Developer Design Spec (Fully Expanded)","text":""},{"location":"core/trust-channel-design-spec/#0-purpose-scope","title":"0. Purpose &amp; Scope","text":"<p>The Trust Channel is the MAP core service that encapsulates, transports, and validates Dance Capsules whenever an interaction crosses a membrane boundary between Spaces. It enforces Agreement-governed security, privacy, and protocol consistency through layered envelopes that correspond to membrane validation gates.</p> <p>Trust Channels:</p> <ul> <li>Exist only in the Rust runtime; the TypeScript SDK never hosts a Trust Channel.</li> <li>Are always governed by an Agreement, which defines envelope sequencing, crypto and policy parameters.</li> <li>Dynamically select compatible ProtocolSuites through Protocol Negotiation during capsule formation.</li> <li>Trigger the transport and validation mechanism for all cross-Space Dances.</li> </ul> <p>The TypeScript\u2194Rust interface inside a single Tauri process is not a membrane boundary and therefore bypasses Trust Channel logic.</p>"},{"location":"core/trust-channel-design-spec/#1-deployment-architecture","title":"1. Deployment Architecture","text":""},{"location":"core/trust-channel-design-spec/#11-system-topology-overview","title":"1.1 System Topology Overview","text":"<p>Each Agent in MAP operates within an Agreement Space\u2014a membrane enclosing Agents that share at least one Agreement. Agents are depicted as spheres connected by a mycelial web of Trust Channels representing the live peer-to-peer fabric.</p> <ul> <li>Source Container: Rust runtime of the sending Agent (Space A).</li> <li>Destination Container: Rust runtime of the receiving Agent (Space B).</li> <li>Trust Channel: logical and cryptographic conduit linking both membranes.</li> <li>Transport Protocol: the routing mechanism defined by the Agreement (e.g., DHT gossip, relay, or direct peer link).</li> </ul> <p>When a DanceRequest leaves an Agent\u2019s pore, it travels through the Trust Channel across the mycelial web, wrapped in layers of envelopes that perform sequential validation. At the receiving pore, the Trust Channel unwraps these envelopes inward, validating routing, signature, encryption, authorization, and dispatch. A DanceResponse is then re-encapsulated with outbound envelopes in reverse order and sent back through the same path.</p>"},{"location":"core/trust-channel-design-spec/#12-trust-channel-cross-section","title":"1.2 Trust Channel Cross-Section","text":"<p>Each Trust Channel is visualized as a funnel through the agent\u2019s membrane. Envelopes are represented as gates, initially closed. As validation succeeds layer by layer, each gate opens and the remaining inner capsule drops through to the next gate until only the inner Dance remains. Outbound responses travel upward through the same funnel, having their envelopes reapplied and gates resealed.</p>"},{"location":"core/trust-channel-design-spec/#2-core-concepts","title":"2. Core Concepts","text":""},{"location":"core/trust-channel-design-spec/#21-dance-capsule","title":"2.1 Dance Capsule","text":"<p>A Dance Capsule is a holarchic structure of nested Envelope holons surrounding a <code>Dance</code> (request or response). Each envelope performs one membrane function: routing, authentication, encryption, authorization, dispatch, or filtering. Inbound sequence: <code>Transport \u2192 AuthN \u2192 Crypto \u2192 AuthZ \u2192 Dispatch \u2192 Payload</code> Outbound sequence: <code>Payload \u2192 Exfiltration \u2192 Crypto \u2192 AuthN \u2192 Transport</code></p> <p>Each layer exposes progressively unwrapped content to the next validation phase.</p>"},{"location":"core/trust-channel-design-spec/#22-agreement-and-protocolsuite","title":"2.2 Agreement and ProtocolSuite","text":"<p>Each Trust Channel is governed by an Agreement, which specifies: - Allowed ProtocolSuites (possible envelope sequences and crypto stacks). - Mappings between Dances and suites via <code>DancePolicyMap</code>. - Cryptographic and policy relationships (AuthZPolicy, CryptoPolicy, ExfiltrationPolicy, StepUpPolicy).</p> <p>A ProtocolSuite holon defines: - The ordered envelope sequences for inbound and outbound directions. - The validator modules for each envelope kind. - Optional <code>CanDownshiftTo</code> relationships for fallback negotiation.</p>"},{"location":"core/trust-channel-design-spec/#23-protocol-negotiation","title":"2.3 Protocol Negotiation","text":"<p>Protocol negotiation determines which ProtocolSuite governs a given capsule exchange. It occurs when a sender proposes a suite under the governing Agreement and the receiver accepts or downshifts to another allowed suite.</p> <p>Negotiation Steps 1. Proposal \u2014 Sender selects a candidate suite from the Agreement\u2019s <code>DancePolicyMap</code> or its <code>DefaultSuite</code> and records it as <code>ProposesSuite</code> in the outer TransportEnvelope. 2. Validation \u2014 Receiver checks the Agreement\u2019s <code>AllowedProtocolSuites</code>. If the proposal is not permitted, it selects a compatible suite from the sender\u2019s <code>CanDownshiftTo</code> list. 3. Response \u2014 Receiver records the final choice as <code>AcceptedSuite</code> in the TransportEnvelope. 4. Pinning \u2014 The capsule pins <code>PinnedAgreement \u2192 Agreement</code> and <code>NegotiatedSuite \u2192 ProtocolSuite</code>. 5. Verification \u2014 Upon receipt, validators confirm that the capsule\u2019s suite matches the pinned Agreement and any downshift path was explicitly allowed.</p> <p>Example: <pre><code>TransportEnvelope\n \u251c\u2500\u2500 ForAgreement \u2192 #agr:std\n \u251c\u2500\u2500 ProposesSuite \u2192 #suite:std-full\n \u2514\u2500\u2500 AcceptedSuite \u2192 #suite:light-authz\n</code></pre></p>"},{"location":"core/trust-channel-design-spec/#3-envelope-layer-reference-expanded","title":"3. Envelope Layer Reference (Expanded)","text":"<p>(Each layer acts as a gate in the membrane funnel.)</p>"},{"location":"core/trust-channel-design-spec/#31-transport-envelope","title":"3.1 Transport Envelope","text":"<p>Summary: The outermost envelope governing routing, Agreement pinning, and protocol negotiation.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose","title":"Conceptual Purpose","text":"<p>The TransportEnvelope establishes the routing and trust context for the capsule. It ensures that the message travels only between agents authorized by the governing Agreement and that both peers agree on the ProtocolSuite governing this exchange.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships","title":"Holon Type and Relationships","text":"<pre><code>HolonType: TransportEnvelope\nRelationships:\n  Wraps \u2192 AuthNEnvelope\n  ForAgreement \u2192 Agreement\n  ProposesSuite \u2192 ProtocolSuite?\n  AcceptedSuite \u2192 ProtocolSuite\n  SenderAgent \u2192 Agent\n  RecipientAgent \u2192 Agent\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields","title":"Key Data Fields","text":"<ul> <li><code>sender_id</code>: Agent identifier of initiator</li> <li><code>recipient_id</code>: target Agent identifier</li> <li><code>agreement_ref</code>: reference to Agreement ID and version hash</li> <li><code>transport_protocol</code>: protocol to be used (DHT, relay, direct)</li> <li><code>timestamp</code>: for replay detection</li> <li><code>routing_signature</code>: optional checksum or route proof</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps","title":"Processing Steps","text":"<p>Build: 1. Fetch Agreement metadata; confirm peer is an authorized participant. 2. Select candidate <code>ProtocolSuite</code> and record as <code>ProposesSuite</code>. 3. Compute and store routing metadata and Agreement hash. 4. Attach the next envelope as payload.</p> <p>Validate: 1. Verify Agreement hash matches local record. 2. Check recipient field corresponds to the local Agent. 3. Confirm <code>AcceptedSuite</code> belongs to Agreement\u2019s allowed suites. 4. Resolve routing path via Agreement transport settings.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome","title":"Expected Outcome","text":"<p>Validated routing context and pinned Agreement; the capsule is confirmed to have arrived at the correct membrane pore under the proper governance framework.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance","title":"Developer Guidance","text":"<p>Rust developers should implement this as the first validator in the inbound pipeline. TransportEnvelope validation failures typically indicate misrouting or incompatible Agreements.</p>"},{"location":"core/trust-channel-design-spec/#32-authentication-envelope-authn","title":"3.2 Authentication Envelope (AuthN)","text":"<p>Summary: Establishes the authenticity and integrity of the capsule.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_1","title":"Conceptual Purpose","text":"<p>The AuthNEnvelope confirms that the message was genuinely sent by an authorized participant and that its contents have not been modified since transmission.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_1","title":"Holon Type and Relationships","text":"<pre><code>HolonType: AuthNEnvelope\nRelationships:\n  Wraps \u2192 CryptoEnvelope\n  SignerAgent \u2192 Agent\n  UsesCryptoPolicy \u2192 CryptoPolicy\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_1","title":"Key Data Fields","text":"<ul> <li><code>signature_scheme</code>: algorithm identifier (e.g., Ed25519)</li> <li><code>signature</code>: base64 signature of inner envelope hash</li> <li><code>signer_public_key_ref</code>: pointer to sender\u2019s public key within Agreement</li> <li><code>signed_hash</code>: computed SHA-256 or BLAKE3 digest</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_1","title":"Processing Steps","text":"<p>Build: 1. Serialize the inner envelope and compute hash. 2. Sign the hash using the sender\u2019s private key via Lair. 3. Attach signature and metadata.</p> <p>Validate: 1. Retrieve sender\u2019s public key from Agreement. 2. Recompute hash of the inner envelope. 3. Verify signature using declared algorithm. 4. Log outcome to telemetry for risk analysis.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_1","title":"Expected Outcome","text":"<p>Message integrity and sender authenticity confirmed. If verification fails, the capsule is discarded.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_1","title":"Developer Guidance","text":"<p>Use the <code>ring</code> or <code>ed25519_dalek</code> crates for signing/verification; keys must always be accessed through Lair interfaces. Avoid holding private keys in process memory longer than necessary.</p>"},{"location":"core/trust-channel-design-spec/#33-cryptography-envelope-crypto","title":"3.3 Cryptography Envelope (Crypto)","text":"<p>Summary: Provides confidentiality by encrypting the inner payload.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_2","title":"Conceptual Purpose","text":"<p>The CryptoEnvelope ensures that only the intended recipient can read the inner payload. It also provides tamper protection and payload freshness via nonces.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_2","title":"Holon Type and Relationships","text":"<pre><code>HolonType: CryptoEnvelope\nRelationships:\n  Wraps \u2192 AuthZEnvelope\n  RecipientAgent \u2192 Agent\n  UsesCryptoPolicy \u2192 CryptoPolicy\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_2","title":"Key Data Fields","text":"<ul> <li><code>cipher_suite</code>: e.g., XChaCha20-Poly1305</li> <li><code>nonce</code>: unique per message</li> <li><code>encrypted_payload</code>: ciphertext of next envelope</li> <li><code>key_ref</code>: recipient public key or shared secret identifier</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_2","title":"Processing Steps","text":"<p>Build: 1. Serialize inner envelope. 2. Generate random nonce. 3. Encrypt payload with recipient\u2019s public key or derived shared secret. 4. Attach cipher suite metadata.</p> <p>Validate: 1. Fetch recipient private key from Lair. 2. Decrypt payload using declared cipher suite. 3. Verify authentication tag integrity. 4. Replace ciphertext with plaintext inner envelope.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_2","title":"Expected Outcome","text":"<p>Payload decrypted successfully; the next layer is now readable only by authorized recipient.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_2","title":"Developer Guidance","text":"<p>Follow the crypto policy declared in Agreement. Ensure nonce uniqueness per sender-recipient-session to prevent replay attacks.</p>"},{"location":"core/trust-channel-design-spec/#34-authorization-envelope-authz","title":"3.4 Authorization Envelope (AuthZ)","text":"<p>Summary: Enforces role- and scope-based permission checks.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_3","title":"Conceptual Purpose","text":"<p>The AuthZEnvelope ensures the request is permitted under the Agreement\u2019s role, scope, and timing rules. It acts as a programmable contract verifying that the sender\u2019s authority matches the Dance being requested.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_3","title":"Holon Type and Relationships","text":"<pre><code>HolonType: AuthZEnvelope\nRelationships:\n  Wraps \u2192 DispatchEnvelope\n  ForAgreement \u2192 Agreement\n  EvaluatedBy \u2192 AuthZPolicy\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_3","title":"Key Data Fields","text":"<ul> <li><code>role</code>: sender\u2019s role within Agreement</li> <li><code>scope</code>: access scope or resource domain</li> <li><code>policy_tag</code>: identifier for specific AuthZPolicy</li> <li><code>valid_from</code> / <code>valid_until</code>: temporal constraints</li> <li><code>policy_signature</code>: optional policy binding proof</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_3","title":"Processing Steps","text":"<p>Build: 1. Query Agreement for sender\u2019s role and applicable AuthZPolicy. 2. Embed policy tag and validity window. 3. Sign policy tag if required.</p> <p>Validate: 1. Fetch AuthZPolicy from Agreement. 2. Evaluate role-scope alignment against requested Dance. 3. Check time window validity. 4. Verify policy signature if provided.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_3","title":"Expected Outcome","text":"<p>Authorization confirmed. Capsule can proceed to dispatch. If denied, validation stops with <code>HolonError::UnauthorizedRole</code>.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_3","title":"Developer Guidance","text":"<p>The AuthZ layer is where governance logic is enforced. Ensure policies are declarative holons so they can evolve without code changes.</p>"},{"location":"core/trust-channel-design-spec/#35-dispatch-envelope","title":"3.5 Dispatch Envelope","text":"<p>Summary: Controls membrane handoff to local execution.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_4","title":"Conceptual Purpose","text":"<p>The DispatchEnvelope represents the moment a capsule transitions from inter-Space validation into intra-Space execution. It validates the target I-Space, ensures that the Dance type is known locally, and checks that any declared target matches an available handler.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_4","title":"Holon Type and Relationships","text":"<pre><code>HolonType: DispatchEnvelope\nRelationships:\n  Wraps \u2192 PayloadEnvelope\n  TargetSpace \u2192 Space\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_4","title":"Key Data Fields","text":"<ul> <li><code>target_space</code>: identifier of destination I-Space or subcontext</li> <li><code>execution_context</code>: optional environment variables</li> <li><code>dispatch_signature</code>: integrity hash of routing parameters</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_4","title":"Processing Steps","text":"<p>Build: 1. Determine target I-Space based on Agreement routing. 2. Compute dispatch hash. 3. Attach as header to envelope.</p> <p>Validate: 1. Confirm that <code>target_space</code> matches local identifier. 2. Check that Dance type exists and is callable. 3. Log dispatch acceptance event.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_4","title":"Expected Outcome","text":"<p>Local execution context prepared; control passed to Choreographer.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_4","title":"Developer Guidance","text":"<p>Implement DispatchEnvelope validation as the final gate before local code execution. Validation failures should never trigger automatic retries.</p>"},{"location":"core/trust-channel-design-spec/#36-payload-envelope","title":"3.6 Payload Envelope","text":"<p>Summary: Contains the actual DanceRequest or DanceResponse.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_5","title":"Conceptual Purpose","text":"<p>The PayloadEnvelope is the innermost layer, containing the semantic content of the interaction. At this point all membrane gates have been cleared.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_5","title":"Holon Type and Relationships","text":"<pre><code>HolonType: PayloadEnvelope\nRelationships:\n  HasPayloadDance \u2192 Dance\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_5","title":"Key Data Fields","text":"<ul> <li><code>payload_type</code>: Request or Response</li> <li><code>payload_model</code>: descriptor name</li> <li><code>payload_digest</code>: hash for integrity</li> <li><code>content_encoding</code>: optional compression scheme</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_5","title":"Processing Steps","text":"<p>Build: 1. Serialize Dance into canonical format. 2. Compute payload hash. 3. Embed descriptor metadata.</p> <p>Validate: 1. Verify hash matches payload content. 2. Deserialize Dance into model. 3. Pass to Choreographer.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_5","title":"Expected Outcome","text":"<p>Validated and deserialized Dance ready for execution.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_5","title":"Developer Guidance","text":"<p>This envelope rarely fails validation except for integrity mismatches. Any schema errors should be handled by the Choreographer.</p>"},{"location":"core/trust-channel-design-spec/#37-exfiltration-envelope-outbound","title":"3.7 Exfiltration Envelope (Outbound)","text":"<p>Summary: Filters outbound data per Agreement\u2019s ExfiltrationPolicy.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_6","title":"Conceptual Purpose","text":"<p>The ExfiltrationEnvelope ensures that responses leaving a Space comply with that Space\u2019s data sharing rules. It enforces outbound privacy and ensures that only agreed-upon data crosses the membrane.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_6","title":"Holon Type and Relationships","text":"<pre><code>HolonType: ExfiltrationEnvelope\nRelationships:\n  Wraps \u2192 CryptoEnvelope\n  AppliesPolicy \u2192 ExfiltrationPolicy\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_6","title":"Key Data Fields","text":"<ul> <li><code>policy_tag</code>: identifier of applied ExfiltrationPolicy</li> <li><code>allowed_fields</code>: whitelist of fields</li> <li><code>thresholds</code>: quantitative limits (e.g., max records)</li> <li><code>sanitization_map</code>: redaction rules</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_6","title":"Processing Steps","text":"<p>Build: 1. Retrieve ExfiltrationPolicy from Agreement. 2. Filter or redact prohibited fields. 3. Record policy tag and transformation metadata.</p> <p>Validate: 1. Confirm policy tag exists and matches Agreement. 2. Verify filtered payload complies with declared thresholds. 3. Hash sanitized payload for audit.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_6","title":"Expected Outcome","text":"<p>Outbound data sanitized, ready for encryption.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_6","title":"Developer Guidance","text":"<p>Developers must implement serialization filters at this layer. Avoid policy logic in business code; always reference ExfiltrationPolicy holons.</p>"},{"location":"core/trust-channel-design-spec/#38-unlock-envelope-optional","title":"3.8 Unlock Envelope (Optional)","text":"<p>Summary: Captures Second-Factor Session (SFS) verification for sensitive Dances.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_7","title":"Conceptual Purpose","text":"<p>The UnlockEnvelope adds human-level verification to the cryptographic stack. It confirms that the user controlling the device has recently authenticated through a configured second factor before performing sensitive or high-risk operations.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_7","title":"Holon Type and Relationships","text":"<pre><code>HolonType: UnlockEnvelope\nRelationships:\n  Wraps \u2192 NextEnvelope\n  VerifiedBy \u2192 StepUpPolicy\n  SessionBelongsTo \u2192 Agent\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_7","title":"Key Data Fields","text":"<ul> <li><code>session_id</code>: UUID of SFS</li> <li><code>verified_method</code>: biometric | PIN | hardware_key</li> <li><code>expires_at</code>: timestamp</li> <li><code>issued_at</code>: timestamp</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_7","title":"Processing Steps","text":"<p>Build: 1. Verify an active SFS exists for this Agent. 2. Record method and expiry. 3. Link to StepUpPolicy.</p> <p>Validate: 1. Fetch SFS from secure store. 2. Check TTL and idle timeout. 3. Confirm cryptographic binding to Agent ID.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_7","title":"Expected Outcome","text":"<p>Step-up authentication confirmed; the Dance may proceed.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_7","title":"Developer Guidance","text":"<p>UnlockEnvelope creation and validation should integrate with the device OS authentication APIs. Never store SFS secrets in application memory.</p>"},{"location":"core/trust-channel-design-spec/#39-sessionstate-envelope-optional","title":"3.9 SessionState Envelope (Optional)","text":"<p>Summary: Transports transient holon state for stateless executions.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_8","title":"Conceptual Purpose","text":"<p>The SessionStateEnvelope allows stateful workflows to execute in stateless environments by serializing necessary transient holons and relationship references. It ensures the guest process has enough context to continue processing without permanent data leakage.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_8","title":"Holon Type and Relationships","text":"<pre><code>HolonType: SessionStateEnvelope\nRelationships:\n  Wraps \u2192 PayloadEnvelope\n  CarriesState \u2192 [TransientHolonPool, NurseryRefs]\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_8","title":"Key Data Fields","text":"<ul> <li><code>state_hash</code>: integrity checksum</li> <li><code>state_length</code>: size in bytes</li> <li><code>allowed_types</code>: whitelist of permitted transient types</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_8","title":"Processing Steps","text":"<p>Build: 1. Serialize transient pool and nursery references. 2. Compute hash and record metadata. 3. Attach to next envelope.</p> <p>Validate: 1. Verify hash integrity. 2. Deserialize transient pool. 3. Enforce allowed_types filter.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_8","title":"Expected Outcome","text":"<p>State hydrated in recipient\u2019s transient context; execution can proceed seamlessly.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_8","title":"Developer Guidance","text":"<p>Keep transient pools small. This mechanism is not intended for bulk data transfer. Always validate deserialized objects before use.</p>"},{"location":"core/trust-channel-design-spec/#4-lifecycle-overview","title":"4. Lifecycle Overview","text":"<ol> <li>Outbound Request: Select suite, negotiate, build, transmit.</li> <li>Inbound Validation: Validate sequentially (Transport\u2192AuthN\u2192Crypto\u2192AuthZ\u2192Dispatch\u2192Payload).</li> <li>Response: Apply outbound envelopes in reverse order and send back.</li> </ol>"},{"location":"core/trust-channel-design-spec/#5-error-handling","title":"5. Error Handling","text":"Error Description <code>InvalidAgreementRef</code> Agreement hash mismatch. <code>ProtocolSuiteMismatch</code> Suite not permitted. <code>InvalidProtocolProposal</code> Proposed suite invalid. <code>SuiteDownshiftNotPermitted</code> Unauthorized fallback. <code>SignatureInvalid</code> AuthN failure. <code>DecryptionFailed</code> Crypto validation failed. <code>UnauthorizedRole</code> AuthZ check failed. <code>DispatchDenied</code> Target invalid. <code>ExfiltrationDenied</code> Policy violation. <code>RequiresSecondFactor</code> Missing SFS. <code>SessionStateUnavailable</code> Missing transient data."},{"location":"core/trust-channel-design-spec/#6-implementation-notes","title":"6. Implementation Notes","text":"<ul> <li>All envelopes and policies are holons declared in the Meta-Schema.</li> <li>Validators and builders are modular and referenced dynamically via descriptors.</li> <li>Use Lair for all key operations; private keys never exposed.</li> <li>Emit telemetry for every validation result to support audit and behavioral analysis.</li> <li>Agreements may define multiple suites per sensitivity tier for flexible negotiation.</li> </ul>"},{"location":"core/trust-channel-design-spec/#7-summary","title":"7. Summary","text":"<p>The Trust Channel provides a layered, Agreement-driven security framework for all cross-Space communications. Each envelope serves a distinct purpose, from routing and authentication to encryption, authorization, dispatch, and outbound filtering. Protocol negotiation guarantees interoperability, while each validation gate enforces sovereignty and trust. This layered architecture transforms MAP\u2019s peer-to-peer network into a self-verifying, self-governing fabric for secure inter-Space collaboration.</p>"},{"location":"mapp-dev/extensibility-model/","title":"MAP Extensibility Model","text":""},{"location":"mapp-dev/extensibility-model/#introduction","title":"Introduction","text":"<p>In the Memetic Activation Platform (MAP), we embrace a fundamentally different approach to extensibility than traditional software systems. Instead of a rigid set of predefined types and relationships, the MAP offers a flexible and open-ended ontology where all entities are represented as holons. This document explains how this extensibility model works and why it matters for developers adopting the MAP.</p>"},{"location":"mapp-dev/extensibility-model/#the-problem-with-fixed-ontologies","title":"The Problem with Fixed Ontologies","text":"<p>Most traditional software systems operate with a fixed schema. Each release defines a set of types, relationships, and behaviors that are controlled by the application provider.</p> <p></p> <p>Over time, as these providers add more functionality, they introduce more and more predefined types\u2014sometimes ballooning into thousands of tightly coupled objects. While this might provide a broad feature set, it also leads to vendor lock-in due to high-switching costs. And no matter how large it gets, you are still limited by the app provider's imagination and release cadence. Got a need to manage different types of data? Novel behavior? A superior visual experience? Good luck! File your enhancement request and then... wait. </p>"},{"location":"mapp-dev/extensibility-model/#emergent-complexity-and-the-need-for-open-ended-ontology","title":"Emergent Complexity and the Need for Open-Ended Ontology","text":"<p>In contrast, the MAP is built on the idea that emergent complexity demands an open-ended ontology. </p> <p></p> <p>By treating everything as a holon\u2014a self-describing, active entity with properties, relationships, and behaviors (dances)\u2014we allow developers to extend the platform in ways that we, as the platform creators, could never fully predict.</p> <p>This means that instead of waiting for a central authority to add a new type, developers can create their own types and relationships as needed. They can share these extensions in a commons, fostering a rich ecosystem of visualizers, application behaviors, and more.</p>"},{"location":"mapp-dev/extensibility-model/#how-extensibility-works","title":"How Extensibility Works","text":"<p>The design goal is to: - Provide strong guarantees about structural compatibility. - Enable application-level innovation without duplicating or rewriting core definitions. - Preserve semantic integrity by constraining what \u201cextension\u201d means.</p> <p>The MAP\u2019s extensibility model is guided by clear, predictable rules that keep extensions simple, DRY (Don\u2019t Repeat Yourself), and interoperable:</p> <ol> <li> <p>Single Inheritance Only    Each new type can extend exactly one other type. There is no multiple inheritance. You inherit all properties, relationships, and dances from that single parent type.</p> </li> <li> <p>Additive, Not Subtractive    When you extend a type, you adopt all of its existing behaviors wholesale. You can add new behaviors, but you do not remove or override inherited ones. This keeps inheritance additive and predictable.</p> </li> <li> <p>Flattened Type Descriptors    The system flattens all inherited properties, relationships, and dances into a single type descriptor for the child type. You only specify what\u2019s unique about your new type; all common behavior is defined once and inherited automatically.</p> </li> <li> <p>Alternative for Variations    If you need a different set of behaviors, you start from a different parent type or reintroduce only the behaviors you want via composition. You avoid erasing or modifying inherited features directly.</p> </li> <li> <p>Extending Across Type Kinds    Extensibility is not limited to holon types. You can extend value types, property types, relationship types, and dance types. This allows you to evolve the ontology across all type kinds.</p> </li> <li> <p>Community and Self-Defined Extensions    You can extend not just core types, but also types defined by yourself or other MAP adopters. This makes the ecosystem a living, collaborative space where new types can evolve organically.</p> </li> <li>Leaf-Only Instantiation    Only the final (leaf) type in an Extends chain can be instantiated. All properties, relationships, and dances from parent types are flattened into the leaf type\u2019s descriptor, ensuring there is a single, complete definition for every instance. Intermediate types serve only as templates for shared structure and behavior, never as instantiable entities.</li> <li>Single Implementation per Dance    Every dance type defined anywhere in an Extends chain can have only one implementation within that chain. Implementations are bound to the type level that defines the dance type and may reference only properties and relationships defined at that level or above. You cannot \"override\" the implementation of a dance defined higher in the extends chain. Thus, if you do not want a dance (or property or relationship) of a type, do not extend that type.</li> </ol>"},{"location":"mapp-dev/extensibility-model/#core-types-as-your-starting-point","title":"Core Types as Your Starting Point","text":"<p>Although the MAP represents everything as a holon, you don\u2019t have to start from a blank slate. The platform ships with a rich foundation of Core Types \u2014 fully-defined, concrete holon types like <code>Meme</code>, <code>Agent</code>, <code>Service</code>, <code>VitalCapital</code>, <code>MemeGroup</code>, and <code>Memeplex</code>. These types already encapsulate key MAP semantics and relationships, giving you a solid base to extend from.</p> <p>When you extend a core type: - You inherit its properties, relationships, and dances. - You avoid re-defining the foundational semantics that MAP tools and visualizers expect. - You stay aligned with the larger ecosystem, improving interoperability with other mapps.</p> <p>Use of these core types is entirely optional. If your domain requires something fundamentally different, you can extend directly from <code>Holon</code> (the most general concrete type) or even create your own abstract type to serve as a base.</p> <p>A common mental model looks like this:</p> <pre><code>       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502       Meta Types         \u2502  (abstract obligations: structure of types)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502    Abstract Types        \u2502  (conceptual categories, no instances)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502     Core Types Layer     \u2502  (instantiable MAP-provided bases: Meme, Agent...)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502  Extension Types Layer   \u2502  (your domain-specific types)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>A powerful feature: You can extend not only core types, but also types defined by other MAP developers. This means the ontology can evolve in ever richer, more specialized ways \u2014 collaboratively and incrementally \u2014 without requiring changes to the core. The result is a living ecosystem of interoperable types, each building on the work of others.</p> <p>Pro tip for mapp developers: If you find yourself removing or avoiding core behaviors from a parent type, it may be better to pick a different starting point \u2014 either another core type, a type from another developer, or <code>Holon</code> itself \u2014 so you keep your inheritance clean and predictable.</p>"},{"location":"mapp-dev/extensibility-model/#an-example","title":"An Example","text":"<p>Let's look at an example to see how these rules work in action.</p>"},{"location":"mapp-dev/extensibility-model/#1-leaf-only-instances","title":"1. Leaf-Only Instances","text":"<p>If you have <code>A</code> Extends <code>B</code> Extends <code>Meme</code>, only A can have instances. - Properties and relationships from all levels are flattened into <code>A</code>\u2019s descriptor. - Your instance is \u201can A\u201d with one set of properties and relationships to populate. - Intermediate types (<code>B</code>, <code>Meme</code>) serve as templates for shared structure and behavior, but are never instantiated directly.</p>"},{"location":"mapp-dev/extensibility-model/#2-separate-the-contract-from-the-implementation","title":"2. Separate the Contract from the Implementation","text":"<p>Every dance has two aspects: - DanceDescriptor (contract): Name, arguments, result type, semantics, and required/optional status. - DanceImplementation (code): The executable logic, bound to the type that defines it.</p> <p>MAP preserves the contract vs. implementation distinction without introducing a separate \u201cinterface\u201d construct. Obligations are explicit in the type descriptor; the code is provided at the defining type.</p>"},{"location":"mapp-dev/extensibility-model/#3-where-implementations-may-live","title":"3. Where Implementations May Live","text":"<p>A DanceImplementation can be declared in: - The MAP Core Type you extended (e.g., <code>Meme</code>) - An intermediate type in the chain (<code>B</code>) - Your own leaf type (<code>A</code>)</p> <p>Instances always dispatch to the single implementation allowed for that descriptor in the chain.</p>"},{"location":"mapp-dev/extensibility-model/#4-rules-that-avoid-overrides","title":"4. Rules that Avoid Overrides","text":"<p>To keep things predictable, DRY, and override-free:</p> <ol> <li>Only the leaf instantiates \u2014 No instances of intermediate types.</li> <li>Unique dance identity across the chain \u2014 No two types in the chain may declare the same DanceDescriptor ID.</li> <li>Single implementation per dance per chain \u2014 At most one implementation for a given descriptor in the chain.</li> <li>If required and none found \u2192 validation fails.</li> <li>If optional and none found \u2192 allowed.</li> <li>If more than one found \u2192 validation fails.</li> <li>Bound to defining type \u2014 Implementations may only reference properties and relationships defined at their own level or above.</li> <li>Different behavior without overrides \u2014 If you need different logic, define a new (possibly versioned) DanceDescriptor or choose a different parent type.</li> </ol>"},{"location":"mapp-dev/extensibility-model/#5-effective-set-computation-loadvalidation-time","title":"5. Effective Set Computation (Load/Validation Time)","text":"<p>At load or validation time, MAP precomputes the EffectiveDanceSet for your leaf type:</p> <pre><code>EffectiveDanceSet(A):\n  let chain = [Meme, B, A]  // ancestor \u2192 leaf\n  let seen = {}\n  for each type T in chain:\n    for each DanceImplementation impl in T:\n      let id = impl.descriptor_id\n      if id in seen: error \"multiple implementations in chain\"\n      seen[id] = impl\n\n  // Ensure all required descriptors in chain have an implementation\n  for each required descriptor d in chain:\n      if d.id not in seen: error \"required dance missing\"\n\n  return seen\n</code></pre> <p>This means your mapp instances dispatch directly to the right implementation with no runtime search and no ambiguity.</p>"},{"location":"mapp-dev/extensibility-model/#benefits-for-developers","title":"Benefits for Developers","text":"<ul> <li>Clarity: No tangled multiple-inheritance chains or runtime delegation puzzles.</li> <li>Predictability: The full definition of a type is always visible in its flattened descriptor.</li> <li>Reusability: Shared behavior is defined once and reliably inherited.</li> <li>Interoperability: Extensions preserve all inherited relationships and obligations, ensuring they work seamlessly with existing MAP tooling.</li> </ul>"},{"location":"mapp-dev/extensibility-model/#comparison-to-traditional-inheritance-models","title":"Comparison to Traditional Inheritance Models","text":"<p>The MAP\u2019s model differs from common inheritance patterns found in mainstream programming languages:</p> <ul> <li>Classical OOP Inheritance (Java, C++)   These languages often allow single or multiple inheritance. Multiple inheritance can lead to the diamond problem, where it\u2019s unclear which inherited method should be used. The MAP avoids this entirely by allowing only single inheritance and flattening all inherited elements into one unified type descriptor.</li> <li> <p>Interfaces and Mixins (Java Interfaces, Ruby Modules)</p> </li> <li> <p>In languages like Java, interfaces separate the contract (what behaviors a type must provide) from the implementation (how those behaviors are carried out), to avoid the pitfalls of tying the two together in rigid inheritance chains. Mixins add reusable behavior across otherwise unrelated types.   In the MAP, this separation is preserved but modeled explicitly through the type system: a holon\u2019s type descriptor declares its obligations (its contract) via inherited properties, relationships, and required dances, while the actual implementation of those dances can be provided or overridden in the specific type or its runtime context. This makes contracts explicit without introducing a separate interface construct, and still allows behaviors to be composed or reused across types.</p> </li> <li> <p>Delegation and Composition (Go Interfaces, \u201ccomposition over inheritance\u201d)   Composition-based designs assemble objects from multiple components, often requiring explicit delegation. The MAP achieves similar modularity by letting you start from the most relevant parent type and additively extend it, while maintaining a single, flattened descriptor. You get the clarity of composition without the overhead of managing multiple internal objects.</p> </li> </ul> <p>By combining inheritance\u2019s clarity with composition\u2019s modularity, the MAP ensures that extensions are both powerful and easy to reason about.</p>"},{"location":"mapp-dev/extensibility-model/#conclusion","title":"Conclusion","text":"<p>By combining a stable foundation of core concrete types with a disciplined, flattened, single-inheritance model, the MAP gives developers a robust but simple way to extend the platform. You inherit everything you need from your parent type, add only what\u2019s unique, and know that your type will integrate cleanly into the larger ecosystem. This balance of openness and structure is what allows the MAP to evolve in step with the diverse needs of its community.  </p>"},{"location":"mapp-dev/holon-data-loader-guide/","title":"MAP Holon Data Loader: JSON Import Format \u2013 Comprehensive Authoring Guide","text":"<p>This guide provides developers with a complete and authoritative reference for constructing valid JSON import files for the MAP Holon Data Loader. It reflects current conventions for authoring schema definitions, base/core types, and domain-specific instances in a self-describing, holonic data model.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#overview","title":"\u2728 Overview","text":"<p>The MAP Holon Data Loader allows for the declarative import of holons and their relationships into a (single) MAP Holon Space. The import format is intentionally minimal, self-describing, and designed for bootstrapping both type descriptors and real data without relying on runtime logic.</p> <p>All holons \u2014 including types, schemas, and instances \u2014 are defined uniformly. Their type, structure, and descriptors are all expressible using the same format.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#foundational-concepts","title":"\ud83d\udcda Foundational Concepts","text":"<p>MAP import files are composed of holons \u2014 self-contained objects representing types, data, or components. This section introduces key concepts that underpin the entire format.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#holons-and-types","title":"Holons and Types","text":"<p>Every holon has a <code>type</code> that points to a type descriptor (e.g., <code>BookType</code>, <code>PropertyType</code>). The type is used to determine:</p> <ul> <li>What properties are allowed</li> <li>What relationships can be included</li> <li>How validation is applied</li> </ul> <p>The <code>type</code> field acts as both a signal and a shortcut. It removes the need to include an explicit <code>DescribedBy</code> relationship.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#keyed-vs-keyless-holon-types","title":"Keyed vs. Keyless Holon Types","text":"<p>Every holon in MAP is an instance of a HolonType, and that HolonType determines whether instances are keyed or keyless.</p> <ul> <li>Keyed Holon Types require that each instance includes a stable <code>key</code>, derived from one or more of its properties using a <code>UsesKeyRule</code>. Holons of these types:</li> <li>Must include a <code>key</code> field in the JSON import</li> <li>May be referenced elsewhere using <code>$ref</code></li> <li> <p>May be the target of declared relationships</p> </li> <li> <p>Keyless Holon Types do not permit their instances to include a key. Holons of these types:</p> </li> <li>Must be embedded inline wherever they are used</li> <li>May not be referenced via <code>$ref</code> (not even by <code>id:</code>)</li> <li>May not be the target of any declared relationship</li> <li>Must act as the source of at least one relationship to a keyed holon (to remain anchored in the graph)</li> </ul> <p>This distinction is structural and enforced during staging. The loader will reject any violation of these rules \u2014 including attempts to reference or directly target a keyless holon.</p> <p>\ud83d\udd0d Whether a holon is keyed is not an authoring choice \u2014 it is defined by the HolonType it instantiates.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key-derivation-rules","title":"\ud83d\udd22 Key Derivation Rules","text":"<p>Every keyed holon must declare a <code>UsesKeyRule</code>, pointing to a <code>FormatKeyRule</code> with:</p> <ul> <li><code>format</code>: A string template (e.g., <code>\"$0\"</code>, <code>\"($0)-[$1]-&gt;($2)\"</code>)</li> <li><code>property_names</code>: List of property or inferred names used to fill the format</li> </ul> <p>The authored <code>key</code> must match the result of evaluating the format rule.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#foundational-rule-for-all-types","title":"\ud83e\uddf1 Foundational Rule for All Types","text":"<p>Every MAP type descriptor (e.g., <code>BookType</code>, <code>PropertyType</code>, <code>MetaHolonType</code>) must:</p> <ul> <li>\u2705 Be DescribedBy the <code>MetaHolonType</code> \u2014 this defines the meta-structure of the type descriptor itself</li> <li>\u2705 Extend the foundational <code>MetaTypeDescriptor</code> \u2014 inheriting shared fields like <code>type_name</code>, <code>description</code>, etc.</li> </ul> <p>This rule applies uniformly to all types in MAP, including both core types (like <code>PropertyType</code>, <code>SchemaType</code>) and meta-types (like <code>MetaHolonType</code>, <code>MetaSchemaType</code>). It ensures:</p> <ul> <li>\ud83d\udd04 Reflexivity \u2014 Types are holons too</li> <li>\ud83d\udd0d Introspection \u2014 Schema tools can explore and validate all descriptors using a shared structure</li> <li>\ud83e\uddf1 Composability \u2014 Specialized descriptors build on common foundations</li> </ul> <p>\ud83e\udde0 Even <code>MetaHolonType</code> itself is DescribedBy the <code>MetaHolonType</code> and Extends <code>MetaTypeDescriptor</code>.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#holontype-requirements","title":"\ud83d\udd10 HolonType Requirements","text":"<p>In addition to the foundational rule above, all HolonTypes must:</p> <ul> <li>\u2705 Declare a <code>UsesKeyRule</code> \u2014 either a formatting rule (e.g., <code>TypeName.KeyRule</code>) or <code>None.KeyRule</code></li> </ul> <p>This ensures that the distinction between keyed and keyless types is structurally enforced and discoverable via introspection.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#best-practices","title":"\ud83d\udcda Best Practices","text":"<ul> <li>\u2705 Include <code>UsesKeyRule</code> for every HolonType descriptor</li> <li>\u2705 Use consistent naming across <code>type_name</code>, <code>display_name</code>, and <code>key</code></li> <li>\u2705 Use inline embedding for keyless holons or unique instances</li> <li>\u2705 Use <code>$ref</code> for reusable, keyed holons</li> <li>\u274c Do not author <code>DescribedBy</code> or <code>OwnedBy</code> \u2014 these are handled automatically</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#referencing-other-holons-ref-and-inline-embedding","title":"Referencing Other Holons: <code>$ref</code> and Inline Embedding","text":"<p>In MAP\u2019s JSON import format, holons frequently refer to other holons \u2014 whether to define relationships, specify constraints, compose schemas, or extend descriptors. These references can be expressed in one of two interchangeable forms:</p> <ol> <li><code>$ref</code> strings \u2014 Concise pointers to other keyed holons</li> <li>Inline embedded holons \u2014 Full holon objects defined in place</li> </ol> <p>Both forms are valid anywhere a holon is expected, and the Holon Data Loader treats them equivalently when staging, validating, and committing.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#motivation-reference-scenarios-map-must-support","title":"\ud83e\udde0 Motivation: Reference Scenarios MAP Must Support","text":"Scenario Example Staged vs. Saved Refer to holons defined in the same file or already saved in the space Local vs. External Link to holons from another HolonSpace (e.g., shared schemas) Keyed vs. Keyless <code>$ref</code> keyed holons; embed keyless ones Reusable vs. One-Off Reuse types and entities via <code>$ref</code>; define constraints inline"},{"location":"mapp-dev/holon-data-loader-guide/#ref-semantics","title":"\ud83e\udded <code>$ref</code> Semantics","text":"<p><code>$ref</code> is a string-based shorthand for referencing previously defined, saved, or external keyed holons. It can be used anywhere a holon is expected and the type can be inferred from context.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#supported-ref-formats","title":"Supported <code>$ref</code> Formats","text":"<code>$ref</code> Format Meaning Example <code>\"#key\"</code> Reference to a keyed holon by key only <code>\"#future-primal\"</code> <code>\"id:&lt;HolonId&gt;\"</code> Reference by ActionHash (HolonId) <code>\"id:uhCAkYmv...\"</code> <code>\"@Proxy:key\"</code> External holon via proxy name + key <code>\"@Library:Books\"</code> <code>\"ext:&lt;Proxy&gt;:&lt;Id&gt;\"</code> External holon via proxy ID + local ID <code>\"ext:uhProxy:uhId\"</code> <p>\ud83d\udd0d The holon\u2019s type is inferred from context. If the key does not match a holon of the expected type, validation will fail.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#inline-embedded-holons","title":"\ud83d\udce6 Inline Embedded Holons","text":"<p>Use inline embedding to define a holon directly in context. This is required for:</p> <ul> <li>Keyless holons</li> <li>One-off structures, like constraints or descriptors</li> <li>Situations where local scoping improves clarity</li> </ul> <p>Caveat: Each inline Holon is importing a new Holon, be careful to avoid unwanted duplication</p>"},{"location":"mapp-dev/holon-data-loader-guide/#reference-examples","title":"\u2705 Reference Examples","text":"<p>TBD</p>"},{"location":"mapp-dev/holon-data-loader-guide/#invalid-reference-cases","title":"\ud83d\udeab Invalid Reference Cases","text":"<ul> <li>\u274c <code>$ref</code> to a keyless holon (must be embedded)</li> <li>\u274c <code>id:</code> reference to a keyless holon \u2014 even though syntactically allowed, keyless holons must never be the target of a declared relationship</li> <li>\u274c References outside expected type context</li> <li>\u274c Mixing <code>$ref</code> and <code>type</code> in a single object</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#summary","title":"\u2705 Summary","text":"Reference Form Best For Requires Key Reusable? <code>$ref</code> Reuse of shared or saved holons \u2705 Yes \u2705 Yes Inline One-off or keyless components \u274c No \u274c No"},{"location":"mapp-dev/holon-data-loader-guide/#file-structure","title":"\ud83d\udcc1 File Structure","text":"<p>Each JSON import file consists of two top-level keys:</p> <pre><code>{\n  \"meta\": { ... },\n  \"holons\": [ ... ]\n}\n</code></pre> <ul> <li><code>meta</code>: Metadata describing the file</li> <li><code>holons</code>: List of holon definitions to be imported</li> </ul> <p>Each entry in the <code>holons</code> array is a self-contained JSON object representing a single holon.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#holon-definition","title":"\ud83d\udd39 Holon Definition","text":"<p>Each holon is a JSON object with four primary fields:</p> <ul> <li><code>type</code>: The descriptor for this holon (replaces <code>DescribedBy</code>)</li> <li><code>key</code>: Required only for keyed holons</li> <li><code>properties</code>: A map of named scalar property values</li> <li><code>relationships</code>: A list of outbound relationships to other holons</li> </ul> <p>See the Foundational Concepts section above for background on types, keys, references, and embedding.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#type","title":"\ud83e\udde9 <code>type</code>","text":"<p>The <code>type</code> field identifies the HolonType (or other descriptor type) that describes this holon. It replaces the need to author a <code>DescribedBy</code> relationship.</p> <ul> <li>Format: a <code>#Key</code> reference to a known type descriptor</li> <li>Required for all holons</li> </ul> <p>Example:</p> <pre><code>\"type\": \"#BookType\"\n</code></pre> <p>This implies: - The holon is described by a <code>BookType</code> - All properties and relationships must conform to the rules defined by that type</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key","title":"\ud83e\udde9 <code>key</code>","text":"<p>The <code>key</code> is a unique identifier for keyed holons. It is:</p> <ul> <li>Required for holons of keyed Holon Types</li> <li>Not allowed for holons of keyless Holon Types</li> <li>Used as the reference target for <code>$ref</code> within the same or other import files</li> </ul> <p>Keys are derived based on the holon\u2019s HolonType, which includes a <code>UsesKeyRule</code> relationship pointing to a <code>FormatKeyRule</code>. This rule specifies how to construct the key from the holon\u2019s property values \u2014 and sometimes values on related holons.</p> <p>\ud83d\udd04 Because the key can be deterministically derived from the holon\u2019s structure, including it is technically redundant. However, the <code>key</code> field is explicitly included in the JSON import for: - Improved readability - <code>$ref</code> compatibility - Validation of key correctness at staging time</p>"},{"location":"mapp-dev/holon-data-loader-guide/#important","title":"\u26a0\ufe0f Important","text":"<p>If any property value involved in key derivation changes, the <code>key</code> field and any <code>$ref</code>'s to it must also be updated to match the new derived value. The loader will recompute the key using the declared <code>FormatKeyRule</code> and compare it to the authored key \u2014 raising a validation error if they do not match.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key-derivation-rules_1","title":"\ud83d\udd22 Key Derivation Rules","text":"<p>Every keyed holon must declare a <code>UsesKeyRule</code> relationship pointing to a <code>FormatKeyRule</code> \u2014 a holon that defines how the key should be constructed.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#formatkeyrule-structure","title":"FormatKeyRule Structure","text":"<p>A <code>FormatKeyRule</code> has two fields:</p> <ul> <li><code>format</code>: A string template (e.g., <code>\"$0\"</code>, <code>\"($0)-[$1]-&gt;($2)\"</code>)</li> <li><code>property_names</code>: An ordered list of names (strings) that supply the values for the placeholders</li> </ul> <p>Example:</p> <pre><code>{\n  \"type\": \"#FormatKeyRule\",\n  \"properties\": {\n    \"format\": \"$0\",\n    \"property_names\": [\"type_name\"]\n  }\n}\n</code></pre>"},{"location":"mapp-dev/holon-data-loader-guide/#common-patterns","title":"\u2705 Common Patterns","text":"<p>Single-property key (e.g., <code>MapStringValueType</code>): <pre><code>{\n  \"format\": \"$0\",\n  \"property_names\": [\"type_name\"]\n}\n</code></pre></p> <p>**Relationship Type Keys ** (inspired by OpenCypher notation): <pre><code>{\n  \"format\": \"($0)-[$1]-&gt;($2)\",\n  \"property_names\": [\"source_type\", \"type_name\", \"target_type\"]\n}\n</code></pre></p>"},{"location":"mapp-dev/holon-data-loader-guide/#declaring-useskeyrule","title":"\u270d\ufe0f Declaring UsesKeyRule","text":"<p>Inline:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": {\n    \"type\": \"#FormatKeyRule\",\n    \"properties\": {\n      \"format\": \"$0\",\n      \"property_names\": [\"type_name\"]\n    }\n  }\n}\n</code></pre> <p>By reference:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": { \"$ref\": \"FormatKeyRule:BookType.KeyRule\" }\n}\n</code></pre> <p>The loader validates all authored <code>key</code> values by recomputing them using the declared key rule and comparing the result.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#properties","title":"\ud83e\udde9 <code>properties</code>","text":"<p>The <code>properties</code> field contains a map of property name to scalar value, like so:</p> <pre><code>\"properties\": {\n  \"type_name\": \"BookType\",\n  \"enabled\": true,\n  \"max_length\": 255\n}\n</code></pre> <p>Each value must be one of the supported MAP scalar types: - <code>string</code> (e.g., <code>\"BookType\"</code>) - <code>number</code> (e.g., <code>42</code>, <code>3.14</code>) - <code>boolean</code> (e.g., <code>true</code>, <code>false</code>) - or an array of scalars (for multi-valued properties)</p> <p>Property types are enforced by the <code>PropertyType</code> descriptor referenced in the holon\u2019s <code>type</code>. The loader will convert each value into its appropriate <code>BaseValue</code> variant based on the declared value type \u2014 not based on any in-band <code>\"type\"</code> or <code>\"value\"</code> tags.</p> <p>\ud83d\udd12 Property values must be scalars. You cannot use structured objects (like <code>{ \"type\": ..., \"value\": ... }</code>) inside the <code>properties</code> field. Those are only valid in embedded holons or type definitions.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#relationships","title":"\ud83e\udde9 <code>relationships</code>","text":"<p>In MAP, every relationship pair is modeled as two named, uni-directional relationships:</p> <ul> <li>A declared relationship (e.g., <code>(Person)-[HasAddress]-&gt;(Address)</code>)</li> <li>Its corresponding inverse relationship (e.g., <code>(Address)-[AddressOf]-&gt;(Person)</code>)</li> </ul> <p>Strictly speaking, only declared relationships are allowed to be directly populated in the system\u2019s internal storage model. Inverse relationships are automatically derived based on this. However, the JSON import format allows you to populate either direction for convenience.</p> <p>If a JSON import populates an inverse relationship, the Holon Data Loader will:</p> <ol> <li>Look up its <code>InverseOf</code> link to find the declared relationship type.</li> <li>Internally redirect the population to that declared relationship.</li> <li>Leave the inverse direction empty (it will be auto-derived later).</li> </ol> <p>This supports a more natural and readable JSON layout in many scenarios.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#authoring-guidelines","title":"\u26a0\ufe0f Authoring Guidelines","text":"<ul> <li> <p>\u2705 Only populate one direction of a relationship pair.   Do not populate both <code>HasAddress</code> and <code>AddressOf</code>.</p> </li> <li> <p>\u26a0\ufe0f If the relationship involves a keyless holon type:</p> </li> <li>The declared relationship must be defined on the keyed holon type.</li> <li>You must embed the keyless holon inline, using the inverse direction.</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#example-embedding-a-keyless-holon","title":"\u2705 Example: Embedding a Keyless Holon","text":"<p>Let\u2019s say <code>PersonType</code> declares the relationship <code>HasAddress \u2192 AddressType</code>, and <code>AddressType</code> is keyless. We want to attach an address to a person:</p> <pre><code>{\n  \"type\": \"#PersonType\",\n  \"key\": \"charles-eisenstein\",\n  \"properties\": {\n    \"name\": \"Charles Eisenstein\"\n  },\n  \"relationships\": [\n    {\n      \"name\": \"AddressOf\",  \n        \"type\": \"#AddressType\",\n        \"properties\": {\n          \"city\": \"Keene\",\n          \"state\": \"New Hampshire\"\n        }\n      }\n  ]\n}\n</code></pre>"},{"location":"mapp-dev/holon-data-loader-guide/#explanation","title":"\ud83e\udde0 Explanation","text":"<ul> <li><code>AddressType</code> is keyless \u2192 it must not be the target of a declared relationship.</li> <li><code>PersonType</code> declares <code>HasAddress \u2192 AddressType</code></li> <li>JSON authors embed the keyless <code>Address</code> and populate its inverse relationship, <code>AddressOf \u2192 Person</code></li> <li>The loader internally flips it and populates <code>HasAddress(charles-eisenstein \u2192 [Address])</code></li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#declared-vs-inverse-relationships","title":"\ud83d\udd01 Declared vs. Inverse Relationships","text":"<p>When importing instance holons, each outbound <code>relationship</code> must ultimately correspond to a declared relationship \u2014 that is, a relationship defined as outbound from the holon\u2019s type.</p> <p>However, the MAP import format allows you to use either direction of a relationship pair when authoring instance data:</p> <ul> <li>A declared relationship, such as:   <pre><code>(Book)-[AUTHORED_BY]-&gt;(Person)\n</code></pre></li> <li>Its corresponding inverse relationship, such as:   <pre><code>(Person)-[AuthorOf]-&gt;(Book)\n</code></pre></li> </ul> <p>These two together form a relationship pair, where one is marked as the <code>InverseOf</code> the other in its relationship type definition.</p> <p>\ud83d\udd04 Even though only declared relationships are persisted, the loader will redirect inverse relationship usage to the appropriate declared relationship and populate it accordingly.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#authoring-either-direction","title":"\u2705 Authoring Either Direction","text":"<p>In your JSON import file, you may use either side:</p> <pre><code>{\n  \"name\": \"AUTHORED_BY\",\n  \"target\": { \"$ref\": \"person-789\" }\n}\n</code></pre> <p>or:</p> <pre><code>{\n  \"name\": \"AuthorOf\",\n  \"target\": { \"$ref\": \"book-123\" }\n}\n</code></pre> <p>Either form will result in the declared <code>AUTHORED_BY</code> relationship being populated.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#authoring-guidelines_1","title":"\u26a0\ufe0f Authoring Guidelines","text":"<ul> <li> <p>\u2705 Only populate one direction of a relationship pair.   Do not populate both <code>AUTHORED_BY</code> and <code>AuthorOf</code> \u2014 choose one or the other.</p> </li> <li> <p>\u26a0\ufe0f If one end of the relationship is a keyless holon (e.g., an inline annotation or constraint):</p> </li> <li>The keyless holon\u2019s type must declare the relationship.</li> <li>You must populate the inverse direction using an embedded target, not a <code>$ref</code>.</li> </ul> <p>\ud83e\udde0 Internally, only declared relationships are directly populated. The system automatically backfills the corresponding inverse relationships.</p> <p>A separate section provides guidance on defining declared and inverse relationship types, and how the <code>InverseOf</code> and <code>Inverse</code> links connect them.</p> <p>In MAP, every relationship pair is modeled as two named, uni-directional relationships:</p> <ul> <li>A declared relationship (e.g., <code>(Book)-[AuthoredBy]-&gt;(Person)</code>)</li> <li>Its corresponding inverse relationship (e.g., <code>(Person)-[AuthorOf]-&gt;(Book)</code>)</li> </ul> <p>Strictly speaking, only declared relationships are allowed to be directly populated in the system\u2019s internal storage model. Inverse relationships are automatically derived based on this. However, the JSON import format allows you to populate either direction for convenience.</p> <p>If a JSON import populates an inverse relationship, the Holon Data Loader will:</p> <ol> <li>Look up its <code>InverseOf</code> link to find the declared relationship type.</li> <li>Internally redirect the population to that declared relationship.</li> <li>Leave the inverse direction empty (it will be auto-derived later).</li> </ol> <p>This supports a more natural and readable JSON layout in many scenarios.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#example-using-inverse-in-json","title":"\u2705 Example: Using Inverse in JSON","text":"<p>You may populate the <code>Extends</code> relationship directly:</p> <pre><code>{\n  \"name\": \"Extends\",\n  \"target\": { \"$ref\": \"MetaTypeDescriptor\" }\n}\n</code></pre> <p>Or, equivalently, populate the inverse <code>ExtendedBy</code>:</p> <pre><code>{\n  \"name\": \"ExtendedBy\",\n  \"target\": {\n    \"type\": \"#MetaHolonType\",\n    \"properties\": {\n      \"type_name\": \"MetaHolonType\"\n    }\n  }\n}\n</code></pre> <p>Both will result in the same internal relationship being established \u2014 on the declared <code>Extends</code> direction.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#authoring-rules-and-caveats","title":"\u26a0\ufe0f Authoring Rules and Caveats","text":"<p>To ensure consistency and correctness, observe the following:</p> <ul> <li>\u2705 Only one direction of a relationship pair should be populated in your JSON file.</li> <li>\u2705 If you choose to use the inverse relationship in your JSON, ensure the inverse type includes an <code>InverseOf</code> link to its declared counterpart.</li> <li>\u26a0\ufe0f If either source or target holon type in the relationship is keyless:</li> <li>That keyless type must declare the relationship (i.e., be the source of the declared direction).</li> <li>The inverse direction must be populated inline, via embedded holons \u2014 since keyless holons cannot be referenced.</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#relationship-pairing-inverseof-and-inverse","title":"\ud83d\udd04 Relationship Pairing: <code>InverseOf</code> and <code>Inverse</code>","text":"<p>Each inverse relationship must include an <code>InverseOf</code> link to its declared counterpart:</p> <pre><code>{\n  \"name\": \"InverseOf\",\n  \"target\": { \"$ref\": \"#(RelationshipType)-[Extends]-&gt;(RelationshipType)\" }\n}\n</code></pre> <p>Once this is present, the system automatically adds the reverse link using <code>Inverse</code>:</p> <pre><code>{\n  \"name\": \"Inverse\",\n  \"target\": { \"$ref\": \"#(RelationshipType)-[ExtendedBy]-&gt;(RelationshipType)\" }\n}\n</code></pre> <p>You do not need to author <code>Inverse</code> links directly.</p> <p>==== OLDER STUFF</p> <p>The <code>relationships</code> field is a list of outbound links from the holon to other holons.</p> <p>Each entry must contain: - <code>name</code>: the name of the relationship - <code>target</code>: a single holon, a <code>$ref</code>, or an array of either</p> <p>You may use either of the following forms:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": { \"$ref\": \"FormatKeyRule:Book.KeyRule\" }\n}\n</code></pre> <p>or</p> <pre><code>{\n  \"name\": \"Components\",\n  \"target\": [\n    { \"$ref\": \"BookType\" },\n    { \"$ref\": \"PersonType\" }\n  ]\n}\n</code></pre> <p>\u2705 The loader automatically normalizes all <code>target</code> values to arrays. Even single references are treated as 1-element arrays internally.</p> <p>\u26a0\ufe0f Cardinality constraints are enforced using the type descriptor associated with the relationship name. For example, relationships like <code>DescribedBy</code> or <code>ComponentOf</code> often have <code>max_cardinality = 1</code>.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#embedded-schema-structure","title":"\ud83d\udcc2 Embedded Schema Structure","text":"<p>Schemas may embed their components directly via inverse relationships:</p> <pre><code>{\n  \"type\": \"#MapSchemaType\",\n  \"key\": \"MAP Core Schema\",\n  \"relationships\": [\n    {\n      \"name\": \"Components\",\n      \"target\": [ { \"holon\" }, { \"holon\" } ]\n    }\n  ]\n}\n</code></pre> <p>These will be rewritten by the loader into <code>ComponentOf</code> declarations from each child.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#defining-the-relationships-for-a-type","title":"Defining the Relationships for a Type:","text":""},{"location":"mapp-dev/holon-data-loader-guide/#declaring-vs-instantiating-relationships","title":"\ud83d\udd04 Declaring vs. Instantiating Relationships","text":"<p>In the MAP import format, it is essential to distinguish between two conceptually distinct usages of relationships:</p>"},{"location":"mapp-dev/holon-data-loader-guide/#1-declaring-allowed-relationships-for-a-type","title":"1. Declaring Allowed Relationships for a Type","text":"<p>When defining a type descriptor, we use the <code>InstanceRelationships</code> relationship to declare what kinds of relationships instances of this type may include. The targets of <code>InstanceRelationships</code> must be relationship types.</p> <p>Example:</p> <pre><code>{\n  \"name\": \"InstanceRelationships\",\n  \"target\": [\n    { \"$ref\": \"#(TypeDescriptor)-[ComponentOf]-&gt;(Schema)\" }\n  ]\n}\n</code></pre> <p>This states that instances of this type (e.g., <code>TypeDescriptor</code>) may include a <code>ComponentOf</code> relationship, and identifies the structural pattern expected for that relationship. The details of that relationship type (cardinality constraints, whether it is definitional, etc.) are defined in the referenced RelationshipType descriptor.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#2-instantiating-a-specific-relationship-for-a-holon","title":"2. Instantiating a Specific Relationship for a Holon","text":"<p>When authoring a specific holon, such as a type descriptor or instance, the <code>relationships</code> field is used to instantiate actual relationship instances. These entries must include:</p> <ul> <li>A <code>name</code>: the name of the relationship</li> <li>A <code>target</code>: the holon being linked to (typically via <code>$ref</code>)</li> </ul> <p>\u2705 Correct:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": { \"$ref\": \"#TypeName.KeyRule\" }\n}\n</code></pre> <p>\u274c Incorrect:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": {\n    \"type\": \"#Format.KeyRuleType\",\n    \"key\": \"TypeName.KeyRule\",\n    ...\n  }\n}\n</code></pre> <p>The incorrect version attempts to define the target inline \u2014 which may duplicate shared definitions and blur the separation of concerns between relationship declarations and relationship instances.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key-takeaway","title":"\ud83e\udded Key Takeaway","text":"<p>When declaring which relationships a type supports, point to relationship types. When instantiating a relationship in a holon, point to a target holon \u2014 typically via <code>$ref</code>.</p> <p>Following this rule ensures structural clarity, enables reuse, and keeps the MAP type system modular and DRY.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key-derivation-rules_2","title":"\ud83d\udd22 Key Derivation Rules","text":"<p>Every keyed holon must declare a <code>UsesKeyRule</code>, pointing to a <code>FormatKeyRule</code> with:</p> <ul> <li><code>format</code>: A string template (e.g., <code>\"$0\"</code>, <code>\"($0)-[$1]-&gt;($2)\"</code>)</li> <li><code>property_names</code>: List of property or inferred names used to fill the format</li> </ul> <p>The authored <code>key</code> must match the result of evaluating the format rule.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#best-practices_1","title":"\ud83d\udcda Best Practices","text":"<ul> <li>\u2705 Include <code>UsesKeyRule</code> for every keyed type descriptor</li> <li>\u2705 Use consistent naming across <code>type_name</code>, <code>display_name</code>, and <code>key</code></li> <li>\u2705 Use inline embedding for keyless holons or unique instances</li> <li>\u2705 Use <code>$ref</code> for reusable, keyed holons</li> <li>\u274c Do not author <code>DescribedBy</code> or <code>OwnedBy</code> \u2014 these are handled automatically</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#validation","title":"\ud83d\udd0e Validation","text":"Rule ID Title Description Severity json-schema Syntactic validation via JSON Schema The file must conform to the MAP JSON import format schema. error foundational-rule Foundational Rule for All Type Descriptors Every Type Descriptor must be <code>DescribedBy</code> <code>TypeDescriptor</code> and <code>Extend</code> (at most) exactly 1 Abstract Type. error unresolved-refs Unresolved References All $ref values must resolve to a keyed holon defined in the same or explicitly provided files. error only-declared-properties Only Declared Properties May Be Populated Holons must not specify properties not listed in InstanceProperties of their type. error only-declared-relationships Only Valid Relationships May Be Authored The import file may only author relationships that are either: (1) explicitly listed in the holon\u2019s type descriptor via InstanceRelationships, or (2) valid inverse relationships, which are resolved via InverseRelationshipType definitions that point back to a DeclaredRelationshipType where the holon\u2019s type is the TargetType. The system applies updates through the canonical declared direction. error <p>Files should be validated against:</p> <ol> <li><code>bootstrap-import.schema.json</code> \u2014 ensures structural correctness</li> <li>Schema-specific definitions \u2014 derived from the loaded Meta-Schema or Core Schema</li> </ol> <p>Holons are further validated at runtime by MAP\u2019s shared validators.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#ready-to-import","title":"\ud83c\udf89 Ready to Import","text":"<p>Once authored and validated, the file can be submitted to the Holon Data Loader.</p> <ul> <li>All <code>key</code> and <code>$ref</code> references will be resolved</li> <li>Relationships will be rewritten as needed</li> <li>Keyless holons will be embedded</li> <li>All imported holons will be linked to the HolonSpace via <code>OwnedBy</code></li> </ul> <p>For support, contact the MAP stewarding team or refer to the developer documentation.</p>"},{"location":"mapp-dev/holon-loader-man-page/","title":"HOLON-LOADER(1) \u2014 Manual Page","text":""},{"location":"mapp-dev/holon-loader-man-page/#name","title":"NAME","text":"<p>holon-loader \u2014 JSON Holon Loader for MAP / Conductora environments</p>"},{"location":"mapp-dev/holon-loader-man-page/#synopsis","title":"SYNOPSIS","text":"<p>holon-loader  [options]"},{"location":"mapp-dev/holon-loader-man-page/#description","title":"DESCRIPTION","text":"<p><code>holon-loader</code> parses, validates, resolves, and commits JSON Holons into a target HolonSpace using an embedded Conductora runtime.</p> <p>Input paths may be JSON files or directories. Directories are scanned recursively for <code>*.json</code>. Processing order is deterministic (lexicographic).</p> <p>Validation schema: The loader uses a built-in, fixed JSON Schema that matches the parser. Callers do not supply schema files.</p>"},{"location":"mapp-dev/holon-loader-man-page/#commands","title":"COMMANDS","text":"<p>load : Parse, validate, resolve, and commit holons into the target HolonSpace. Supports dry-run.</p> <p>validate : Parse and validate holons without committing. Produces a validation report.</p> <p>version : Print version and build information, including the loader\u2019s schema version.</p>"},{"location":"mapp-dev/holon-loader-man-page/#options","title":"OPTIONS","text":""},{"location":"mapp-dev/holon-loader-man-page/#general","title":"General","text":"<p><code>-v</code> : Increase verbosity. Repeatable (e.g. <code>-vvv</code>). Each additional <code>-v</code> raises the log level, capped at the maximum (debug).</p> <p><code>-q</code> : Quiet mode; only errors are printed. Overrides any <code>-v</code> flags.</p> <p><code>--format</code> text|json : Output format for results and reports. - <code>text</code> \u2014 human-readable summaries (default). - <code>json</code> \u2014 machine-readable structured output (for scripting and integration). Affects only output; inputs are always JSON files.</p>"},{"location":"mapp-dev/holon-loader-man-page/#target-holonspace","title":"Target HolonSpace","text":"<p>One of the following must be provided:</p> <p><code>--space-id</code> hash : Exact HolonSpace ID (ActionHash).</p> <p><code>--space-key</code> Type:Key : Resolve HolonSpace by type and key (e.g., <code>Space:PlanetProject.Core</code>).</p> <p><code>--create-space</code> name : Create a new HolonSpace with the given name if it does not exist.</p> <p><code>--space-config</code> path : Path to space.json describing the space to create. Current schema: <code>{ \"name\": \"&lt;string&gt;\", \"description\": \"&lt;string&gt;\" }</code>.</p> <p>Resolution precedence: 1. <code>--space-id</code> 2. <code>--space-key</code> 3. <code>--create-space</code> (with optional <code>--space-config</code>)    Else \u2192 error: \u201cNo HolonSpace specified.\u201d</p>"},{"location":"mapp-dev/holon-loader-man-page/#loader-behavior","title":"Loader Behavior","text":"<p><code>-n</code>, <code>--dry-run</code> : Do everything except commit.</p> <p><code>--deny-externals</code> : Forbid references to external spaces (default).</p> <p><code>--allow-externals</code> : Allow references to external spaces via proxy map.</p> <p><code>--proxy-map</code> path : Proxy map file used when <code>--allow-externals</code> is enabled.</p> <p><code>--fail-fast</code> : Abort on first validation error.</p> <p><code>--max-errors</code> n : Maximum number of errors to collect before aborting (default: 50).</p>"},{"location":"mapp-dev/holon-loader-man-page/#inputs","title":"INPUTS","text":"<ul> <li>One or more file or directory paths.</li> <li>Files: processed if they end with <code>.json</code>.</li> <li>Directories: scanned recursively for <code>*.json</code>.</li> <li>Non-JSON files are ignored.</li> <li>Mixed paths allowed; final list is the deterministic union.</li> </ul>"},{"location":"mapp-dev/holon-loader-man-page/#files","title":"FILES","text":"<p>*.json : Holon import files. Each file must contain one or more Holon definitions in the MAP JSON import format.</p> <p>space.json : Optional configuration file for <code>--space-config</code> when creating a HolonSpace. Currently supports only: - <code>name</code> (string) - <code>description</code> (string)</p> <p>(No external schema files are used; validation relies on the loader\u2019s fixed internal schema.)</p>"},{"location":"mapp-dev/holon-loader-man-page/#examples","title":"EXAMPLES","text":"<p>Validate all JSON files under <code>./imports</code>:</p> <pre><code>holon-loader validate ./imports --space-id id:uhCk123\u2026\n</code></pre> <p>Load with dry-run and verbose output:</p> <pre><code>holon-loader load ./set -n -vv \\\n  --space-key Space:PlanetProject.Core\n</code></pre> <p>Create a new space and load into it (space.json with name/description):</p> <pre><code>holon-loader load ./data \\\n  --create-space Catalist.Sandbox \\\n  --space-config ./space.json\n</code></pre> <p>Emit machine-readable JSON:</p> <pre><code>holon-loader validate ./imports --format json --space-id id:uhCk123\u2026\n</code></pre>"},{"location":"mapp-dev/holon-loader-man-page/#exit-status","title":"EXIT STATUS","text":"<p><code>0</code> \u2014 success <code>1</code> \u2014 validation error <code>2</code> \u2014 reference resolution error <code>3</code> \u2014 commit error <code>4</code> \u2014 configuration or environment error</p>"},{"location":"mapp-dev/holon-loader-man-page/#see-also","title":"SEE ALSO","text":"<p>holochain(1), hc(1), MAP documentation.</p>"},{"location":"mapp-dev/holon-loader-man-page/#notes","title":"NOTES","text":"<ul> <li>Input order is stable and deterministic.</li> <li>HolonSpace currently supports only <code>name</code> and <code>description</code>.</li> <li>When future HolonSpace policy is introduced, it will take precedence over CLI flags.</li> </ul>"},{"location":"mapp-dev/map-api/","title":"MAP API","text":"<p>This section describes the interface surface of the MAP from a client perspective.</p>"},{"location":"mapp-dev/map-security-model/","title":"MAP Security Model \u2014 Technical Specification (Modern Structure)","text":"<p>Version: 1.0 Status: Draft Audience: MAP Core Developers, Security Architects, Holochain Integration Engineers Last Updated: October 2025</p>"},{"location":"mapp-dev/map-security-model/#1-overview","title":"1. Overview","text":""},{"location":"mapp-dev/map-security-model/#11-purpose","title":"1.1 Purpose","text":"<p>This document specifies the security architecture and operational controls of the Memetic Activation Platform (MAP). It defines the trust foundations, threat mitigations, and adaptive enforcement mechanisms that ensure data sovereignty, agent integrity, and membrane-level trust across the platform.</p>"},{"location":"mapp-dev/map-security-model/#12-scope","title":"1.2 Scope","text":"<p>The specification applies to all MAP runtimes (client, host, and interspace) and covers: - Identity and key management - Authentication, authorization, and accountability - Membrane security and Trust Channels - Adaptive risk and behavioral enforcement - Space lensing and contextual visibility - Governance and data exfiltration controls - Operational resilience and resource protection</p>"},{"location":"mapp-dev/map-security-model/#13-guiding-principles","title":"1.3 Guiding Principles","text":"<ul> <li>Sovereignty by Design: Each Agent owns its identity, keys, and data.</li> <li>Defense in Depth: Security enforced at device, membrane, and agreement layers.</li> <li>Contextual Enforcement: Risk, sensitivity, and lens determine protection level.</li> <li>Zero Central Trust: No MAP component requires global or third-party trust.</li> <li>Transparency and Traceability: Every security decision is auditable and policy-driven.</li> </ul>"},{"location":"mapp-dev/map-security-model/#2-system-architecture","title":"2. System Architecture","text":""},{"location":"mapp-dev/map-security-model/#21-core-security-domains","title":"2.1 Core Security Domains","text":"Domain Description Enforcement Mechanism Agent Identity Cryptographically unique entities (one per device). Holochain keypairs managed by Lair keystore. Space Membranes Sovereign boundaries governing holon data and execution. Trust Channels and Agreement policies. Agreements Policy layer defining roles, protocols, and data rights. AuthZPolicy, CryptoPolicy, StepUpPolicy. Trust Channels Secure communication conduits between Spaces. Multi-envelope capsule architecture. Risk Layer Adaptive defense system analyzing behavioral and contextual data. RiskPolicy + StepUpPolicy enforcement. Lens Layer Contextual visibility management within Spaces. ActiveSpace + AsSelfEnvelope."},{"location":"mapp-dev/map-security-model/#22-layered-architecture-diagram","title":"2.2 Layered Architecture Diagram","text":"<pre><code>Device Layer  \u2192  Agent Layer  \u2192  Space Membrane Layer  \u2192  Agreement Layer\n      \u2195                  \u2195                        \u2195                       \u2195\nLocal Authentication   Key Custody          Trust Channel Validation   Policy &amp; Risk Control\n</code></pre>"},{"location":"mapp-dev/map-security-model/#3-identity-and-key-management","title":"3. Identity and Key Management","text":""},{"location":"mapp-dev/map-security-model/#31-agent-keys","title":"3.1 Agent Keys","text":"<p>Each device acts as an Agent with a unique cryptographic keypair: - Keys are stored in Lair Keystore (Holochain secure enclave). - Public keys are registered with relevant Agreements. - Keys never leave the device; signing and decryption happen in-process only.</p>"},{"location":"mapp-dev/map-security-model/#32-key-lifecycle","title":"3.2 Key Lifecycle","text":"Phase Action Enforcement Creation Device generates new keypair via Lair. Requires local OS unlock. Association Key registered to user\u2019s I-Space. Cryptographically signed claim. Revocation Compromised keys revoked by user or I-Space admin. Propagated via DHT gossip. Rotation New keypair replaces revoked key. Updates signed linkage chain."},{"location":"mapp-dev/map-security-model/#33-optional-key-splitting","title":"3.3 Optional Key Splitting","text":"<p>For critical data, MAP supports XOR or threshold-based key partitioning. Each fragment is stored across separate devices or vaults, requiring quorum reconstruction.</p>"},{"location":"mapp-dev/map-security-model/#4-authentication-and-authorization","title":"4. Authentication and Authorization","text":""},{"location":"mapp-dev/map-security-model/#41-authentication-sources","title":"4.1 Authentication Sources","text":"<ul> <li>Device Trust: Biometric/PIN unlocks the operating system.</li> <li>Agent Trust: Lair keystore confirms agent keypair control.</li> <li>Space Trust: Agreement-based verification within the Space membrane.</li> <li>Step-Up Trust: Secondary verification for sensitive Dances (SFS session).</li> </ul>"},{"location":"mapp-dev/map-security-model/#42-authorization-model","title":"4.2 Authorization Model","text":"<p>Authorization follows a role \u2192 scope \u2192 policy chain: 1. The active Agreement defines permissible roles. 2. Roles map to AuthZPolicy objects specifying allowed Dances and data scopes. 3. The Space membrane enforces these via the Trust Channel\u2019s AuthZEnvelope.</p>"},{"location":"mapp-dev/map-security-model/#43-permission-types","title":"4.3 Permission Types","text":"Permission Type Description Example Enforcement Read Retrieve data within allowed visibility scope. Lens filtering via ExfiltrationPolicy. Write Modify or propose changes to Space data. AuthZEnvelope validation. Execute Trigger a Dance or system action. DispatchEnvelope routing. Exfiltrate Send data beyond membrane. Outbound ExfiltrationEnvelope."},{"location":"mapp-dev/map-security-model/#5-trust-channels-and-membrane-security","title":"5. Trust Channels and Membrane Security","text":""},{"location":"mapp-dev/map-security-model/#51-purpose","title":"5.1 Purpose","text":"<p>Trust Channels provide the secure envelope architecture that protects all cross-Space Dances. Each message is encapsulated in a Dance Capsule comprising sequential validation layers: <code>Transport \u2192 AuthN \u2192 Crypto \u2192 AuthZ \u2192 Dispatch \u2192 Payload (\u2192 Exfiltration)</code></p>"},{"location":"mapp-dev/map-security-model/#52-enforcement-objectives","title":"5.2 Enforcement Objectives","text":"<ul> <li>Guarantee message authenticity and origin.</li> <li>Prevent unauthorized decryption or replay.</li> <li>Enforce Agreement policies cryptographically.</li> <li>Maintain auditability of all exchanges.</li> </ul>"},{"location":"mapp-dev/map-security-model/#53-key-functions","title":"5.3 Key Functions","text":"Envelope Function Validation Output Transport Routing, Agreement pinning, protocol negotiation. Confirmed target membrane. AuthN Verify sender\u2019s signature. Proven identity and integrity. Crypto Decrypt payload. Confidentiality enforced. AuthZ Check sender\u2019s role and permissions. Scoped authorization granted. Dispatch Deliver payload to local I-Space. Safe local execution. Exfiltration Filter outbound data. Controlled data exposure."},{"location":"mapp-dev/map-security-model/#54-protocol-negotiation","title":"5.4 Protocol Negotiation","text":"<p>When Spaces exchange data, they negotiate which ProtocolSuite to use: 1. Sender proposes a suite from the Agreement\u2019s <code>DancePolicyMap</code>. 2. Receiver validates or downshifts to a compatible suite. 3. The final choice is pinned in the capsule (<code>NegotiatedSuite</code>). 4. Both sides verify suite compatibility and envelope sequence integrity.</p>"},{"location":"mapp-dev/map-security-model/#6-risk-enforcement-framework","title":"6. Risk Enforcement Framework","text":""},{"location":"mapp-dev/map-security-model/#61-overview","title":"6.1 Overview","text":"<p>The Risk Enforcement Framework introduces adaptive, behavior-driven protection. It monitors usage patterns and dynamically enforces step-up authentication or throttling when contextual risk increases.</p>"},{"location":"mapp-dev/map-security-model/#62-core-components","title":"6.2 Core Components","text":"<p>RiskPolicy Holon <pre><code>RiskPolicy\n \u251c\u2500\u2500 ConsumesTelemetry \u2192 [RiskEventType...]\n \u251c\u2500\u2500 UsesStepUpPolicy \u2192 StepUpPolicy\n \u2514\u2500\u2500 MapsSensitivityToThresholds \u2192 [SensitivityThresholdMap...]\n</code></pre></p> <p>StepUpPolicy - Defines acceptable second-factor methods (biometric, PIN, hardware key). - Establishes TTL, idle timeout, and re-verification frequency.</p>"},{"location":"mapp-dev/map-security-model/#63-sensitivity-and-scoring","title":"6.3 Sensitivity and Scoring","text":"<p>Each DanceDescriptor defines a sensitivity tier: | Tier | Description | Typical Enforcement | |------|--------------|---------------------| | None | Low risk | No step-up required | | Elevated | Confidential | Require active SFS | | Critical | Governance or high value | Always require step-up |</p> <p>A Risk Engine aggregates telemetry (e.g., failed auth, anomalies, location shifts) into a dynamic risk score. If score \u2265 threshold or sensitivity = Critical \u2192 the capsule builder inserts an <code>UnlockEnvelope</code>.</p>"},{"location":"mapp-dev/map-security-model/#64-behavioral-monitoring","title":"6.4 Behavioral Monitoring","text":"<p>The Risk Engine collects and evaluates: - Frequency and velocity of actions. - Deviations from normal temporal patterns. - Device or network changes. - Recent revocations or policy breaches.</p> <p>Triggered responses: - Insert <code>UnlockEnvelope</code> before next Dance. - Suspend session or throttle request rate. - Emit <code>RiskPolicyViolation</code> for audit and governance action.</p>"},{"location":"mapp-dev/map-security-model/#65-developer-integration","title":"6.5 Developer Integration","text":"<ul> <li>Step-up enforcement occurs client-side (Tauri layer).</li> <li>Applications must query risk state and prompt user for confirmation if required.</li> <li>Telemetry events should be submitted for ongoing learning.</li> </ul>"},{"location":"mapp-dev/map-security-model/#7-space-lens-and-access-semantics","title":"7. Space Lens and Access Semantics","text":""},{"location":"mapp-dev/map-security-model/#71-concept","title":"7.1 Concept","text":"<p>MAP introduces Space lenses to define the contextual visibility of data. At any time, an Agent operates within one ActiveSpace that determines which holons they can see, modify, or invoke.</p>"},{"location":"mapp-dev/map-security-model/#72-activespace","title":"7.2 ActiveSpace","text":"<ul> <li>A single Space context is active per user session.</li> <li>Switching ActiveSpace updates the active Agreement set and available Trust Channels.</li> <li>Cached views and permissions are lens-bound\u2014switching lenses resets them.</li> </ul>"},{"location":"mapp-dev/map-security-model/#73-lens-filtering","title":"7.3 Lens Filtering","text":"<ul> <li>The membrane automatically filters holon visibility.</li> <li>External holons are visible only through Agreement-approved projections.</li> <li>ExfiltrationPolicy determines which properties or relationships can be seen.</li> <li>Filtered results are cached per proxy for low-latency reuse.</li> </ul>"},{"location":"mapp-dev/map-security-model/#74-acting-as-vs-accessing-through","title":"7.4 Acting As vs. Accessing Through","text":"Mode Description Trust Source Acting As Changing ActiveSpace, adopting that Space\u2019s governance role. New Space\u2019s Agreement. Accessing Through Remaining in I-Space but querying remote data. Cross-Space Agreement and outbound proxy."},{"location":"mapp-dev/map-security-model/#75-asselfenvelope","title":"7.5 AsSelfEnvelope","text":"<p>For scenarios where an agent temporarily acts as themselves while within another Space: <pre><code>AsSelfEnvelope\n \u251c\u2500\u2500 SubjectAgent \u2192 Agent\n \u251c\u2500\u2500 AuthenticatedIn \u2192 SourceSpace\n \u2514\u2500\u2500 VerifiedBy \u2192 Agreement\n</code></pre> This explicitly asserts the user\u2019s I-Space identity. Validation ensures only permitted personal data is accessible and filters are applied per Agreement.</p>"},{"location":"mapp-dev/map-security-model/#76-ux-and-developer-considerations","title":"7.6 UX and Developer Considerations","text":"<ul> <li>Interfaces must clearly show the current lens.</li> <li>Switching lenses must re-evaluate role, Agreement, and risk context.</li> <li>Caches should isolate per ActiveSpace to avoid privilege bleed-through.</li> </ul>"},{"location":"mapp-dev/map-security-model/#8-data-protection-and-exfiltration","title":"8. Data Protection and Exfiltration","text":""},{"location":"mapp-dev/map-security-model/#81-exfiltrationpolicy","title":"8.1 ExfiltrationPolicy","text":"<p>Controls outbound data leaving a Space: - Whitelists permitted fields and relationships. - Defines quantitative thresholds (record count, payload size). - Redacts or aggregates sensitive attributes.</p>"},{"location":"mapp-dev/map-security-model/#82-enforcement","title":"8.2 Enforcement","text":"<p>Implemented via the ExfiltrationEnvelope in the Trust Channel. Validated before encryption to ensure no sensitive data leaves the membrane.</p>"},{"location":"mapp-dev/map-security-model/#83-audit-and-provenance","title":"8.3 Audit and Provenance","text":"<p>All exfiltrations are logged as signed <code>ExfiltrationEvents</code>, storing: - Policy tag used - Payload digest - Destination Space and Agreement - Timestamp and responsible Agent ID</p>"},{"location":"mapp-dev/map-security-model/#9-operational-security-and-resilience","title":"9. Operational Security and Resilience","text":""},{"location":"mapp-dev/map-security-model/#91-immutable-state-model","title":"9.1 Immutable State Model","text":"<p>All persisted holons are immutable; updates create new versions. This eliminates state tampering and ensures full provenance.</p>"},{"location":"mapp-dev/map-security-model/#92-sustainer-role","title":"9.2 Sustainer Role","text":"<p>The Sustainer monitors device and Space resources (memory, compute, bandwidth). When thresholds approach limits, it can: - Prune caches. - Slow gossip replication. - Temporarily halt new inbound capsules.</p> <p>This makes resource sustainability a security function preventing denial-of-service conditions.</p>"},{"location":"mapp-dev/map-security-model/#93-audit-logging-and-observability","title":"9.3 Audit Logging and Observability","text":"<ul> <li>Every validation gate in the Trust Channel emits a signed audit event.</li> <li>Events are recorded in append-only DHT logs.</li> <li>Audit holons are queryable by Agreement participants for forensic review.</li> </ul>"},{"location":"mapp-dev/map-security-model/#10-threat-model","title":"10. Threat Model","text":"Threat Vector Primary Mitigation Secondary Mitigation Device Theft Lost or stolen device Revoke key, data encrypted at rest Step-up gating, key rotation Man-in-the-Middle Network interception Capsule encryption, signature validation Protocol negotiation ensuring suite compatibility Privilege Escalation Role misuse AuthZPolicy, lens filtering Step-up enforcement Data Leakage Improper exfiltration ExfiltrationPolicy &amp; Envelope Space lens boundaries Replay Attack Capsule reuse Nonces, timestamps, hash chains Agreement nonce validation Behavioral Compromise Account hijacking or automation Risk Engine monitoring Dynamic throttling Resource Exhaustion Memory/compute flood Sustainer thresholds Load shedding"},{"location":"mapp-dev/map-security-model/#11-compliance-and-auditability","title":"11. Compliance and Auditability","text":""},{"location":"mapp-dev/map-security-model/#111-policy-provenance","title":"11.1 Policy Provenance","text":"<p>All policies (AuthZ, Crypto, Exfiltration, Risk) are holons\u2014self-describing, versioned, and signed. This ensures every enforcement event can be traced back to a verifiable descriptor.</p>"},{"location":"mapp-dev/map-security-model/#112-audit-trails","title":"11.2 Audit Trails","text":"<ul> <li>Trust Channel emits ValidationEvents with timestamps, suite IDs, and results.</li> <li>Audit holons are queryable per Agreement.</li> <li>For privacy, sensitive payloads are hashed before storage.</li> </ul>"},{"location":"mapp-dev/map-security-model/#113-policy-amendments","title":"11.3 Policy Amendments","text":"<p>Changes to security policies require Agreement version increments. All previous versions remain immutable for historic verification.</p>"},{"location":"mapp-dev/map-security-model/#12-summary","title":"12. Summary","text":""},{"location":"mapp-dev/map-security-model/#121-key-properties","title":"12.1 Key Properties","text":"Principle Outcome Sovereignty by Design Agents control their keys, data, and Agreements. Defense in Depth Device, membrane, and agreement layers reinforce each other. Adaptive Security Step-up and risk scoring adjust authentication dynamically. Contextual Visibility Space lenses define what is visible or actionable. Auditability Every envelope validation and policy decision is recorded. Resilience Sustainer maintains secure operation under load."},{"location":"mapp-dev/map-security-model/#122-conclusion","title":"12.2 Conclusion","text":"<p>The MAP Security Model is a self-governing, adaptive security architecture where sovereignty, trust, and resilience are not bolted on but emerge from the system\u2019s holonic structure. By merging Trust Channels, contextual lenses, and behavioral risk intelligence, MAP creates a living trust fabric\u2014a network where all participants interact securely, transparently, and autonomously.</p>"},{"location":"mapp-dev/rust-api-developers-guide/","title":"MAP Rust-API Developer Guide","text":"<p>The reference layer is the boundary between your application code and the underlying holon store and services. It provides:</p> <ul> <li>Uniform handles (\u201creferences\u201d) to holons, regardless of whether they are transient, staged, or cached/saved.</li> <li>A small, consistent read/write API that hides internal manager and phase differences.</li> <li>High-level operations for staging, committing, and deleting.</li> <li>A curated prelude for ergonomic imports and a stable public API.</li> </ul> <p>This guide explains the API surface and shows how to perform the most common tasks.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#1-prelude","title":"1. Prelude","text":"<p>To simplify imports, use the MAP prelude:</p> <pre><code>use holons_prelude::prelude::*;\n</code></pre> <p>This brings into scope:</p> <ul> <li>Core value and identifier types (<code>BaseValue</code>, <code>MapString</code>, <code>HolonId</code>)</li> <li>Reference traits and types (<code>HolonReference</code>, <code>ReadableHolon</code>, <code>WritableHolon</code>, <code>TransientReference</code>, <code>StagedReference</code>, <code>SmartReference</code>)</li> <li>Context traits (<code>HolonsContextBehavior</code>)</li> <li>Common operations (<code>stage_new_holon_api</code>, <code>commit_api</code>, etc.)</li> <li>Type-name helpers (<code>CorePropertyTypeName</code>, <code>CoreRelationshipTypeName</code>, <code>ToPropertyName</code>, <code>ToRelationshipName</code>)</li> <li>Dance protocol builders (<code>holon_dance_builders::*</code>)</li> <li>Query types (<code>Node</code>, <code>NodeCollection</code>, <code>QueryExpression</code>)</li> </ul> <p>Use <code>holons_prelude::prelude::v1::*</code> if you need to pin to a stable prelude version.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#2-context-your-execution-environment","title":"2. Context: your execution environment","text":"<p>Every holon operation in MAP runs within a context that implements the <code>HolonsContextBehavior</code> trait. This context is the execution environment for all read, write, and commit actions\u2014it provides access to the active workspace where your holons live.</p> <p>As a developer, you don\u2019t create or manage the context yourself. Your mApp receives it from the runtime whenever you perform operations that touch holons. You simply pass it along to each API call that needs it.</p> <p>Example \u2014 staging and committing a holon:</p> <pre><code>fn create_and_commit(\n    context: &amp;dyn HolonsContextBehavior,\n) -&gt; Result&lt;(), HolonError&gt; {\n    // Create a new transient holon of a given type\n    let transient = create_empty_transient_holon(context, MapString(\"ExampleType\".into()));\n    transient.with_property_value(context, P::Key, \"example-1\".into())?;\n\n    // Stage it for persistence\n    let staged = stage_new_holon_api(context, transient)?;\n\n    // Commit all staged changes\n    let response = commit_api(context)?;\n    println!(\"Committed {} holons.\", response.commits_attempted);\n\n    Ok(())\n}\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#key-points-for-developers","title":"Key points for developers","text":"<ul> <li> <p>The context is always the first parameter to any read or write call.   It carries all the state needed to resolve references, access relationships, and enforce permissions.</p> </li> <li> <p>You can think of it as your \u201csession\u201d or \u201cworkspace.\u201d   Everything that happens during a transaction\u2014reads, writes, staging, commits\u2014occurs within this context.</p> </li> <li> <p>The context automatically routes requests to the right implementation based on the holon\u2019s phase (transient, staged, or saved).   You never need to know which storage or cache layer is involved.</p> </li> <li> <p>Contexts are lightweight and short-lived.   They are passed around as immutable references (<code>&amp;dyn HolonsContextBehavior</code>), so you can safely use them in async or concurrent flows.</p> </li> </ul> <p>In short: the context is your gateway to the MAP. You use it everywhere, but you don\u2019t manage or configure it\u2014just pass it through to the reference-layer API.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#3-reference-kinds","title":"3. Reference Kinds","text":"<p><code>HolonReference</code> is the umbrella type that can represent any phase:</p> <ul> <li><code>TransientReference</code> \u2014 in-memory, mutable, not persisted.</li> <li><code>StagedReference</code> \u2014 managed and ready to commit.</li> <li><code>SmartReference</code> \u2014 read-only, backed by a saved holon in cache or storage.</li> </ul> <p>All three implement the <code>ReadableHolon</code> trait; transient and staged also implement <code>WritableHolon</code>.</p> Type Backing store Read Write Commit <code>TransientReference</code> In-memory \u2705 \u2705 \u274c (must stage) <code>StagedReference</code> Staging area \u2705 \u2705 \u2705 <code>SmartReference</code> Saved/cache \u2705 \u274c \u274c"},{"location":"mapp-dev/rust-api-developers-guide/#4-collections","title":"4. Collections","text":"<p>A <code>HolonCollection</code> represents an ordered set of holon references.  Collections are most commonly returned when traversing relationships\u2014especially many-to-many or one-to-many links between holons. For example, a <code>Project</code> holon might have a <code>HasTask</code> relationship that returns a <code>HolonCollection</code> of <code>Task</code> holons.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#example-reading-related-holons","title":"Example: Reading related holons","text":"<pre><code>let tasks = project_ref.related_holons(context, R::HasTask.as_relationship_name())?;\nfor task_ref in tasks.iter() {\n    let title = task_ref.property_value(context, &amp;P::Title)?;\n    println!(\"Task: {:?}\", title);\n}\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#key-capabilities","title":"Key capabilities","text":""},{"location":"mapp-dev/rust-api-developers-guide/#1-access-and-iteration","title":"1. Access and iteration","text":"<p><code>HolonCollection</code> behaves like a lightweight, reference-aware vector:</p> <pre><code>let count = tasks.len();\nlet first = tasks.first();\nlet by_index = tasks.get(2);\nlet all = tasks.to_vec(); // Clones references into a Vec&lt;HolonReference&gt;\n</code></pre> <p>You can iterate directly:</p> <pre><code>for holon_ref in &amp;tasks {\n    println!(\"{:?}\", holon_ref.key(context)?);\n}\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#2-membership-and-lookup","title":"2. Membership and lookup","text":"<pre><code>if tasks.contains(&amp;some_ref) {\n    println!(\"Already linked!\");\n}\n</code></pre> <p>If the collection is keyed (e.g., by <code>MapString</code>), you can look up by key:</p> <pre><code>if let Some(found) = tasks.get_by_key(&amp;MapString(\"task-42\".into())) {\n    println!(\"Found task 42: {:?}\", found.key(context)?);\n}\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#3-mutation-transient-and-staged-only","title":"3. Mutation (transient and staged only)","text":"<p>Collections tied to writable holons can be updated via the <code>HolonCollectionApi</code> trait. These operations automatically update both the in-memory collection and the relationship map on the parent holon.</p> <pre><code>// Add a new related holon\ntasks.add(context, HolonReference::Transient(new_task_ref))?;\n\n// Remove an existing related holon\ntasks.remove(context, HolonReference::Smart(old_task_ref))?;\n</code></pre> <p>Behind the scenes, this uses the same logic as calling: <pre><code>parent_ref.add_related_holons(context, R::HasTask.as_relationship_name(), vec![child_ref])?;\n</code></pre></p>"},{"location":"mapp-dev/rust-api-developers-guide/#4-access-control-and-phase-safety","title":"4. Access control and phase safety","text":"<ul> <li>Read-only collections (from <code>SmartReference</code>) cannot be mutated.</li> <li>Transient and staged collections support add/remove operations.</li> <li>Attempting to mutate a read-only collection returns <code>HolonError::NotAccessible</code>.</li> </ul>"},{"location":"mapp-dev/rust-api-developers-guide/#5-use-cases","title":"5. Use cases","text":"<ul> <li>Navigation: traverse relationships, fetch related holons, inspect their properties.</li> <li>Editing: attach or detach related holons while editing staged or transient instances.</li> <li>Synchronization: check if a relationship set has changed before committing.</li> </ul>"},{"location":"mapp-dev/rust-api-developers-guide/#summary","title":"Summary","text":"Operation Available on Description <code>iter()</code> All Iterate through member references <code>len()</code> / <code>is_empty()</code> All Get collection size <code>get(index)</code> / <code>get_by_key()</code> All Access by position or key <code>add()</code> / <code>remove()</code> Transient, Staged Modify collection membership <code>contains()</code> All Check membership <code>to_vec()</code> All Convert to owned vector <p>In short: HolonCollection gives you a simple, phase-safe way to traverse and manipulate sets of related holons, just like a Rust <code>Vec</code>, but with built-in access control and automatic relationship synchronization.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#5-read-api-all-reference-types","title":"5. Read API (all reference types)","text":"<p>Every <code>HolonReference</code> implements <code>ReadableHolon</code>. That means the same read calls work on <code>TransientReference</code>, <code>StagedReference</code>, and <code>SmartReference</code> alike. Reads are phase-safe and route through the active <code>HolonsContextBehavior</code>.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#core-calls","title":"Core calls","text":"<pre><code>let key_opt      = reference.key(context)?;                               // Option&lt;MapString&gt;\nlet vkey         = reference.versioned_key(context)?;                     // Versioned key (type+key+rev/epoch)\nlet title_opt    = reference.property_value(context, &amp;P::Title)?;         // Option&lt;PropertyValue&gt;\nlet children     = reference.related_holons(context, R::HasChild.as_relationship_name())?; // HolonCollection\n</code></pre> <p>Other useful calls: - <code>all_related_holons(context)</code> \u2013 returns a map of all relationship names \u2192 <code>HolonCollection</code> - <code>holon_id(context)</code> \u2013 low-level persistent identifier (when applicable) - <code>predecessor(context)</code> \u2013 previous version (if any) - <code>essential_content(context)</code> \u2013 minimal content needed to reconstruct the holon - <code>into_model(context)</code> \u2013 materialize a snapshot model (e.g., for serialization or UI presentation)</p>"},{"location":"mapp-dev/rust-api-developers-guide/#ergonomic-usage-patterns","title":"Ergonomic usage patterns","text":""},{"location":"mapp-dev/rust-api-developers-guide/#1-keys-and-versioned-keys","title":"1) Keys and versioned keys","text":"<p>Use <code>key()</code> where present (some holons may be keyless) and fall back gracefully:</p> <pre><code>let label = reference\n    .key(context)?\n    .map(|k| format!(\"key: {}\", k.0))\n    .unwrap_or_else(|| \"keyless\".to_string());\n\nlet vkey = reference.versioned_key(context)?; // Stable for logs, audit, and idempotency\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#2-properties-with-defaults","title":"2) Properties with defaults","text":"<p><code>property_value</code> returns <code>Option&lt;PropertyValue&gt;</code>. Provide sensible defaults at the edge:</p> <pre><code>let title = reference\n    .property_value(context, &amp;P::Title)?\n    .and_then(|v| v.as_string())                // Convert if your ValueType is String-like\n    .unwrap_or_else(|| \"Untitled\".to_string());\n</code></pre> <p>Tip: keep type conversion at the edge (e.g., UI layer). Treat raw <code>PropertyValue</code> as data until you must render or compute.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#3-navigating-relationships","title":"3) Navigating relationships","text":"<p>Use relationship constants for clarity and refactor safety:</p> <pre><code>let children = reference.related_holons(context, R::HasChild.as_relationship_name())?;\nfor child in children.iter() {\n    let ck = child.key(context)?;\n    let ct = child.property_value(context, &amp;P::Title)?.and_then(|v| v.as_string());\n    println!(\"child {:?} titled {:?}\", ck, ct);\n}\n</code></pre> <p>Fetch all relationships when you need to render a full card/graph:</p> <pre><code>let relmap = reference.all_related_holons(context)?;\nfor (rel_name, collection) in relmap.iter() {\n    println!(\"{}: {} linked holons\", rel_name, collection.len());\n}\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#4-lineage-aware-reads","title":"4) Lineage-aware reads","text":"<p>When building edit screens for saved holons:</p> <pre><code>if let Some(prev) = reference.predecessor(context)? {\n    println!(\"has predecessor with key {:?}\", prev.key(context)?);\n}\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#5-snapshotting-for-uipersistence","title":"5) Snapshotting for UI/persistence","text":"<p>Prefer <code>into_model</code> for immutable snapshots passed to views or serialization:</p> <pre><code>let model = reference.into_model(context)?;\n// pass `model` to your presentation layer or serializer\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#applicability-access-rules","title":"Applicability (access rules)","text":"<ul> <li>Read is allowed on all phases: Transient \u2705, Staged \u2705, Smart \u2705.</li> <li>Access control is automatically enforced; if a read is not permitted you\u2019ll get an error (see below).</li> <li>The same method set works across phases, so you can write one code path for all references.</li> </ul> <p>You never need to detect the phase to read. Call the method; the context routes it correctly.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#error-behavior-you-should-expect-here","title":"Error behavior you should expect here","text":"<p>All reads return <code>Result&lt;_, HolonError&gt;</code>. Common cases for this section:</p> <ul> <li><code>HolonError::NotAccessible</code> \u2014 read not permitted for the current state of this holon</li> <li><code>HolonError::InvalidHolonReference</code> \u2014 reference cannot be resolved (e.g., missing, malformed, or out-of-scope).</li> <li><code>HolonError::InvalidType</code> / <code>HolonError::UnexpectedValueType</code> \u2014 property exists but the value type doesn\u2019t match your expectation.</li> <li><code>HolonError::EmptyField</code> \u2014 property required by your logic is unset.</li> </ul> <p>The guide\u2019s Error Handling section enumerates all variants and recommended remedies. In read paths, prefer graceful fallbacks and edge validation (e.g., default titles, optional render elements).</p>"},{"location":"mapp-dev/rust-api-developers-guide/#practical-examples","title":"Practical examples","text":"<p>Read a title with a default and render children count <pre><code>fn render_card(\n    context: &amp;dyn HolonsContextBehavior,\n    item: &amp;HolonReference,\n) -&gt; Result&lt;(), HolonError&gt; {\n    let title = item.property_value(context, &amp;P::Title)?\n        .and_then(|v| v.as_string())\n        .unwrap_or_else(|| \"Untitled\".to_string());\n\n    let kids = item.related_holons(context, R::HasChild.as_relationship_name())?;\n    println!(\"{} ({} items)\", title, kids.len());\n    Ok(())\n}\n</code></pre></p> <p>Collect all related holons for a relationship-aware widget <pre><code>fn gather_relationships(\n    context: &amp;dyn HolonsContextBehavior,\n    item: &amp;HolonReference,\n) -&gt; Result&lt;Vec&lt;(RelationshipName, Vec&lt;HolonReference&gt;)&gt;, HolonError&gt; {\n    let mut out = Vec::new();\n    for (rel_name, coll) in item.all_related_holons(context)? {\n        out.push((rel_name.clone(), coll.to_vec()));\n    }\n    Ok(out)\n}\n</code></pre></p>"},{"location":"mapp-dev/rust-api-developers-guide/#summary-table","title":"Summary table","text":"Method Returns Notes <code>key(context)</code> <code>Result&lt;Option&lt;MapString&gt;, HolonError&gt;</code> Keyless holons return <code>None</code>. <code>versioned_key(context)</code> <code>Result&lt;VersionedKey, HolonError&gt;</code> Stable identifier for logs/audits. <code>property_value(context, &amp;P::X)</code> <code>Result&lt;Option&lt;PropertyValue&gt;, HolonError&gt;</code> Convert at the edge (<code>as_string()</code>, etc.). <code>related_holons(context, R::X)</code> <code>Result&lt;HolonCollection, HolonError&gt;</code> Ordered, phase-safe collection. <code>all_related_holons(context)</code> <code>Result&lt;BTreeMap&lt;RelationshipName, HolonCollection&gt;, HolonError&gt;</code> Full relationship map. <code>holon_id(context)</code> <code>Result&lt;HolonId, HolonError&gt;</code> May be unavailable for purely transient holons. <code>predecessor(context)</code> <code>Result&lt;Option&lt;HolonReference&gt;, HolonError&gt;</code> Present on versioned/saved lineages. <code>essential_content(context)</code> <code>Result&lt;EssentialHolonContent, HolonError&gt;</code> Minimal reconstruction payload. <code>into_model(context)</code> <code>Result&lt;HolonNodeModel, HolonError&gt;</code> Immutable snapshot for UI/serialization. <p>Takeaways - One trait, all phases: write once, read anywhere. - Treat properties as optional until rendered; fail soft at the edge. - Use relationship constants for clarity and stability.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#6-write-api-transientstaged-only","title":"6. Write API (transient/staged only)","text":"<p>Available via <code>WritableHolon</code>:</p> <pre><code>reference.with_property_value(context, P::Title, \"Hello\".into())?;\nreference.remove_property_value(context, P::Obsolete)?;\nreference.add_related_holons(context, R::HasChild.as_relationship_name(), vec![child_ref])?;\nreference.remove_related_holons(context, R::HasChild.as_relationship_name(), vec![child_ref])?;\nreference.with_descriptor(context, descriptor_ref)?;\nreference.with_predecessor(context, Some(prev_ref))?;\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#7-staging-and-commit","title":"7. Staging and Commit","text":"<p>High-level helpers in <code>holon_operations_api</code>:</p> <ul> <li>Stage a new holon <pre><code>let staged = stage_new_holon_api(context, transient)?;\n</code></pre></li> <li>Stage a new version of a saved holon   <pre><code>let staged = stage_new_version(context, smart_ref)?;\n</code></pre></li> <li>Commit all staged changes <pre><code>let commit_response = commit_api(context)?;\n</code></pre></li> </ul> <p><code>CommitResponse</code> includes: * <code>saved_holons</code> * <code>abandoned_holons</code> * <code>commits_attempted</code></p> <p><code>(saved + abandoned == attempted)</code> indicates completion.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#8-cloning-holons","title":"8. Cloning holons","text":"<p>MAP offers three public clone operations, depending on your intent.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#a-readableholonclone_holon-transientreference","title":"A. <code>ReadableHolon::clone_holon</code> \u2192 <code>TransientReference</code>","text":"<pre><code>fn clone_holon(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n) -&gt; Result&lt;TransientReference, HolonError&gt;\n</code></pre> <p>Any holon\u2014saved, staged, or transient\u2014can be cloned. The result is always a new transient holon, detached from lineage or staging metadata but preserving its property and relationship data.</p> <p>Use this for creating a scratch copy:</p> <pre><code>let transient_clone = any_reference.clone_holon(context)?;\ntransient_clone.with_property_value(context, P::Title, \"Draft copy\".into())?;\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#b-stage_new_version-stagedreference","title":"B. <code>stage_new_version</code> \u2192 <code>StagedReference</code>","text":"<pre><code>fn stage_new_version(\n    context: &amp;dyn HolonsContextBehavior,\n    current_version: SmartReference,\n) -&gt; Result&lt;StagedReference, HolonError&gt;\n</code></pre> <p>Creates a new staged holon as an update to an existing saved holon, retaining lineage through the <code>Predecessor</code> relationship.</p> <pre><code>let staged = stage_new_version(context, saved_ref)?;\nstaged.with_property_value(context, P::Status, \"Revised\".into())?;\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#c-stage_new_from_clone-stagedreference","title":"C. <code>stage_new_from_clone</code> \u2192 <code>StagedReference</code>","text":"<pre><code>fn stage_new_from_clone(\n    context: &amp;dyn HolonsContextBehavior,\n    original_holon: HolonReference,\n    new_key: MapString,\n) -&gt; Result&lt;StagedReference, HolonError&gt;\n</code></pre> <p>Creates a new staged holon from any existing one, without lineage. Ideal for templates or derivatives.</p> <pre><code>let staged_clone = stage_new_from_clone(context, original_ref, MapString(\"copy-123\".into()))?;\n</code></pre> Operation Input Output Lineage Typical use <code>clone_holon</code> Any <code>TransientReference</code> \u274c Scratch copy <code>stage_new_version</code> <code>SmartReference</code> <code>StagedReference</code> \u2705 Update existing <code>stage_new_from_clone</code> Any <code>StagedReference</code> \u274c Derive new holon"},{"location":"mapp-dev/rust-api-developers-guide/#9-typical-flows","title":"9. Typical Flows","text":""},{"location":"mapp-dev/rust-api-developers-guide/#create-stage-commit","title":"Create \u2192 stage \u2192 commit","text":"<pre><code>let t = create_empty_transient_holon(context, MapString(\"MyType\".into()));\nt.with_property_value(context, P::Key, \"example-1\".into())?;\nlet staged = stage_new_holon_api(context, t)?;\nlet resp = commit_api(context)?;\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#fetch-saved-holon-stage-new-version","title":"Fetch saved holon \u2192 stage new version","text":"<pre><code>let smart = HolonReference::from_id(saved_id);\nlet staged = stage_new_version(context, smart)?;\nstaged.with_property_value(context, P::Title, \"updated\".into())?;\nlet resp = commit_api(context)?;\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#derive-new-staged-holon-from-existing","title":"Derive new staged holon from existing","text":"<pre><code>let staged_clone = stage_new_from_clone(context, existing_ref, MapString(\"copy-2\".into()))?;\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#10-relationships","title":"10. Relationships","text":"<ul> <li> <p>Read:   Smart holons fetch from cache (with fetch-on-miss).   Staged and transient holons use local relationship maps.</p> </li> <li> <p>Write:   Only staged or transient references can modify relationships.   Use <code>add_related_holons</code>, <code>remove_related_holons</code>, or <code>with_descriptor</code>.</p> </li> </ul>"},{"location":"mapp-dev/rust-api-developers-guide/#11-query-layer","title":"11. Query Layer","text":"<p><code>Node</code>, <code>NodeCollection</code>, and <code>QueryExpression</code> express queries over holons.</p> <pre><code>let expr = QueryExpression::property_equals(P::Title, \"Hello\".into());\nlet nodes: NodeCollection = run_query(context, expr)?;\nfor node in nodes {\n    println!(\"Found: {:?}\", node.key(context)?);\n}\n</code></pre> <p>Note: The query API is evolving. Current support includes basic property and relationship predicates.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#12-dance-builders","title":"12. Dance Builders","text":"<p><code>holon_dance_builders::*</code> provides ergonomic constructors for standard Dances:</p> <pre><code>let request = build_commit_dance_request(staged_refs);\nlet response: DanceResponse = send_dance(context, request)?;\nif response.status_code == ResponseStatusCode::Ok {\n    println!(\"Commit succeeded!\");\n}\n</code></pre> <p>Builders are the preferred way to trigger standardized Dances that cross the membrane boundary.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#13-access-control","title":"13. Access Control","text":"<p>All reference operations are validated against an <code>AccessType</code>:</p> AccessType Transient Staged Smart Read \u2705 \u2705 \u2705 Write \u2705 \u2705 \u274c Clone \u2705 \u2705 \u2705 Commit \u274c \u2705 \u274c Abandon \u2705 \u2705 \u274c <p>Unauthorized actions raise <code>HolonError::NotAccessible</code>.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#14-error-handling","title":"14. Error Handling","text":"<p>All functions return <code>Result&lt;_, HolonError&gt;</code>. Common variants include:</p> <ul> <li><code>NotAccessible</code> \u2013 operation not permitted in this phase</li> <li><code>InvalidHolonReference</code> \u2013 bad or missing reference</li> <li><code>InvalidType</code>, <code>UnexpectedValueType</code>, <code>EmptyField</code> \u2013 schema or data errors</li> </ul> <p>Errors returned through Dances can also be mapped to <code>ResponseStatusCode</code>.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#15-style-conventions","title":"15. Style &amp; Conventions","text":"<ul> <li>Use explicit suffixes (<code>*_reference</code>) for reference variables.</li> <li>When APIs expect <code>Vec&lt;HolonReference&gt;</code>, wrap explicitly:</li> </ul> <pre><code>HolonReference::Transient(transient_reference)\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#16-where-to-look","title":"16. Where to Look","text":"<ul> <li>Prelude: <code>holons_prelude::prelude</code></li> <li>Context behavior: <code>reference_layer/context_behavior.rs</code></li> <li>Operations API: <code>reference_layer/holon_operations_api.rs</code></li> <li>Reference traits and types: <code>reference_layer/holon_reference.rs</code>, <code>readable_holon.rs</code>, <code>writable_holon.rs</code>, <code>staged_reference.rs</code>, <code>transient_reference.rs</code></li> <li>Access and state: <code>core_shared_objects/holon/state.rs</code></li> <li>Dance builders: <code>holon_dance_builders</code></li> <li>Query layer: <code>reference_layer/query_api.rs</code></li> </ul>"},{"location":"mapp-dev/rust-api-developers-guide/#17-evolving-areas","title":"17. Evolving Areas","text":"<ul> <li>Validation runs primarily at commit.</li> <li>Fluent chaining (<code>&amp;Self</code>) is being standardized in setters.</li> <li>The query API will expand to richer predicates.</li> <li>Additional Dances (Loader, Validation) will reuse the same reference layer interface.</li> </ul>"},{"location":"mapp-dev/tags_to_memes/","title":"\ud83e\udde0 From Tags to Memes: A Deep Reframing of Tagging in the Memetic Activation Platform (MAP)","text":""},{"location":"mapp-dev/tags_to_memes/#abstract","title":"Abstract","text":"<p>Tagging has long been used to annotate, organize, and discover content in digital environments. Most systems treat tags as flat strings \u2014 simple labels applied to objects \u2014 with minimal structure or semantic depth. The Memetic Activation Platform (MAP) introduces a new model that reimagines tagging as a memetic act, embedded in a rich and evolving semantic graph.</p> <p>In MAP, a tag is a Meme in role \u2014 an object-based conceptual unit participating in a <code>CLASSIFIES</code> relationship. Tags are not a special type, but an expression of memetic function. This shift enables tags to evolve from lightweight associations into richly connected nodes of meaning \u2014 or, in some cases, be reinterpreted as references to non-memetic Holons such as books, people, or organizations.</p> <p>This document situates MAP\u2019s approach within the broader landscape of tagging systems \u2014 from folksonomies and controlled vocabularies to semantic web ontologies \u2014 and highlights how it advances the state of the art.</p>"},{"location":"mapp-dev/tags_to_memes/#1-introduction","title":"1. Introduction","text":"<p>In platforms from Flickr to Twitter to Notion, tagging plays a key role in organizing content. Yet most implementations suffer from common limitations:</p> <ul> <li>Tags are strings, not concepts.</li> <li>No distinction between roles (e.g., topic vs. person vs. action).</li> <li>Little to no governance or semantic disambiguation.</li> <li>Limited pathways for tag evolution or refinement.</li> </ul> <p>MAP addresses these issues by grounding tags in its core memetic ontology. Every tag is a Meme \u2014 a semantic entity \u2014 and tagging is a type of relationship that can be upgraded, refined, or superseded over time.</p>"},{"location":"mapp-dev/tags_to_memes/#2-key-principle-tagging-is-a-role-not-a-type","title":"2. Key Principle: Tagging Is a Role, Not a Type","text":"<p>In MAP:</p> <ul> <li>Any Meme can act as a tag by participating in a <code>CLASSIFIES \u2192 Holon</code> relationship.</li> <li>There is no special \u201cTag\u201d type \u2014 tagging is a function of relationship semantics.</li> </ul> <p>This means:</p> <ul> <li>Tags retain the full expressive power of Memes.</li> <li>The same Meme can classify many Holons, appear in MemeGroups, or evolve into a richly defined concept.</li> </ul> <p>\u201c#capitalism\u201d isn\u2019t a just label \u2014 it\u2019s a Meme that classifies many Holons, relates to other Memes, and can carry definitions, translations, and curated context.</p>"},{"location":"mapp-dev/tags_to_memes/#3-two-evolutionary-paths-for-tags","title":"3. Two Evolutionary Paths for Tags","text":"<p>MAP uniquely recognizes that tags do not all evolve in the same way. Two primary evolutionary pathways exist:</p>"},{"location":"mapp-dev/tags_to_memes/#a-referent-disambiguation","title":"A. Referent Disambiguation","text":"<p>Some tags are initially applied to a Holon as a rough association \u2014 but later turn out to refer to a non-memetic entity.</p> <p>Example:</p> <p><code>#emerging-world</code> is used as a tag, but we later discover it refers to a Book called Emerging World. The proper model is to create a <code>Holon(Book)</code> and connect Roger Briggs to it via <code>AUTHOR_OF</code>.</p> <p>The original tag is now either:</p> <ul> <li>Superseded (no longer needed), or</li> <li>Retained for thematic linkage (e.g., <code>#emerging-world</code> still classifies the Book or Author loosely)</li> </ul> <p>This flow highlights MAP\u2019s ability to distinguish:</p> <ul> <li>Concepts (Memes) from</li> <li>Artifacts, Agents, or Works (Vital Capital, Projects, etc.)</li> </ul>"},{"location":"mapp-dev/tags_to_memes/#b-semantic-deepening","title":"B. Semantic Deepening","text":"<p>Other tags are Memes from the start \u2014 and grow in semantic richness over time.</p> <p>Example:</p> <p><code>#capitalism</code> starts as a tag. It then gains:</p> <ul> <li>A <code>DEFINED_BY</code> link</li> <li>Related Memes (e.g., <code>#socialism</code>, <code>#market-economy</code>)</li> <li>Multilingual equivalents</li> <li>Inclusion in curated groups (e.g., \"Economic Ideologies\")</li> </ul> <p>The tag doesn\u2019t refer to something else \u2014 it is the thing, and it matures into a high-gravity node in the memetic graph.</p>"},{"location":"mapp-dev/tags_to_memes/#4-comparison-with-existing-tagging-paradigms","title":"4. Comparison with Existing Tagging Paradigms","text":"Paradigm Characteristics MAP Distinctions Folksonomy (Web 2.0) Tags are freeform strings; no semantics; bottom-up MAP supports folksonomic tagging but uses object-based Memes and typed relationships Controlled Vocabularies Curated taxonomies; predefined terms; rigid MAP allows emergent structure, but supports curation and governance over time Semantic Web Tags as URIs; typed relationships; machine-readable MAP aligns with RDF-style models but prioritizes human-centered conceptual meaning Discourse-based models Tags reflect user sensemaking; meaning is emergent MAP embraces this, while providing infrastructure for long-term semantic enrichment"},{"location":"mapp-dev/tags_to_memes/#5-implementation-highlights","title":"5. Implementation Highlights","text":""},{"location":"mapp-dev/tags_to_memes/#51-tags-as-first-class-objects","title":"5.1 Tags as First-Class Objects","text":"<ul> <li>Every tag is a <code>Meme</code>, with a unique identifier and optional metadata.</li> <li>Memes can be defined, related, grouped, translated, and governed.</li> </ul>"},{"location":"mapp-dev/tags_to_memes/#52-tag-application-as-an-event","title":"5.2 Tag Application as an Event","text":"<p>Tagging can be represented as a <code>TagApplication</code> or <code>TagAssertion</code>, which may include:</p> <ul> <li>Who applied it</li> <li>When and where</li> <li>Why or in what context</li> <li>Whether it was later superseded by a stronger relationship</li> </ul>"},{"location":"mapp-dev/tags_to_memes/#53-multi-layered-meaning","title":"5.3 Multi-layered Meaning","text":"<p>A single Meme can:</p> <ul> <li>Function as a tag (<code>CLASSIFIES</code>)</li> <li>Be defined (<code>DEFINED_BY</code>)</li> <li>Be related (<code>RELATED_TO</code>, <code>CONTRASTS_WITH</code>)</li> <li>Exist in curated <code>MemeGroups</code> or <code>TagSets</code></li> <li>Be governed in <code>StewardedMemePools</code></li> </ul>"},{"location":"mapp-dev/tags_to_memes/#54-ui-and-ux-opportunities","title":"5.4 UI and UX Opportunities","text":"<ul> <li>Show semantic weight of tags (e.g., enriched vs. raw)</li> <li>Suggest upgrades (\u201cWould you like to mark this person as author of that book?\u201d)</li> <li>Offer tag disambiguation when multiple referents are likely</li> </ul>"},{"location":"mapp-dev/tags_to_memes/#6-why-this-matters","title":"6. Why This Matters","text":"<p>MAP\u2019s approach addresses long-standing challenges in tagging systems:</p> Challenge MAP's Answer Tags lack meaning Tags are Memes: semantically enrichable objects Tags are misapplied Disambiguation allows for correction and clarification Tags can't evolve Tags can deepen into structured, governed knowledge units Tagging is chaotic/brittle MAP supports emergent order and structured refinement <p>This model enables semantic infrastructure that can grow organically, integrating the best of folksonomy, controlled vocabularies, and ontology-based knowledge systems.</p>"},{"location":"mapp-dev/tags_to_memes/#7-conclusion","title":"7. Conclusion","text":"<p>MAP reframes tagging as a memetic function, not a flat annotation. By treating tags as Memes-in-role and allowing them to evolve \u2014 either toward deeper meaning or clearer referents \u2014 MAP bridges the gap between human conceptual creativity and formal semantic integrity.</p> <p>It doesn't just let people tag things \u2014 it lets meaning itself grow.</p>"},{"location":"mapp-dev/tags_to_memes/#8-future-directions","title":"8. Future Directions","text":"<ul> <li>Development of <code>TagApplication</code> schema</li> <li>Semantic weight scoring models</li> <li>UI/UX patterns for tag promotion and disambiguation</li> <li>Stewardship workflows for meme governance</li> <li>Alignment with broader memetic knowledge commons initiatives</li> </ul>"},{"location":"mapp-dev/trust-channel/","title":"\ud83e\ude70 We-Space Trust Channels in Action","text":""},{"location":"mapp-dev/trust-channel/#how-map-enforces-sovereignty-privacy-and-agreement-integrity","title":"How MAP Enforces Sovereignty, Privacy, and Agreement Integrity","text":"<p>This document uses the life-cycle of a DanceRequest to illustrate a deeper story: how the We-Space application layer and Trust Channel services in MAP protect data sovereignty and enforce agreements in a fully decentralized architecture.</p>"},{"location":"mapp-dev/trust-channel/#why-this-matters","title":"\ud83c\udfaf Why This Matters","text":"<p>The primary goals of the We-Space and its Trust Channels are:</p> <ol> <li> <p>Sovereignty and Privacy Without Central Servers    MAP Agents never need to trust a central authority with their data. All routing, validation, and exchange happens peer-to-peer, with no central custody of private information.</p> </li> <li> <p>Infrastructure-Level Security and Governance Enforcement    Authentication, authorization, cryptographic security, and privacy enforcement are built into MAP\u2019s infrastructure layer. This means application developers:</p> </li> <li>Don\u2019t have to implement security protocols themselves</li> <li>Can rely on consistent adherence to the signed promises in Agreements</li> <li>Work with validated, decrypted, role-checked requests \u2014 already safe to act upon</li> </ol> <p>By handling these steps before a request reaches an application\u2019s logic, the MAP ensures consistency, trust, and interoperability across the entire ecosystem.</p>"},{"location":"mapp-dev/trust-channel/#inbound-flow-envelopes-and-membrane-functions","title":"\ud83d\udce5 Inbound Flow: Envelopes and Membrane Functions","text":"<p>Every inbound DanceRequest travels through the We-Space membrane in a layered sequence of envelopes. Each envelope contains the information needed for the membrane function at that stage. The envelopes do not \u201cdo\u201d the work themselves \u2014 the Trust Channel functions act on the envelope\u2019s contents.</p>"},{"location":"mapp-dev/trust-channel/#1-transport-envelope-routing-function","title":"1. Transport Envelope \u2192 Routing Function","text":"<p>Envelope contains:</p> <ul> <li><code>agreement_id</code> \u2014 identifies governing Agreement</li> <li><code>sender_id</code> \u2014 request originator</li> <li><code>recipient_id</code> \u2014 intended receiver</li> <li><code>message_type = DanceRequest</code></li> </ul> <p>Function performed: </p> <p>The We-Space messaging infrastructure reads this metadata to select the allowed protocol (per Agreement) and route the message to the recipient\u2019s membrane \u2014 without exposing any payload contents.</p>"},{"location":"mapp-dev/trust-channel/#2-authentication-envelope-identity-verification-function","title":"2. Authentication Envelope \u2192 Identity Verification Function","text":"<p>Envelope contains:</p> <ul> <li>Cryptographic signature over the hash of the encrypted payload</li> </ul> <p>Function performed:</p> <p>The Trust Channel fetches the sender\u2019s public key from the Agreement and verifies: - The signature matches the payload hash - The sender is an authorized Agreement participant</p> <p>This step proves authenticity before any decryption occurs.</p>"},{"location":"mapp-dev/trust-channel/#3-encryption-envelope-confidentiality-function","title":"3. Encryption Envelope \u2192 Confidentiality Function","text":"<p>Envelope contains: - Payload encrypted with the recipient\u2019s public key</p> <p>Function performed:</p> <p>The recipient\u2019s membrane decrypts the payload with its private key.  This ensures that even though transport and routing may cross multiple peers, only the final recipient can read the request.</p>"},{"location":"mapp-dev/trust-channel/#4-authorization-envelope-permission-check-function","title":"4. Authorization Envelope \u2192 Permission Check Function","text":"<p>Envelope contains: - Full <code>DanceRequest</code> - Target <code>Dance</code> - Agent roles - Parameters, thresholds, and timing</p> <p>Function performed: Agreement rules are applied to ensure: - The requester\u2019s role is permitted to invoke this Dance - The role pairing is valid under the Agreement - All scope and timing conditions are met</p>"},{"location":"mapp-dev/trust-channel/#5-execution-context-dispatch-function","title":"5. Execution Context \u2192 Dispatch Function","text":"<p>Function performed: Once validated, the We-Space hands the request to the recipient\u2019s I-Space. Here, the MAP Choreographer invokes the Dance. If part of a DanceFlow, subsequent steps are dispatched automatically.</p>"},{"location":"mapp-dev/trust-channel/#outbound-flow-layering-the-response","title":"\ud83d\udce4 Outbound Flow: Layering the Response","text":"<p>Outbound processing mirrors inbound, ensuring the response leaves the membrane as securely and intentionally as the request entered.</p>"},{"location":"mapp-dev/trust-channel/#1-payload-creation-function","title":"1. Payload \u2192 Creation Function","text":"<p>The application logic in the I-Space generates the raw <code>DanceResponse</code>.</p>"},{"location":"mapp-dev/trust-channel/#2-exfiltration-envelope-outbound-authorization-function","title":"2. Exfiltration Envelope \u2192 Outbound Authorization Function","text":"<p>Function performed: Filters response content against Agreement terms, type-level access policies, and trust thresholds before anything leaves the membrane.</p>"},{"location":"mapp-dev/trust-channel/#3-encryption-envelope-confidentiality-function_1","title":"3. Encryption Envelope \u2192 Confidentiality Function","text":"<p>Response is encrypted with the requester\u2019s public key so only they can read it.</p>"},{"location":"mapp-dev/trust-channel/#4-authentication-envelope-integrity-verification-function","title":"4. Authentication Envelope \u2192 Integrity Verification Function","text":"<p>Encrypted response is signed with the responder\u2019s private key to prove origin and integrity.</p>"},{"location":"mapp-dev/trust-channel/#5-transport-envelope-routing-function","title":"5. Transport Envelope \u2192 Routing Function","text":"<p>Routing metadata is wrapped around the response and the Trust Channel selects the allowed protocol for delivery.</p>"},{"location":"mapp-dev/trust-channel/#why-this-is-a-big-deal-for-developers","title":"\ud83e\udde0 Why This is a Big Deal for Developers","text":"<p>Because the We-Space application services and Trust Channel stack do all of this before a request reaches app logic, developers can: - Assume incoming requests are authentic, authorized, and within scope - Skip building custom cryptographic or trust enforcement layers - Focus entirely on the business logic of the Dance itself</p> <p>At the same time, the MAP ensures uniform adherence to Agreements, so every response is also vetted, encrypted, and signed before leaving the agent\u2019s control.</p> <p>In short: The We-Space and Trust Channels are sovereignty-preserving service layers. They are the reason MAP can operate fully decentralized without central servers \u2014 and why MAP apps can remain secure, interoperable, and trust-aligned by default.</p>"},{"location":"shared/glossary/","title":"\ud83e\uddfe Glossary","text":"<p>This glossary defines key concepts and terms used throughout the MAP architecture and narrative framework. Terms are listed alphabetically. Multiple definitions are included where distinctions emerged between narrative threads.</p>"},{"location":"shared/glossary/#agent","title":"Agent","text":"<p>An Agent is any entity capable of sensing and responding to its environment. It may be biological (e.g., a person, whale, or tree), technical (e.g., a computing process), or social (e.g., a family, cooperative, or commons).</p> <ul> <li>Every Agent has a unique identity and a corresponding I-Space \u2014 a private AgentSpace that houses its LifeCode, Data Grove, and core affordances. </li> <li>Agents can make offers and accept offers made by others to form Agreements.</li> </ul> <p>Agents are expressed as Holons that belong to one or more AgentSpaces. Every Agent belongs to the Exosphere and typically one or more additional AgentSpaces.</p>"},{"location":"shared/glossary/#agentspace","title":"AgentSpace","text":"<p>An AgentSpace is a membrane-bound social space where Agents interact, co-create, and participate in regenerative value flows. It is simultaneously:</p> <ul> <li>A HolonSpace \u2014 stewarding both Agents and Holons</li> <li>A container for knowledge, relationships, and shared governance</li> <li>A venue for Offers, Agreements, Promises, and visualization</li> </ul> <p>Every AgentSpace has its own LifeCode, and every interaction between Agents happens within an AgentSpace.</p> <p>\u26a0\ufe0f Not every AgentSpace is itself an Agent (i.e., not all are Social Organisms), but some  AgentSpaces, once sufficiently coherent and governed, may themselves become Agents \u2014 emergent wholes acting at a higher level of the holarchy.</p>"},{"location":"shared/glossary/#agreement","title":"Agreement","text":"<p>An Agreement is created from an Offer when agents have accepted all of the mandatory roles of the Offer. An Agreement may instantiate its own Agreement-Based AgentSpace which becomes the interaction venue for activities governed by that agreement.</p>"},{"location":"shared/glossary/#agreement-based-agentspace","title":"Agreement-Based AgentSpace","text":"<p>An Agreement-Based AgentSpace is a bounded interaction context that emerges when an Offer is accepted and an Agreement is formed.</p> <p>It includes: - All participating Agents - A LifeCode derived from the shared promises and intent of the Agreement - A scoped Data Grove of relevant Holons and references - The governance and coordination logic encoded in the Agreement, including optional roles for verification, mediation, or escalation</p> <p>While agreements may expire, be revoked, or become inactive, the AgentSpace itself \u2014 like all entities in the MAP \u2014 is immutable and persistent. Its history, structure, and prior interactions remain verifiable and accessible, preserving both accountability and lineage.</p> <p>An Agreement-Based AgentSpace is the sovereign membrane where promises take form, interactions unfold, and trust-based coordination becomes possible \u2014 with a cryptographically assured memory.</p>"},{"location":"shared/glossary/#choreographer","title":"Choreographer","text":"<p>The Choreographer is the MAP\u2019s native coordination engine. It manages the invocation and sequencing of modular dances across agents, spaces, and roles using declarative Dance Flows. </p> <p>Each dance performs a single task and emits a completion signal. The Choreographer listens for these signals and, based on the active flow specification and local context, invokes the next appropriate step. By keeping sequencing logic outside of individual dances, MAP enables complex behaviors to be composed from simple, intelligible parts.</p>"},{"location":"shared/glossary/#commoning","title":"Commoning","text":"<p>Commoning is the ongoing social process through which people collaboratively create, steward, and sustain shared resources (i.e., Vital Capitals) and relationships. At its core, commoning is a relational, participatory, and adaptive practice that reclaims shared power in managing the conditions of life. It is not just a structure, but a way of being and doing together.</p> <p>Commoning emerges outside of \u2014 and often in resistance to \u2014 market and state logics, cultivating trust, reciprocity, and long-term ecological and social flourishing. The lived practice of mutual care, collective governance, and cultural co-creation is what enables a commons to thrive.</p> <p>\u201cCommoning is a verb. It\u2019s about the social practices and cultural traditions that people devise to manage shared resources in fair, inclusive, and sustainable ways.\u201d  \u2014 David Bollier, \u201cThink Like a Commoner\u201d (2014)</p> <p>\u201cThere is no commons without commoning.\u201d \u2014 Peter Linebaugh, \u201cThe Magna Carta Manifesto\u201d (2008)</p>"},{"location":"shared/glossary/#commons","title":"Commons","text":"<p>A Commons is a social system for the long-term stewardship of Vital Capital that preserves shared values and community identity. A self-organized system by which communities manage vital capital (both depletable and replenishable) with minimal or no reliance on the Market or State. In the MAP, a commons is represented by an Agent Space whose  LifeCode conveys its community values, join membrane, and governance model.</p>"},{"location":"shared/glossary/#dahn","title":"DAHN (Dynamic Adaptive Holon Navigator)","text":"<p>A personalized, dynamic interface layer for exploring the MAP holon graph. DAHN empowers each agent to shape their own experience \u2014 not just by choosing settings, but by composing the very way information is seen, explored, and interacted with.</p> <p>Rather than each app imposing its own interface, DAHN provides a coherent visual and interaction layer across all Mapps. This coherence is achieved through dynamic selection of visualizers \u2014 modular components contributed by HX designers to the federated Visualizer Commons.</p> <p>DAHN embodies the MAP design philosophy: putting agents at the center of their digital experience, enabling expressive, adaptable, and trustable interfaces that evolve with collective and individual needs.</p>"},{"location":"shared/glossary/#dance","title":"Dance","text":"<p>A Dance is a named, invocable action that a Holon can perform or participate in \u2014 such as querying data, initiating a service, accepting an offer, or responding to a relationship.</p> <p>In MAP, dances represent affordances \u2014 the ways a Holon can be interacted with \u2014 but the term affordance felt overly technical and lacked poetic resonance.</p> <p>So we coined the term Dance.</p> <p>Why Dance?</p> <ul> <li>Because dances are relational \u2014 they involve interaction, timing, rhythm, consent.</li> <li>Because they convey graceful interdependence, not mechanical execution.</li> <li>Because in MAP, even technical operations are wrapped in patterns of trust, meaning, and flow.</li> </ul> <p>Dances are defined through the MAP Uniform API, where each <code>DanceRequest</code> expresses: - Who is dancing (the Holon) - What dance is being performed - With what input parameters - Under what conditions</p> <p>And the <code>DanceResponse</code> returns: - The result of the dance - A set of next possible dances based on the current state of the system</p> <p>A Dance is not just a function call \u2014 it's a structured act of agency within a living graph of relationship and meaning.</p>"},{"location":"shared/glossary/#dance-flow","title":"Dance Flow","text":"<p>A Dance Flow is a named, context-aware sequence of individual dances that collectively coordinate a process across agents, promises, or Agent Spaces.</p> <p>Each dance within the flow performs a discrete task or role and emits a signal upon completion. The MAP Choreographer responds to these signals by invoking the next appropriate dance in the flow, guided by shared agreements and contextual conditions.</p> <p>Key Characteristics: - Composable: Built from modular, reusable dances. - Declarative: Specifies what should unfold, not how each dance works internally. - Membrane-aware: Executes within or across Agent Spaces while respecting boundaries and permissions. - Promise-aligned: Flows often reflect and reinforce explicit promises among participants.</p> <p>Purpose: Dance Flows enable complex behaviors to emerge through the orchestration of simple, intelligible steps \u2014 making collaborative processes legible, adaptable, and agency-respecting.</p> <p>Related Concepts: \u2192 Dance, Choreographer, Promise Weave, Agent Space</p>"},{"location":"shared/glossary/#dance-interface-protocol","title":"Dance Interface Protocol","text":"<p>The Dance Interface Protocol is the universal invocation protocol in the MAP. It replaces traditional REST or RPC calls with a more expressive, memetic, and composable request model.</p> <p>Every Holon exposes available Dances depending on its current state and context.</p>"},{"location":"shared/glossary/#dancerequest","title":"DanceRequest","text":"<p>A DanceRequest is a Holon-encoded invocation of a Dance. It tells a Holon what is being requested \u2014 and under what terms.</p> <p>Each <code>DanceRequest</code> contains: - The ID of the Holon being danced with - The name of the Dance being invoked - A RequestBody \u2014 including input parameters, context, and initiating agent identity - (Optionally) an associated Agreement that governs the terms of the interaction</p> <p>Like all things in the MAP, the DanceRequest is itself a Holon \u2014 with its own type descriptor, provenance, access policy, and potential for visual representation.</p> <p>DanceRequests can be created by: - Human users interacting through DAHN  - Other Holons (e.g., service Holons triggering dances) - External systems interfacing through the MAP Uniform API</p> <p>A <code>DanceRequest</code> is a memetically and permissionally aware act of intent \u2014 a moment of coordinated agency within a shared graph.</p>"},{"location":"shared/glossary/#danceresponse","title":"DanceResponse","text":"<p>A DanceResponse is the result of performing a Dance. It includes not only the outcome of the request but also the forward affordances \u2014 what the Holon now makes possible.</p> <p>Each <code>DanceResponse</code> includes: - A ResponseBody \u2014 containing results, messages, or new Holons - A list of next available Dances \u2014 HATEOAS-style descriptors of follow-up actions - Provenance metadata and optional diagnostics - Links to updated state, derived Agreements, or resulting relationships</p> <p>Like the <code>DanceRequest</code>, the <code>DanceResponse</code> is a fully self-describing Holon and can be visualized, shared, or referenced by other components of the MAP.</p> <p>A <code>DanceResponse</code> is not just a return value \u2014 it\u2019s the moment-by-moment emergence of possibility in a living graph of consent and flow.</p>"},{"location":"shared/glossary/#data-grove","title":"Data Grove","text":"<p>A Data Grove is the sovereign, Holochain-based data storage area. Each AgentSpace has its own private Data Grove.  All of the mapps that are imported into an Agent Space store their information in the Data Grove of that Space.</p>"},{"location":"shared/glossary/#echo","title":"Echo","text":"<p>An Echo is a signed affirmation of a Promise made by another Agent, issued by an agent who chooses to align with that promise.</p> <p>Echoes serve as memetic endorsements\u2014reinforcing, repeating, and extending the trustworthiness of a promise in a given AgentSpace or across spaces.</p> <p>An Echo is:</p> <ul> <li>A verbatim reference to an existing Promise, not a reinterpretation</li> <li>A social trust gesture\u2014binding the echoing agent\u2019s reputation to the original claim</li> <li>A signal of observability\u2014often grounded in direct experience, shared context, or role-based verification</li> <li>A building block of memetic trust networks, used to evaluate promises, inform Agreements, and govern access or delegation</li> </ul> <p>Echoes may carry optional metadata such as echo weight, reasoning, or contextual scope (e.g., \u201cwithin this space only\u201d).</p> <p>\u2733\ufe0f Echoes are foundational to MAP\u2019s distributed trust model\u2014allowing agents to construct verifiable, socially-scaffolded identity and reputation without centralized authorities.</p>"},{"location":"shared/glossary/#echo-weight","title":"Echo Weight","text":"<p>An Echo Weight is an optional indicator attached to an Echo, expressing the echoing Agent\u2019s degree of confidence, verification, or proximity to the original Promise.</p> <p>Echo Weights enable more nuanced interpretation of social signals by:</p> <ul> <li>Differentiating firsthand from secondhand endorsements</li> <li>Informing access decisions, Agreement thresholds, and trust scores</li> <li>Supporting evaluative logic in AgentSpaces and across social holarchies</li> </ul> <p>Weights may be numeric (e.g., 0.9), categorical (e.g., \u201cstrong,\u201d \u201clight\u201d), or policy-defined by a GroupAgent.</p> <p>\u2733\ufe0f While optional, Echo Weights help MAP spaces distinguish between weak support and strong verification\u2014without requiring rigid central scoring systems.</p>"},{"location":"shared/glossary/#exosphere","title":"Exosphere","text":"<p>The Exosphere is the outermost, most inclusive AgentSpace in the MAP. It includes all Agents by default and serves as the lowest-threshold interaction venue across the entire platform.</p> <p>The Exosphere is:</p> <ul> <li>Non-governed (aside from platform-level rules)</li> <li>High-reach, low-trust</li> <li>The place where initial Offers may be surfaced to broad audiences</li> </ul> <p>It is not a commons or Social Organism \u2014 it is a shared membrane of visibility.</p>"},{"location":"shared/glossary/#governance-scaffold","title":"Governance Scaffold","text":"<p>A Governance Scaffold is a modular structure of roles, rules, and processes that guides how coordination and decision-making unfold within an AgentSpace.</p> <p>Rather than imposing a fixed governance model, a governance scaffold provides lightweight, composable affordances that can evolve alongside the needs and context of the space. These scaffolds are often memetically sourced from the Global Meme Pool, where patterns like sociocracy, holacracy, liquid democracy, or bespoke cultural traditions can be adapted and instantiated.</p> <p>Governance scaffolds define: - Who has voice and agency - How decisions are made and validated - What roles exist and how they are assigned or rotated - How conflicts are mediated or escalated</p> <p>They can be: - Hard-coded into Agreements - Expressed as Memeplexes in the Meme Pool - Referenced dynamically during Dance Flows</p> <p>\ud83e\udde9 Governance scaffolds are to governance what protocols are to software: flexible, interoperable building blocks that support resilient, adaptive coordination.</p> <p>See also: AgentSpace, LifeCode, Agreement, Meme Pool</p>"},{"location":"shared/glossary/#holon","title":"Holon","text":"<p>A Holon is the foundational unit of structure, meaning, and interaction in the MAP.</p> <p>Every object in the MAP \u2014 whether it\u2019s a piece of content, an Agent, a relationship, a service, or a visual element \u2014 is encoded as a self-describing, active Holon or HolonRelationship.</p>"},{"location":"shared/glossary/#self-describing","title":"\u2727 Self-Describing","text":"<p>A Holon contains within itself everything needed to interpret and interact with it. When you encounter a Holon \u201cin the wild,\u201d you can ask:</p> <ul> <li> <p>What properties do you have?   What are your current values for those properties?</p> </li> <li> <p>What types of relationships do you participate in?   To what other Holons are you related via those relationships?</p> </li> <li> <p>Through what visualizations can I view and interact with you?   Holons reference one or more Visualizers from the commons, allowing fully customizable rendering and interaction \u2014 from list views to immersive spatial experiences.</p> </li> <li> <p>What types of data access are permitted?   Holons carry their own access policies, provenance signatures, and licensing terms \u2014 enabling granular, trustable permissioning.</p> </li> </ul>"},{"location":"shared/glossary/#active","title":"\u2727 Active","text":"<p>Holons aren\u2019t just data \u2014 being active means holons can do stuff... they offer affordances.</p> <p>Every Holon can declare the Dances it is capable of performing \u2014 actions that can be invoked via the MAP Uniform API. These may include:</p> <ul> <li>Responding to queries</li> <li>Invoking relationships</li> <li>Triggering services</li> <li>Participating in negotiations, offers, or agreements</li> </ul> <p>In this way, Holons are not passive records, but sovereign, interactive knowledge actors that make up the living substrate of the MAP.</p> <p>A Holon is not just a piece of data \u2014 it is a meaningful, permissioned, expressive agent of action in a graph of relationships. It sees, responds, and evolves.</p>"},{"location":"shared/glossary/#holonspace","title":"HolonSpace","text":"<p>A HolonSpace is the foundational data container in the MAP, equivalent to an AgentSpace. While the term highlights its function as a steward of Holons, in MAP narratives, the two terms are generally treated as synonymous.</p>"},{"location":"shared/glossary/#i-space","title":"I-Space","text":"<p>An I-Space is an AgentSpace viewed from the interior perspective \u2014 focusing on internal structure, properties, intentions, and affordances of an Agent.</p> <p>Every Agent has an I-Space. For persons, this is often referred to as a Personal I-Space, but not all I-Spaces are personal.</p> <p>See also: We-Space</p>"},{"location":"shared/glossary/#join-membrane","title":"Join Membrane","text":"<p>The set of rules defined by an AgentSpace's Life Code that govern adding new members of the Agent Space.</p>"},{"location":"shared/glossary/#lifecode","title":"LifeCode","text":"<p>A LifeCode (also known as a Memetic Signature) is the values-and-identity encoding of an Agent, AgentSpace, Offer or Agreement. It defines:</p> <ul> <li>Aspirational purpose</li> <li>Memetic values and ethics</li> <li>Governance expectations</li> <li>Membership criteria</li> <li>Expressed Promises</li> </ul> <p>The LifeCode is the symbolic \"membrane\" of an AgentSpace and plays a foundational role in trust-based interaction.</p>"},{"location":"shared/glossary/#meme","title":"Meme","text":"<p>A Meme is a pattern, story, value, or shared practice that carries meaning and can be passed from one person or group to another.</p> <p>In the MAP, a meme could be a community ritual, a traditional teaching, a way of solving problems, a decision-making method, a symbol, or even a sacred story. Some memes are old and passed down through generations. Others are new, shared in conversation, taught in workshops, or built into tools and agreements.</p> <p>What matters is not just where a meme comes from \u2014 but that it helps people live together with intention, take action, or share understanding.</p> <p>Memes travel in many ways. Some are copied, some are taught, some are woven into daily life. In MAP, we honor all of these. Whether a meme is passed in a ceremony, a drawing, a document, or a song \u2014 it becomes part of our living culture when people put it into use.</p> <p>Memes are gathered into Meme Pools, where they can be shared, adapted, and stewarded with care \u2014 so that wisdom from one place can grow in another, without losing its roots.</p> <p>See also: Meme Pool, Vital Capital, LifeCode</p>"},{"location":"shared/glossary/#meme-technical","title":"Meme (technical)","text":"<p>A Meme is a structured unit of cultural meaning that can be defined, expressed, enacted, and evolved by Agents.</p> <p>In the MAP, a meme may take many forms \u2014 including values, principles, protocols, schemas, profiles, practices, rituals, governance models, economic models, or other cultural structures that guide interaction and meaning-making. Every meme is modular, stewardable, and context-aware.</p> <p>In the MAP, memes are not just viral ideas \u2014 they are the living infrastructure of cultural evolution.</p> <p>MAP extends Richard Dawkins\u2019 original definition \u2014 which emphasized replication through imitation \u2014 to include agentic enactment, contextual re-use, and memetic evolution. Memes may spread via imitation (per Dawkins), but also through instruction, documentation, or embedded use in systems and agreements. What defines a meme is not just how it spreads, but that it encodes actionable meaning and can be activated across diverse contexts.</p> <p>Memes are replicable and selectable: they persist through evolutionary dynamics, where their relevance and effectiveness are tested in lived experience. In this way, MAP supports not just cultural transmission, but the iterative refinement and ecological adaptation of its memetic commons.</p> <p>Epistemic rigor \u2014 such as practices rooted in the scientific method \u2014 can strengthen the fidelity and resilience of a meme by making it easier to reproduce, test, and refine across contexts. However, epistemic rigor is neither the sole pathway to replicability nor a universal standard: many memes in MAP draw from spiritual traditions, embodied practices, or lived experience that offer their own forms of coherence, relevance, and transmission.</p> <p>Memes can be classified by:</p> <ul> <li>Type (e.g. atomic meme, schema, protocol, visualizer)</li> <li>Category (e.g. governance, economics, learning, identity)</li> <li>Functional structure (e.g. memeplex, memefamily)</li> </ul> <p>Every Meme in MAP is a form of Vital Capital, and is stewarded within one or more Meme Pools.</p> <p>See also: Meme Pool, Vital Capital, LifeCode</p>"},{"location":"shared/glossary/#meme-pool","title":"Meme Pool","text":"<p>A Meme Pool is a collection of memes together with the agents and governance processes that steward them. In other words, a Meme Pool is a Commons.</p>"},{"location":"shared/glossary/#memetic-signature","title":"Memetic Signature","text":"<p>Synonym for LifeCode. Refers to the expressive encoding of an Agent\u2019s identity, values, and memetic alignment.</p>"},{"location":"shared/glossary/#observability","title":"Observability","text":"<p>Observability describes the degree to which a Promise can be independently verified by other Agents within a given AgentSpace.</p> <p>Every Promise has an implicit or explicit observability profile, which may be:</p> <ul> <li>Direct \u2014 fulfillment is visible to others (e.g., a submitted file, a public action)</li> <li>Indirect \u2014 fulfillment is verifiable through roles, logs, or trusted intermediaries</li> <li>Unobservable \u2014 fulfillment is private or unverifiable (e.g., internal state, intentions)</li> </ul> <p>Spaces may define Observability Profiles that specify the kinds of promises they accept, echo, or require in Agreements.</p> <p>\u2733\ufe0f Observability governs the memetic legibility of a promise\u2014what others can trust, echo, or build upon.</p>"},{"location":"shared/glossary/#offer","title":"Offer","text":"<p>An Offer is a proposed bundle of Promises, expressing both:</p> <ul> <li>What the offering Agent is willing to do or provide</li> <li>What reciprocal Promises it expects in return</li> </ul> <p>Offers are shared into specific AgentSpaces (e.g., the Exosphere or a Social Organism) and may result in Agreements.</p>"},{"location":"shared/glossary/#offer-type","title":"Offer Type","text":"<p>An Offer Type is a reusable template or pattern that defines the structure, roles, conditions, and expectations for a class of Offers in the MAP.</p> <p>Offer Types allow communities and Agents to create Offers with shared semantics and validated structure. Each Offer Type is a Meme \u2014 discoverable, remixable, and stewarded in the Global Meme Pool.</p> <p>Key properties of an Offer Type may include: - A named purpose or intent (e.g., \u201cTimebank Exchange\u201d, \u201cMicrogrant Application\u201d, \u201cCommons Stewardship Invitation\u201d) - The required and optional roles (e.g., Initiator, Contributor, Verifier) - Preconditions and fulfillment criteria - Common reciprocity patterns (e.g., \u201coffer of service in exchange for learning\u201d)</p> <p>By standardizing structure while remaining adaptable, Offer Types reduce friction and ambiguity in peer coordination, and enable the creation of Agreements that are intelligible across diverse contexts.</p> <p>\ud83d\udce6 An Offer Type is a memetic design pattern for regenerative coordination \u2014 shaping how value is proposed, negotiated, and enacted.</p> <p>See also: Offer, Agreement, Meme, Meme Pool</p>"},{"location":"shared/glossary/#promise","title":"Promise","text":"<p>A Promise is a voluntary, sovereign commitment made by one Agent. It is the atomic unit of value coordination within MAP.</p> <p>Promises may be formal (e.g., I promise to transfer 10 units of water in exchange for 5 units of labor) or informal (e.g., I promise to show up with care and attention).</p> <p>All Agreements are built from bundles of Promises.</p>"},{"location":"shared/glossary/#service","title":"Service","text":"<p>Services support the flow and transformation of vital capitals to/from other agents for mutual benefit. Services are the focus of Offers, Agreements, and Service Invocations.</p>"},{"location":"shared/glossary/#service-invocation","title":"Service Invocation","text":"<p>A request to an offering agent to perform a requested service within the context of an active agreement.</p>"},{"location":"shared/glossary/#social-organism","title":"Social Organism","text":"<p>A Social Organism is an AgentSpace that has developed enough internal coherence, governance capacity, and memetic identity to act as an Agent in its own right\u2014a Holon one level up.</p> <p>Unlike the default Exosphere, which includes all agents by default and lacks any collective governance, a Social Organism is formed intentionally. It may emerge from one or more Agreement-Based AgentSpaces and evolve into an agentic identity through extensions to its LifeCode.</p> <p>A key property of Social Organisms\u2014described by Ken Wilber as Social Holons<sup>1</sup>\u2014is that membership is non-exclusive. That is, an individual agent can participate in multiple Social Organisms at once. This contrasts with Biological Holons (e.g., cells or mitochondria), whose parts typically belong to a single organism. Social Holons reflect the fluid, overlapping, and context-dependent nature of social identity and affiliation.</p> <p>Social Organisms are not merely large groups\u2014they are living holons: capable of acting, adapting, evolving, and participating in higher-order Social Organisms themselves. A canonical example is a corporation\u2014a persistent, governance-equipped AgentSpace that can form agreements and delegate authority to sub-agents.</p> <p>Other examples might include co-ops, intentional communities, DAOs, or bioregional networks.</p> <p>See also: AgentSpace, Exosphere, LifeCode, Agreement, Agent, Holon</p>"},{"location":"shared/glossary/#stewardship","title":"Stewardship","text":"<p>In the MAP, stewardship replaces \"ownership\" to describe the relationship between an AgentSpace and the Holons it is responsible for. Each Holon is stewarded by exactly one AgentSpace, though it may be referenced in many.</p> <p>Stewardship emphasizes care, consent, and accountability.</p>"},{"location":"shared/glossary/#uniform-api","title":"Uniform API","text":"<p>The Uniform API is the singular interface through which all interactions with the MAP take place. It is based on the metaphor of the Dance, framing every invocation \u2014 from data queries to service calls \u2014 as a shared, consensual interaction.</p> <p>At its core is the <code>dance()</code> function, which accepts a <code>DanceRequest</code> and returns a <code>DanceResponse</code>.</p> <ul> <li>The DanceRequest specifies:</li> <li>The Holon (or relationship) initiating the Dance</li> <li>Parameters for the action (e.g., queries, inputs, filters)</li> <li> <p>Optionally, an OpenCypher query \u2014 enabling expressive graph traversal and transformation</p> </li> <li> <p>The DanceResponse returns:</p> </li> <li>Results from the invocation (e.g., data, confirmation, computation)</li> <li>Updated state where appropriate</li> <li>Additional <code>DanceRequest</code> options (HATEOAS-style), revealing the next set of affordances available in the current state</li> </ul> <p>Because the MAP is knowledge-graph native, all interactions \u2014 including service calls, interface rendering, and value flows \u2014 are expressible as Dances across a dynamic graph of Holons.</p> <p>The Uniform API means every Holon interaction is symmetric, discoverable, and composable \u2014 turning the MAP into a danceable language of consent, action, and agency.</p>"},{"location":"shared/glossary/#vital-capital","title":"Vital Capital","text":"<p>A core MAP holon type representing the diverse forms of value that can flow between Agents \u2014 including knowledge, care, trust, materials, attention, and more. Vital Capital is what flows as a result of service invocations and fulfilled Promises. While not inherently scarce or commodified, each Vital Capital holon is definable, describable, and context-aware. When under the stewardship of a particular Agent, it may be treated as an Asset. The concept draws from multiple sources, including Context-Based Sustainability (McElroy), the Metacurrency Project (which defines wealth as \"the capacity to meet the needs of a living system\"), and the 8 Forms of Capital in permaculture theory.</p> <p>The MAP concept of Vital Capital refers to the many forms of value \u2014 not just financial \u2014 that flow through MAP Agreements. These include:</p> <p>draws heavily on the work around Context-Based Sustainability (see citation below) </p> Capital Type Description Natural Capital Ecosystem services, land, water, air, biodiversity Human Capital Skills, labor, knowledge, health, attention Social Capital Trust, reputation, relationships, group cohesion Cultural Capital Stories, rituals, symbols, traditions, identity Built Capital Tools, infrastructure, digital systems, physical assets Financial Capital Currency, tokens, credit, investments Experiential Capital Aesthetic, emotional, and lived experiences Memetic Capital Values, beliefs, narratives, memetic signatures Temporal Capital Time, availability, scheduling of attention or actions Spiritual Capital Purpose, presence, connection to meaning (optional but supported dimension) <ul> <li>Social capital</li> <li>Ecological contributions</li> <li>Attention, care, and creativity</li> <li>Knowledge and memetic resources</li> </ul> <p>Vital capital flows are explicitly tracked via Promises and Agreements.</p> <p>For more information: see  McElroy, M. W. (2008). Social Footprints: Measuring the Social Sustainability Performance of Organizations. Middlebury: Center for Sustainable Innovation. https://www.sustainableinnovation.org ResearchGate PDF</p>"},{"location":"shared/glossary/#visualizer","title":"Visualizer","text":"<p>A Visualizer is a Holon that describes how another Holon should be rendered and interacted with \u2014 in 2D, 3D, text, graph, gallery, immersive environment, or any other format.</p> <p>Visualizers are contributed to the Visualizer Commons and selected at runtime by DAHN based on: - The type of Holon - The preferences of the Agent viewing it - The popularity and contextual fit of available visualizers</p> <p>Every Holon can reference one or more Visualizers, allowing radically different renderings for different contexts \u2014 from dashboards to immersive journeys.</p> <p>A Visualizer is not just a UI component \u2014 it is a semantic lens, a votable style, and a participatory aesthetic contribution to the shared experience of the MAP. </p>"},{"location":"shared/glossary/#visualizer-commons","title":"Visualizer Commons","text":"<p>A federated network of stewarded sets of Visualizers. DAHN dynamically selects and configures visualizers from the Visualizer Commons to present and enable interaction with the MAP' self-describing, active Holons</p>"},{"location":"shared/glossary/#we-space","title":"We-Space","text":"<p>A We-Space is an AgentSpace viewed from the exterior perspective \u2014 how it participates within larger structures, how it exposes interfaces and affordances, and how it relates to other spaces.</p> <p>A Social Organism is always a We-Space, but not all We-Spaces are yet Social Organisms.</p> <ol> <li> <p>Wilber, Ken. Sex, Ecology, Spirituality: The Spirit of Evolution. Shambhala Publications, 1995.\u00a0\u21a9</p> </li> </ol>"}]}