{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MAP Developer Documentation","text":"<p>Welcome to the MAP Developer Documentation.</p> <p>This site is intended to support developers, schema authors, and community contributors who are building with the MAP Type System and holonic data structures.</p> <p>MAP is designed to be:</p> <ul> <li>Self-describing \u2014 every type is a holon</li> <li>Composable \u2014 types and schemas can be extended without breaking compatibility</li> <li>Federated \u2014 schema evolution happens across a network of independently defined but interoperable types</li> </ul>"},{"location":"#getting-started","title":"\ud83e\udded Getting Started","text":"<p>This documentation is still evolving. It's initial focus is on a JSON File Authoring Guide as part of the MAP Holon Data Loader. </p> <ul> <li>Explore the type system design in the MAP wiki</li> <li>Review example import files in <code>schemas/</code> if available</li> <li>Watch this space for developer guides and schema authoring tips</li> </ul> <p>We\u2019ll be adding more structured guides and references as the project grows. Contributions are welcome.</p> <p>For licensing info, see LICENSE.md.</p>"},{"location":"core/agent-space-arch/","title":"MAP Architectural Consolidation \u2014 AgentSpace, TrustChannels, Routing, and Protocol Extensibility","text":"<p>One DNA. One Zome. One EntryType. One LinkType. The entire MAP runtime emerges from this singular, self-similar pattern \u2014 replicated fractally at every scale of agency.</p> <p>A series of related insights have resulted in the MAP architecture converging into a unified and elegant runtime model. Many of the early \u201cfuzzy edges\u201d have been clarified, revealing a single coherent structure that expresses the holonic principle at every level of the system.</p> <p>At its core, MAP now recognizes one coordinator zome \u2014 AgentSpace.  The same AgentSpace codebase governs every context of interaction: personal I-Spaces, collective We-Spaces, and any higher-order federations built from them.  Each AgentSpace is simultaneously a whole (coordinating its own members and internal Dances) and a part (participating as an agent within larger collectives).  This mirrors the biological and social logic that inspired the platform: every living entity is both autonomous and relational.</p> <p>The sections that follow unpack how this consolidation simplifies the entire MAP runtime \u2014 beginning with the shift to a single DNA, and continuing through the unification of I-Space and We-Space roles, the definition of TrustChannels and RoutingHolons, and the design of MAP\u2019s extensible communication protocols.</p>"},{"location":"core/agent-space-arch/#1-one-dna-decoupling-social-context-from-application-code","title":"1. One DNA: Decoupling Social Context from Application Code","text":"<p>Perhaps the most fundamental architectural distinction between Holochain and MAP lies in how each defines an application. A Holochain application, or hApp, always couples two things: 1. a DNA \u2014 the code container that defines what data structures and zomes exist, and 2. a DHT \u2014 the membership container that holds the agents participating in that shared membrane.</p> <p>Each hApp therefore bundles who participates together with what code runs. That coupling makes every hApp an app-specific shard of the social graph. If four housemates want to use ten Holochain apps together, they must join ten DHTs with identical membership, updating each one whenever someone joins or leaves. This intertwining of social and functional boundaries leaves a trace of app-centricity in an otherwise agent-centric framework.</p> <p>MAP dissolves that coupling entirely. In MAP, a mApp (memetic application) is not a new DNA and does not create its own DHT. Instead, it is a declarative extension of the shared runtime \u2014 a bundle of schemas, Dances, and visualizers that introduces new affordances within existing Spaces.</p> <p>The consolidated MAP runtime now operates from a single DNA \u2014 AgentSpace \u2014 whose sole purpose is to maintain the social context of each collective: its members, roles, LifeCode, and Agreements. Every social organism in MAP, from an individual to a federation of cooperatives, runs this same AgentSpace DNA.</p> <p>All other functionality \u2014 Promises, Trust Channels, Vital Capital Flows, Governance Scaffolds, and more \u2014 is governed by digitally signed Agreements that define how Dances are invoked within and between AgentSpaces. Each AgentSpace executes its own Dances locally, while TrustChannels mediate secure exchanges of DanceRequests and DanceResponses across membranes.</p> <p>Executable logic becomes available through Dynamic Dance Dispatch. This mechanism allows any type within the ontology to declare the Dances it affords and bind them to runtime implementations, so new behaviors can be dynamically loaded, verified, and executed \u2014 all without embedding code in the DNA itself. For more details, see the Dances Design Spec.</p> <p>This yields a purely agent-centric architecture: - The DHT corresponds to who is in relationship. - mApps define how those agents can interact.   Membership changes once \u2014 at the membrane \u2014 and immediately applies across all applications.</p> <p>Benefits of the one-DNA model: - \ud83d\udd39 Dramatically reduced deployment and onboarding complexity - \ud83d\udd39 Unified governance and membership management - \ud83d\udd39 Lower network and storage overhead - \ud83d\udd39 Simplified developer workflow (no DHT proliferation) - \ud83d\udd39 Clear separation between social topology and functional affordances - \ud83d\udd39 Extensibility through mApps and Dynamic Dance Dispatch \u2014 introducing new schemas and executable behaviors without modifying the base DNA</p>"},{"location":"core/agent-space-arch/#2-one-zome-unification-of-i-space-and-we-space","title":"2. One Zome: Unification of I-Space and We-Space","text":"<p>While Section 1 clarified that MAP runs on a single DNA pattern, this section shows how that DNA is expressed through a single zome: AgentSpace.  AgentSpace unifies the code underlying I-Space and We-Space into one self-similar runtime component capable of playing both roles.</p> <p>Every AgentSpace is simultaneously: - A whole, containing and coordinating its internal agents (inward-facing behavior). - A part, participating as a member within larger collectives (outward-facing behavior).</p> <p>This dual role embodies the holonic principle: every holon is both a whole and a part. There are no separate codebases for I-Space vs. We-Space; configuration \u2014 via LifeCode, Agreements, and memberships \u2014 determines the current orientation and responsibilities.</p> <p>Key outcomes of this unification: - \ud83e\udde9 One coordinator zome for all social contexts (AgentSpace). - \ud83d\udee1\ufe0f Each DHT now represents a distinct social organism \u2014 from an individual to a federation. - \ud83d\udcdc Differentiation occurs through LifeCodes and Agreements, not through divergent codebases. - \u267b\ufe0f The same logic applies recursively at every scale of agency.</p>"},{"location":"core/agent-space-arch/#2-responsibilities-of-an-agentspace","title":"2. Responsibilities of an AgentSpace","text":"<p>An AgentSpace holon:</p> <ol> <li>Manages Membership \u2013 defines its join membrane, validates new sub-agents, and governs internal roles.</li> <li>Maintains Agreements \u2013 stores and enforces both internal (LifeCode) and external (Trust-based) Agreements.</li> <li>Coordinates Dances \u2013 orchestrates local Dances among internal agents and bridges to external Spaces.</li> <li>Hosts TrustChannels \u2013 instantiates inbound and outbound TrustChannel instances at its membrane boundaries.</li> <li>Handles Routing \u2013 collaborates with RoutingHolons to resolve addresses, select transports, and ensure reliable delivery.</li> <li>Enforces LifeCode \u2013 applies local norms and validation rules to all actions within its membrane.</li> <li>Provides Sovereign Persistence \u2013 persists its own Holons and governs external references through secure fetches.</li> <li>Acts as Participant \u2013 when part of a larger collective, joins We-Spaces via the same TrustChannel interface it uses internally.</li> </ol>"},{"location":"core/agent-space-arch/#3-trustchannel-architecture","title":"3. TrustChannel Architecture","text":"<ul> <li>Single codebase for TrustChannels; every instance represents a membrane boundary.</li> <li>Instances are created wherever two AgentSpaces interact.<ul> <li>Outbound instance on the sending side wraps, signs, and transmits capsules.</li> <li>Inbound instance on the receiving side verifies and unwraps capsules.</li> </ul> </li> <li>A single Dance involves two cooperating instances \u2014 one outbound, one inbound \u2014 each governed by its side\u2019s LifeCode or Agreement.</li> <li>The TrustChannel code itself is a lightweight capsule assembler/disassembler; it does not hard-code envelope logic.</li> </ul>"},{"location":"core/agent-space-arch/#31-envelope-and-capsule-model","title":"3.1 Envelope and Capsule Model","text":"<ul> <li>A Capsule is an ordered stack of Envelopes wrapped around a payload.</li> <li>Each EnvelopeType is a HolonType descriptor defining:<ul> <li>its attributes (what\u2019s written \u201con the outside\u201d),</li> <li>its order in the stack,</li> <li>and the Dances that perform <code>wrap()</code> and <code>unwrap()</code>.</li> </ul> </li> <li>Capsule composition for any interaction is determined dynamically by:<ul> <li>the Agreement (for cross-Space interactions), or</li> <li>the LifeCode (for intra-Space interactions).</li> </ul> </li> </ul>"},{"location":"core/agent-space-arch/#32-envelope-responsibilities","title":"3.2 Envelope Responsibilities","text":"<p>Typical envelope layers: 1. SessionEnvelope \u2013 context/state exchange (optional, LifeCode-governed). 2. SecurityEnvelope \u2013 Agreement reference, Persona signature, nonces, proofs. 3. TransportEnvelope \u2013 framing and routing hints for the selected transport. 4. Payload \u2013 the opaque DanceRequest or DanceResponse.</p> <p>Each layer is self-describing via its HolonType and can evolve independently.</p>"},{"location":"core/agent-space-arch/#4-routingholon","title":"4. RoutingHolon","text":"<ul> <li>A reusable holon providing transport Dances for discovery, path selection, retries, and delivery.</li> <li>Operates identically whether:<ul> <li>routing inside an AgentSpace (originator \u2192 bridge sub-agent), or</li> <li>routing between AgentSpaces (bridge \u2192 recipient Persona).</li> </ul> </li> <li>Maintains registries of active agents, bridge health, and performance metrics.</li> <li>Provides retry, back-off, and K-parallel sending for resilience.</li> <li>Exposes a consistent API to TrustChannels:<ul> <li><code>resolve_candidates(address) \u2192 [AgentRoute]</code></li> <li><code>select(candidates, policy) \u2192 AgentRoute</code></li> <li><code>send(route, Capsule) \u2192 Result</code></li> </ul> </li> </ul>"},{"location":"core/agent-space-arch/#5-pluggable-transport-protocols","title":"5. Pluggable Transport Protocols","text":"<ul> <li>Transport is pluggable; Holochain networking is one possible carrier, not the only one.</li> <li>Alternate transports (HTTP, JLINC, mesh, peer-to-peer bus, etc.) can be bound via different RoutingHolon implementations.</li> <li>Agreements specify which transport protocols are valid for a given TrustChannel.</li> <li>Each protocol corresponds to a set of envelopes defining its framing and security layers.</li> <li>Cross-Space communication with non-Holochain services is supported as long as both sides honor the same protocol definition (the envelope schema).</li> </ul>"},{"location":"core/agent-space-arch/#6-protocol-vs-api","title":"6. Protocol vs. API","text":"<ul> <li>API: language-specific surface used by local code (e.g., RoutingHolon Dances).   It encapsulates how capsules are constructed or interpreted within a particular runtime.</li> <li>Protocol: language-independent definition of the envelope stack and payload semantics.   Any implementation in any environment can participate if it can construct and parse the same capsule structure.</li> <li>The combination of:<ul> <li>the API layer (RoutingHolon + TrustChannel code) and</li> <li>the protocol definition (Agreement-defined envelope schema)   enables MAP to interoperate across different runtimes and evolve its protocols without changing core code.</li> </ul> </li> </ul>"},{"location":"core/agent-space-arch/#7-extensibility-through-agreements","title":"7. Extensibility Through Agreements","text":"<ul> <li>Agreements are the living source of protocol definition:<ul> <li>They specify which EnvelopeTypes apply and in what order.</li> <li>They dictate validation rules, privacy levels, and transport preferences.</li> <li>They can introduce new capsule types without touching core zome logic.</li> </ul> </li> <li>LifeCodes serve the same role internally within a Space.</li> <li>This design allows MAP\u2019s communication layer to evolve purely through new HolonType definitions and Agreements, keeping the base AgentSpace and TrustChannel code stable.</li> </ul>"},{"location":"core/agent-space-arch/#8-summary-the-unified-pattern","title":"8. Summary: The Unified Pattern","text":"Layer Responsibility Extensible By AgentSpace Governs members, manages Agreements, instantiates TrustChannels LifeCode TrustChannel Wraps/unwraps capsules, enforces Agreement/LifeCode rules EnvelopeType holons RoutingHolon Finds paths, chooses transport, ensures delivery Transport adapter holons Transport Protocol Defines envelope stack and serialization Agreement Capsule / Envelope Self-describing data structure governing how value flows HolonType descriptors <p>Together they form a fractal, self-describing communication fabric where: - Every AgentSpace is both a whole and a part. - Every membrane crossing is mediated by a TrustChannel. - Every Capsule structure is governed by the living Agreements of the participating Spaces. - New social or technical protocols can be introduced by publishing new EnvelopeType holons\u2014no hard-coded changes required.</p> <p>This is the extensible core of the Memetic Activation Platform\u2019s holonic communication model.</p>"},{"location":"core/capsulization/","title":"MAP Context-Aware Capsulization &amp; Session State Strategies \u2014 Design Spec","text":""},{"location":"core/capsulization/#0-purpose-scope","title":"0. Purpose &amp; Scope","text":"<p>This specification defines how MAP determines the appropriate capsulization strategy for a given Dance invocation based on the interaction context, and how session state is managed across contexts where state continuity cannot be assumed.</p> <p>It extends the MAP Trust Channel and Security Model specifications by describing: - Context profiles for different communication topologies. - How envelope stacks are constructed dynamically. - How session state (transient holon pools, nursery references) is shipped or resolved. - How Agreements override or refine these defaults for cross-Space exchanges.</p>"},{"location":"core/capsulization/#1-architectural-overview","title":"1. Architectural Overview","text":""},{"location":"core/capsulization/#11-context-aware-capsuleization","title":"1.1 Context-Aware Capsuleization","text":"<p>A capsuleization strategy determines which envelopes are applied around a Dance payload when building or validating a Dance Capsule. The selected strategy depends on: - The context boundary being crossed (in-process, inter-agent, or cross-space). - The trust surface (same process vs. network transport). - The state continuity (whether the callee maintains persistent context). - The Agreement defining additional envelope requirements for cross-space flows.</p> <p>Capsuleization is governed by ContextProfiles, not hard-coded paths. Each ContextProfile maps a boundary type to an ordered list of envelope kinds and defines its state-handling strategy.</p>"},{"location":"core/capsulization/#2-context-profiles","title":"2. Context Profiles","text":""},{"location":"core/capsulization/#21-profile-definition","title":"2.1 Profile Definition","text":"<p>Holon Type: <code>ContextProfile</code> Key Properties: - <code>src_env</code> / <code>dst_env</code> (TypeScript, RustHost, RustGuest, RemoteSpace) - <code>space_boundary</code> (None | SameSpace | CrossSpace) - <code>trust_surface</code> (InProcess | LocalIPC | LAN | WAN | DHT) - <code>state_strategy</code> (NoShipping | ShipSessionState) - <code>default_envelope_set</code> (ordered list of envelope kinds) - <code>gating_policy</code> (conditions for step-up or extra envelopes)</p> <p>Relationships: <pre><code>ContextProfile\n \u251c\u2500\u2500 UsesEnvelopeType \u2192 [EnvelopeType...]\n \u251c\u2500\u2500 AppliesStateStrategy \u2192 StateStrategy\n \u251c\u2500\u2500 UsesStepUpPolicy \u2192 StepUpPolicy\n \u2514\u2500\u2500 OverridesByAgreement \u2192 Agreement?\n</code></pre></p> <p>Each ContextProfile is itself a holon, discoverable and replaceable by Agreements that define custom profiles.</p>"},{"location":"core/capsulization/#22-canonical-profiles","title":"2.2 Canonical Profiles","text":"Context Boundary State Strategy Envelope Stack (inbound/outbound) Notes TypeScript \u2192 Rust (Tauri same process) None NoShipping [Unlock?], [Payload] Not a membrane; minimal capsule. Rust Host \u2192 Rust Guest (stateless guest) SameSpace ShipSessionState [Unlock?], [AuthZ?], [SessionState], [Payload] State ping-ponged; optional logical AuthZ. Space A \u2192 Space B (network/DHT) CrossSpace Configured by Agreement [Transport, AuthN, Crypto, AuthZ, Dispatch, Unlock?, SessionState?, Payload] / [Payload, Exfiltration, Crypto, AuthN, Transport] Full capsule sequence. <p>Each profile defines the expected validator order and transient state behavior for the trust surface.</p>"},{"location":"core/capsulization/#3-capsulebuilder-capsulevalidator","title":"3. CapsuleBuilder &amp; CapsuleValidator","text":""},{"location":"core/capsulization/#31-capsulebuilder","title":"3.1 CapsuleBuilder","text":"<p>Constructs Dance Capsules based on a ContextProfile (or Agreement-overridden suite).</p> <p>Steps: 1. Identify active <code>ContextProfile</code> based on src/dst environment. 2. Select the appropriate <code>ProtocolSuite</code> from Agreement (if CrossSpace). 3. Build envelope stack using <code>default_envelope_set</code>, applying:     - <code>UnlockEnvelope</code> if required by gating_policy.     - <code>SessionStateEnvelope</code> if <code>ShipSessionState</code>. 4. Pin <code>Agreement</code> and <code>ProtocolSuite</code> references. 5. Compute hash chain for envelope integrity.</p> <p>Output: a complete <code>DanceCapsule</code> ready for transport.</p>"},{"location":"core/capsulization/#32-capsulevalidator","title":"3.2 CapsuleValidator","text":"<p>Sequentially validates and unwraps envelopes according to the same ContextProfile or pinned ProtocolSuite.</p> <p>Steps: 1. Read <code>PinnedAgreement</code> / <code>NegotiatedSuite</code> (outermost layer). 2. Validate envelopes in declared order. 3. Invoke pluggable validators for each envelope type. 4. Rehydrate transient state if a <code>SessionStateEnvelope</code> is present. 5. Return the unwrapped <code>Dance</code> to the Choreographer.</p>"},{"location":"core/capsulization/#4-state-management-strategies","title":"4. State Management Strategies","text":""},{"location":"core/capsulization/#41-noshipping","title":"4.1 NoShipping","text":"<p>Use when: both ends share live memory context (e.g., TypeScript\u2194Rust). - Only references are passed; no state serialization. - All resolution occurs in host context.</p>"},{"location":"core/capsulization/#42-shipsessionstate","title":"4.2 ShipSessionState","text":"<p>Use when: the recipient is stateless (e.g., Rust Guest or remote Space). - Serialize the TransientHolonPool and NurseryRefs into a <code>SessionStateEnvelope</code>. - Validate integrity via content hash and policy (e.g., allowed reference types). - On receive, hydrate these pools in the callee\u2019s transient context.</p> <p>Holon Type: <code>SessionStateEnvelope</code> Relationships: <code>CarriesState \u2192 [TransientHolonPool, NurseryRefs]</code></p> <p>Validation rules: - <code>state_hash</code> must match computed digest. - Only whitelisted transient holon types may be shipped across a membrane. - State size thresholds enforced by policy.</p>"},{"location":"core/capsulization/#5-gating-and-step-up-policies","title":"5. Gating and Step-Up Policies","text":"<p>Each ContextProfile references a <code>StepUpPolicy</code>, which governs whether a local unlock is required.</p> <p>Triggers: - Dance sensitivity (Elevated | Critical) - Behavioral risk score \u2265 threshold - Explicit <code>require_step_up</code> flag from Agreement</p> <p>If triggered, an <code>UnlockEnvelope</code> is inserted before the Payload. The validator checks that the active Second Factor Session (SFS) is valid, unexpired, and not revoked.</p> <p>Holon Type: <code>UnlockEnvelope</code> Relationships: <code>VerifiedBy \u2192 StepUpPolicy</code></p>"},{"location":"core/capsulization/#6-agreement-overrides","title":"6. Agreement Overrides","text":"<p>Agreements can override ContextProfiles for cross-space interactions.</p> <p>Mechanism: - Agreement declares a <code>UsesContextProfile</code> relationship. - During capsule creation, the Trust Channel uses this Agreement-specific profile instead of the default one. - This allows different spaces to negotiate alternate envelope sets or state strategies.</p> <p>Example: <pre><code>Agreement \u2500\u2500UsesContextProfile\u2500\u2500\u25ba ContextProfile: secure-bridge-v2\nContextProfile.secure-bridge-v2:\n   EnvelopeStack: [Transport, AuthN, Crypto, AuthZ, Dispatch, Payload]\n   StateStrategy: NoShipping\n   StepUpPolicy: AlwaysRequire\n</code></pre></p>"},{"location":"core/capsulization/#7-session-state-envelope-flow-example","title":"7. Session State Envelope Flow Example","text":"<p>Rust Host \u2192 Rust Guest (stateless guest):</p> <p>DanceCapsule \u251c\u2500\u2500 UnlockEnvelope (if Sensitive or risky) \u2502   \u2514\u2500\u2500 SessionStateEnvelope \u2502       \u251c\u2500\u2500 CarriesState \u2192 TransientHolonPool \u2502       \u2514\u2500\u2500 Wraps \u2192 PayloadEnvelope \u2502           \u2514\u2500\u2500 HasPayloadDance \u2192 Dance \u2502               \u2514\u2500\u2500 HasRequest \u2192 LoaderHolonSegment</p> <p>Validation sequence: 1. UnlockEnvelope \u2192 verify SFS. 2. SessionStateEnvelope \u2192 validate state integrity. 3. PayloadEnvelope \u2192 execute Dance with hydrated transient context.</p>"},{"location":"core/capsulization/#8-state-resolution-rules","title":"8. State Resolution Rules","text":""},{"location":"core/capsulization/#81-transientholonpool","title":"8.1 TransientHolonPool","text":"<ul> <li>Contains staged holons awaiting persistence or relationship resolution.</li> <li>Used for Pass 1\u20132 data loader operations.</li> <li>Must not contain persistent identifiers or DHT addresses.</li> </ul>"},{"location":"core/capsulization/#82-nurseryrefs","title":"8.2 NurseryRefs","text":"<ul> <li>Lightweight handles for deferred relationship resolution.</li> <li>Hydrated during guest execution; discarded afterward.</li> </ul>"},{"location":"core/capsulization/#83-security-implications","title":"8.3 Security Implications","text":"<ul> <li>State shipping must respect Agreement-defined data-sharing limits.</li> <li>Certain value types (e.g., MapBytesValueType, MapIdValueType) may be redacted or masked when crossing membranes.</li> <li>Session state is never persisted; it expires at end of Dance execution.</li> </ul>"},{"location":"core/capsulization/#9-context-selection-logic","title":"9. Context Selection Logic","text":"<p>Algorithm for capsuleization: 1. Determine context (TS\u2192Rust, Host\u2192Guest, Space\u2194Space). 2. Load corresponding ContextProfile. 3. If Agreement present:     - Override profile with Agreement\u2019s <code>UsesContextProfile</code> if specified.     - Use <code>ProtocolSuite</code> from Agreement to determine final envelope set. 4. Apply gating_policy \u2192 insert UnlockEnvelope if required. 5. Apply state_strategy \u2192 add SessionStateEnvelope if needed. 6. Assemble and send capsule.</p> <p>This algorithm ensures capsuleization is adaptive, not static \u2014 matching security, performance, and state requirements to context.</p>"},{"location":"core/capsulization/#10-summary","title":"10. Summary","text":"<p>Context-aware capsuleization allows MAP to: - Optimize in-process Dances (minimal envelopes, no overhead). - Support stateless guests via controlled state shipping. - Enforce Agreement-defined envelope sequences for cross-space trust. - Dynamically add authentication layers when sensitivity or behavioral risk warrants it.</p> <p>By encoding these strategies as holons (<code>ContextProfile</code>, <code>StateStrategy</code>, <code>StepUpPolicy</code>), capsule formation and validation remain fully data-driven, extensible, and discoverable \u2014 consistent with MAP\u2019s self-describing architecture.</p>"},{"location":"core/connect-design/","title":"MAP Connect Dashboards: Early Design Sketches","text":"<p>\ud83d\udea7 Draft for discussion \u2014 not final. Intended to seed design conversations among MAP Core developers.</p>"},{"location":"core/connect-design/#1-connect-dashboard-offer-centric","title":"1. Connect Dashboard (Offer-Centric)","text":"<p>The primary dashboard shows aggregate data on my Offers and inbound Offers. It surfaces both state counts and actionable prompts.</p>"},{"location":"core/connect-design/#lifecycle-flow","title":"Lifecycle Flow","text":"<ul> <li>Drafts \u2014 Offers not yet placed in a Space (parked, not visible).</li> <li>Active Offers \u2014 visible in a Space, subdivided by matching state:<ul> <li>Under-constrained \u2192 too many matches; suggests requirements to add.</li> <li>Over-constrained \u2192 too few/none; suggests requirements to relax.</li> <li>Waiting for My Responses \u2192 unknowns I must answer.</li> <li>Waiting on Others \u2192 unknowns others must answer.</li> <li>Healthy Fit \u2192 matches in desired range but below Agreement threshold.</li> </ul> </li> <li>Agreement Phase \u2192 matches \u2265 Agreement Phase Threshold; ready to reveal identity and negotiate.</li> <li>Agreed / Closed \u2192 historical Offers (archived for reference).</li> </ul>"},{"location":"core/connect-design/#dashboard-interactions","title":"Dashboard Interactions","text":"<ul> <li>Click a header (e.g. \u201cOver-constrained\u201d):<ul> <li>Reveals Top 3 prompts relevant to that state.<ul> <li>For \u201cOver-constrained\u201d: top 3 requirements to consider relaxing.</li> <li>For \u201cWaiting for My Responses\u201d: top missing promises I\u2019m asked to make.</li> </ul> </li> </ul> </li> <li>Click a number (e.g. \u201c7 Over-constrained Offers\u201d):<ul> <li>Opens a Collection View of Offer Cards in that state.</li> <li>From there, I can drill into any card\u2019s Feedback Panel.</li> </ul> </li> </ul>"},{"location":"core/connect-design/#2-collection-view","title":"2. Collection View","text":"<p>Displays a grid or list of Offer Cards.</p> <p>Offer Card Preview - Title &amp; context (e.g. Service Offer, Join Offer, Space). - Status chips: \u2715 Mismatches | ? Unknowns | \u25d4 Possibles | \u2705 Matches. - Click \u2192 opens Feedback Panel.</p>"},{"location":"core/connect-design/#3-feedback-panel-card-drill-down","title":"3. Feedback Panel (Card Drill-Down)","text":"<p>When I drill into a specific Offer Card:</p> <ul> <li> <p>Status Strip</p> <ul> <li>Counts for \u2715 mismatches, ? unknowns, \u25d4 possibles, \u2705 matches.</li> </ul> </li> <li> <p>Unlocking Promises (ranked)</p> <ul> <li>Promises I could make to unlock the most matches.</li> <li>Each shows projected gain (e.g. \u201cAdd Value: Regeneration \u2192 +8 matches\u201d).</li> <li>Actions: Answer, Learn More (link to Meme Pool definition).</li> </ul> </li> <li> <p>Blocking Requirements (ranked)</p> <ul> <li>Requirements I imposed that are over-constraining.</li> <li>Each shows projected gain if relaxed (e.g. \u201cRelax Age \u2265 18 to 16 \u2192 +3 matches\u201d).</li> <li>Actions: Adjust / Relax.</li> </ul> </li> <li> <p>Next Actions</p> <ul> <li>Propose Agreement (if matches are in range).</li> <li>Reveal Identity / Open Negotiation (Agreement Phase).</li> <li>Withdraw Offer.</li> </ul> </li> <li> <p>Notifications (Sense)</p> <ul> <li>Toggle: \u201cNotify me when this Offer reaches Agreement Phase / gains new matches / gets blocked.\u201d</li> </ul> </li> </ul>"},{"location":"core/connect-design/#4-resonance-engine-dashboard-promise-centric","title":"4. Resonance Engine Dashboard (Promise-Centric)","text":"<p>A complementary dashboard for sense-making into a Space. Instead of Offers, it organizes around Promises themselves.</p>"},{"location":"core/connect-design/#what-it-surfaces","title":"What it surfaces","text":"<ul> <li>Top Resonant Promises \u2014 promises most frequently included in offers in this space.</li> <li>Aspirational Gaps \u2014 promises often required in offers but rarely present in members\u2019 LifeCodes.</li> <li>Cultural Climate Heatmap \u2014 % of members aligned with key promises (values, principles).</li> <li>Growth Prompts \u2014 promises I\u2019m being nudged to consider adding to my LifeCode to unlock more connections.</li> </ul>"},{"location":"core/connect-design/#why-it-matters","title":"Why it matters","text":"<ul> <li>Lets individuals see where they resonate with the culture of a space.</li> <li>Lets spaces see where alignment is strong or thin, and adapt over time.</li> <li>Complements the Offer-centric dashboard by showing the memetic layer of connection.</li> </ul>"},{"location":"core/connect-design/#5-design-notes","title":"5. Design Notes","text":"<ul> <li>States are mutually exclusive and clear: Draft \u2192 Active (with sub-status) \u2192 Agreement Phase \u2192 Closed.</li> <li>Top 3 prompts ensure dashboards surface actionable insights, not just numbers.</li> <li>Cross-cutting pivots: Clicking any Promise or Requirement shows both its definition (link to Meme Pool) and the collection of Offers it affects.</li> <li>Threshold awareness: Agreement Phase Threshold is explicit; exceeding it unlocks negotiation tools.</li> <li>Privacy posture: Spaces see only alignment signals; only I see my private answers.</li> </ul> <p>\ud83d\udc49 Next steps: - Align on visual language (chips, icons, color coding). - Decide whether the Resonance Engine Dashboard is part of Connect or a separate DAHN module. - Prototype the funnel dashboard + feedback flows in low-fidelity wireframes.  </p>"},{"location":"core/dances-design/","title":"MAP Design Spec: Dance Types, Implementation &amp; Dispatch","text":"<p>Status: Draft Author: MAP Core / Steve Melville Intent: Specify how types declare dances, how implementations are bound, and how the host dispatches calls safely and dynamically.   Scope: Type system extensions, import format, governance/validation, runtime dispatch, security, caching, and compatibility with existing MAP/Holochain patterns.  </p>"},{"location":"core/dances-design/#0-foundations-assumptions","title":"0) Foundations &amp; Assumptions","text":"<ol> <li> <p>Self\u2011describing types</p> <ul> <li>All MAP types are holons described by TypeDescriptor holons.</li> <li><code>InstanceProperties</code> and <code>InstanceRelationships</code> declare expectations for instances.</li> <li>The metaschema already supports declaring new PropertyTypes and RelationshipTypes.</li> </ul> </li> <li> <p>Holon identity &amp; immutability</p> <ul> <li>Instances are immutable; newer versions create new holons.</li> <li>References are stable and do not \u201cgo stale\u201d; caches can safely retain instances until memory pressure requires eviction.</li> </ul> </li> <li> <p>Import format conventions</p> <ul> <li>Holon JSON import files use the unified <code>holons</code> array, with relationships and properties defined on each holon.</li> <li><code>$ref</code> resolution is strict within the provided file set (no implicit global context).</li> <li><code>key</code> MUST appear before <code>type</code> in each holon definition.</li> <li><code>type</code> is shorthand for a <code>DescribedBy</code> relationship and should not be duplicated unless rules require exact match.</li> </ul> </li> <li> <p>Key rules</p> <ul> <li>Some holons are keyed, some are keyless, per existing KeyRuleType semantics.</li> <li>Enum Variant holons are keyed and top-level (not embedded).</li> </ul> </li> <li> <p>Governance membranes</p> <ul> <li>Spaces (I\u2011Spaces / We\u2011Spaces) enforce admission, attestation, and activation policies for new descriptors and modules.</li> <li>Provenance and attestations are recorded as holons and/or signatures on content hashes.</li> </ul> </li> <li> <p>Runtime execution</p> <ul> <li>Host supports WASM/WASI execution and may optionally support:<ul> <li>Process (spawned executable with stream protocol),</li> <li>Rust dylib (FFI with stable ABI),</li> <li>Builtin (host-registered functions).</li> </ul> </li> <li>Single-threaded isolation for WASM execution is assumed.</li> <li>Modules are addressed by content hash and may be fetched via membrane-authorized channels.</li> </ul> </li> </ol>"},{"location":"core/dances-design/#1-conceptual-model","title":"1) Conceptual Model","text":"<p>At its heart, the MAP type system implements a dynamic dispatch model in which every type \u2014 not just <code>HolonType</code> \u2014 can advertise the behaviors it supports via fine-grained dispatch tables. These tables are essentially the per-type registries of \u201cwhat this type can do,\u201d expressed as relationships from the type descriptor to a set of DanceTypes.</p> <p>In our new terminology, we\u2019re formalizing this as:</p> <pre><code>&lt;TypeDescriptor&gt; \u2014AFFORDS\u2192 &lt;DanceType&gt;\n</code></pre>"},{"location":"core/dances-design/#dynamic-dispatch-tables","title":"Dynamic Dispatch Tables","text":"<ul> <li> <p>One per type:   Every <code>TypeDescriptor</code> can have its own dispatch table \u2014 a set of <code>Affords</code> relationships that point to the <code>DanceType</code>s it supports. This allows dispatch to be as fine-grained as needed: even closely related types can differ in the set of dances they afford.</p> </li> <li> <p>Any type can afford dances:   We don\u2019t limit affordances to <code>HolonType</code>s. <code>ValueType</code>s, <code>RelationshipType</code>s, even <code>DanceType</code>s themselves can have <code>Affords</code> links to other dances, enabling compositional and meta-level behaviors.</p> </li> <li> <p>Behavior resolution:   When the system receives a <code>DanceRequest</code> for a specific target, the dispatch mechanism:</p> <ol> <li>Identifies the type of the target holon.</li> <li>Looks up that type\u2019s <code>Affords</code> relationships.</li> <li>Matches the requested dance against the list.</li> <li>Routes execution to the handler bound to that dance for this type.</li> </ol> </li> </ul>"},{"location":"core/dances-design/#affordances-as-first-class-relationships","title":"Affordances as First-Class Relationships","text":"<ul> <li><code>Affords</code> is itself a RelationshipType holon (like all type descriptors in MAP).</li> <li>Concrete instances of <code>Affords</code> are smartlinks between a type and a dance type.</li> <li>Because <code>Affords</code> is part of the schema, it can carry metadata \u2014 version constraints, capability conditions, or even parameter hints \u2014 making affordances declarative, inspectable, and extensible.</li> </ul>"},{"location":"core/dances-design/#why-this-matters","title":"Why This Matters","text":"<ul> <li>Granularity: Instead of large, monolithic capability declarations, we get fine-grained, composable affordances that can evolve per type.</li> <li>Flexibility: Adding a new dance is a matter of creating a <code>DanceType</code> and linking it via <code>Affords</code>; no core code needs changing for schema-driven dispatch.</li> <li>Uniformity: All affordances are modeled the same way, whether they\u2019re about creating a holon, validating a property, or triggering a real-world workflow.</li> <li>Extensibility: The dispatch model is naturally open to extension in downstream schemas or spaces without schema rewrites \u2014 just add new <code>Affords</code> links.</li> </ul>"},{"location":"core/dances-design/#2-newupdated-descriptors-relationships","title":"2) New/Updated Descriptors &amp; Relationships","text":""},{"location":"core/dances-design/#21-descriptors","title":"2.1 Descriptors","text":"<ul> <li> <p>DanceType (HolonType, abstract)   The DanceType defines the interface for a single dance. This includes the dance name (by convention, this should be a verb) (e.g., <code>Render</code>, <code>Validate</code>, <code>SyncOut</code>).</p> <ul> <li>Properties (examples): <code>display_name</code>, <code>description</code>, <code>abi_id</code> (optional if polymorphic).</li> <li>Relationships:</li> <li><code>Request</code> -- to a HolonType that bundles the input parameters to the DanceRequest. </li> </ul> </li> <li> <p>DanceImplementation (Holon)   A concrete binding of a <code>DanceType</code> for a specific <code>TypeDescriptor</code>.</p> <ul> <li>Properties (required unless noted):<ul> <li><code>Engine</code> (Enum): <code>WasmWasi</code> | <code>Process</code> | <code>RustDylib</code> | <code>Builtin</code></li> <li><code>ModuleRef</code> (String): content address (e.g., <code>b3:\u2026</code> multihash, URL with hash, capability address)</li> <li><code>Entrypoint</code> (String): export/function name (WASM symbol, FFI symbol, command name)</li> <li><code>ABI</code> (String): stable ABI signature id the host supports (e.g., <code>map.dance.v1</code>)</li> <li><code>Version</code> (String): semver or content-hash pin</li> <li><code>CompatRange</code> (String, optional): semver range allowed</li> <li><code>ActivationStatus</code> (Enum): <code>proposed</code> | <code>active</code> | <code>disabled</code></li> <li><code>Scope</code> (Enum): <code>Builtin</code> | <code>SchemaDefault</code> | <code>SpaceOverride</code></li> <li><code>ModuleHash</code> (String): cryptographic hash of the content (if not implicit in ModuleRef)</li> </ul> </li> <li>Relationships:</li> <li><code>DanceType</code>-&gt;DanceType -- The Dance being implemented.</li> <li><code>AffordingType</code>-&gt; TypeDescriptor (?) the type on whose behalf this dance is being implemented</li> </ul> </li> <li> <p>(optional) DanceParameterSchema (Holon)   Describes structured inputs/outputs for ABI validation.</p> </li> </ul>"},{"location":"core/dances-design/#22-relationships","title":"2.2 Relationships","text":"<ul> <li> <p>Affords (DeclaredRelationshipType) <code>(TypeDescriptor) -[Affords]-&gt; (DanceType)</code>   Declares that instances of the type afford/expose the dance.</p> </li> <li> <p>ImplementsDance (DeclaredRelationshipType) <code>(TypeDescriptor) -[ImplementsDance]-&gt; (DanceImplementation)</code>   Binds concrete implementations available to the dispatcher.</p> </li> <li> <p>ForDance (DeclaredRelationshipType) <code>(DanceImplementation) -[ForDance]-&gt; (DanceType)</code>   The interface this implementation satisfies.</p> </li> <li> <p>(optional) ParametersSchema (DeclaredRelationshipType) <code>(DanceType) -[ParametersSchema]-&gt; (DanceParameterSchema)</code></p> </li> </ul> <p>All descriptors follow the foundational rule: <code>type: \"#TypeDescriptor\"</code> with <code>Extends</code> pointing at the appropriate meta-type, and they adopt MAP import conventions (key before type, unified relationships block, etc.).</p>"},{"location":"core/dances-design/#3-import-file-additions-examples-illustrative","title":"3) Import File Additions &amp; Examples (Illustrative)","text":"<p>Note: Examples are schematic and omit boilerplate. Use your established keys/type shorthands and naming patterns. (No code fences here; the following is raw markdown text with indentation.)</p> <p>Example A: Declaring a DanceType and parameter schema - key: <code>Render.DanceType</code> - type: <code>#DanceType</code> - properties: <code>display_name=\"Render\"</code>, <code>description=\"Produce a representation\"</code> - relationships: <code>ParametersSchema -&gt; #Render.Params.Schema</code> (optional)</p> <p>Example B: A TypeDescriptor that supports and implements a dance - key: <code>BookType.TypeDescriptor</code> - type: <code>#TypeDescriptor</code> - relationships:     - <code>Affords -&gt; #Render.DanceType</code>     - <code>ImplementsDance -&gt; #BookType.Render.WasmImpl</code> (below)</p> <p>Example C: A DanceImplementation bound to <code>BookType</code> for <code>Render</code> - key: <code>BookType.Render.WasmImpl</code> - type: <code>#DanceImplementation</code> - properties:     - <code>Engine=\"WasmWasi\"</code>     - <code>ModuleRef=\"b3hash:Qm...\"</code>     - <code>Entrypoint=\"render_book\"</code>     - <code>ABI=\"map.dance.v1\"</code>     - <code>Version=\"1.2.0\"</code>     - <code>CompatRange=\"^1.0.0\"</code>     - <code>ActivationStatus=\"active\"</code>     - <code>Scope=\"SchemaDefault\"</code>     - <code>ModuleHash=\"sha256:abcd...\"</code> - relationships:     - <code>ForDance -&gt; #Render.DanceType</code></p> <p>Space-scoped override A We\u2011Space can introduce a second implementation with <code>Scope=\"SpaceOverride\"</code> and <code>ActivationStatus=\"active\"</code>. Resolution rules (Section 5) ensure overrides take precedence without mutating the schema default.</p>"},{"location":"core/dances-design/#4-abi-application-binary-interface","title":"4) ABI (Application Binary Interface)","text":""},{"location":"core/dances-design/#41-goals","title":"4.1 Goals","text":"<ul> <li>Stable contract between host and implementation irrespective of engine.</li> <li>Enable content-addressed modules to be swapped/upgraded safely.</li> <li>Keep functions stateless and deterministic (inputs \u2192 outputs), with side effects routed through explicit host calls (capability-gated).</li> </ul>"},{"location":"core/dances-design/#42-core-shape-mapdancev1","title":"4.2 Core shape (<code>map.dance.v1</code>)","text":"<ul> <li>Inputs<ul> <li><code>dance_type_id</code> (ref)</li> <li><code>type_descriptor_id</code> (ref)</li> <li><code>instance_refs</code> (list of holon ids or $ref proxies)</li> <li><code>parameters</code> (bytes or canonical JSON/CBOR)</li> <li><code>context</code> (agent id, space id, capability token, call chain, clock)</li> </ul> </li> <li>Outputs<ul> <li><code>status</code> (OK | Error(code))</li> <li><code>result</code> (bytes or canonical JSON/CBOR)</li> <li><code>emitted_events</code> (optional; for telemetry)</li> </ul> </li> <li>Host imports<ul> <li><code>holon_fetch(id)</code> \u2192 bytes</li> <li><code>relationship_query(query)</code> \u2192 ids</li> <li><code>attest(proof)</code> \u2192 receipt</li> <li><code>emit(event)</code> \u2192 ack</li> <li>(All host functions are capability-gated and audited.)</li> </ul> </li> </ul>"},{"location":"core/dances-design/#43-serialization-determinism","title":"4.3 Serialization &amp; determinism","text":"<ul> <li>Canonical encoding (CBOR or JSON Canonical Form).</li> <li>No host clock access except via provided <code>context</code>.</li> <li>No ambient I/O except via host-imported capabilities.</li> </ul>"},{"location":"core/dances-design/#5-dispatch-algorithm-host","title":"5) Dispatch Algorithm (Host)","text":"<p>Given a request <code>(T, D, ctx)</code>:</p> <ol> <li>Affordance check: Ensure <code>T Affords D</code>; otherwise fail with <code>NotSupported(T,D)</code>.</li> <li>Collect candidates: <code>C = { impl | T ImplementsDance impl \u2227 impl ForDance = D \u2227 impl ActivationStatus=active }</code>.</li> <li>Select binding (deterministic precedence):<ul> <li>Prefer <code>Scope=\"SpaceOverride\"</code> in <code>ctx.space</code> &gt; <code>SchemaDefault</code> &gt; <code>Builtin</code>.</li> <li>Prefer exact <code>Version</code> pin &gt; satisfied <code>CompatRange</code> &gt; latest compatible by semver.</li> <li>Optional: apply policy filter (agent role, license/flowshare rules, allowlist).</li> <li>If multiple remain, choose lexicographically by <code>(Version, ModuleHash)</code> or policy-defined tiebreaker.</li> </ul> </li> <li>Load &amp; cache:<ul> <li>Fetch module by <code>ModuleRef</code> (verify <code>ModuleHash</code>, signatures, provenance).</li> <li>Instantiate per engine; reuse cached instance if ABI/spec allows (see lifecycle).</li> </ul> </li> <li>Invoke:<ul> <li>Marshal inputs to ABI.</li> <li>Call <code>Entrypoint</code>.</li> <li>Enforce time/memory fuel limits and capability quotas.</li> </ul> </li> <li>Validate &amp; return:<ul> <li>Check ABI contract on outputs.</li> <li>Apply membrane \u201cexfiltration filter\u201d (response validation &amp; redaction as promised).</li> <li>Return <code>DanceResponse</code>.</li> </ul> </li> </ol> <p>Error handling: Produce structured errors: <code>NotSupported</code>, <code>NoActiveImpl</code>, <code>ABIIncompatible</code>, <code>ModuleFetchFailed</code>, <code>SignatureInvalid</code>, <code>PolicyDenied</code>, <code>EngineError</code>, <code>Timeout</code>, <code>MemoryLimit</code>, <code>ResultValidationFailed</code>.</p>"},{"location":"core/dances-design/#6-module-lifecycle-caching-eviction","title":"6) Module Lifecycle, Caching, Eviction","text":"<ul> <li>Cache keys: <code>(Engine, ModuleHash, ABI)</code>; instance-specific caches may include <code>(SpaceId)</code> when overrides alter host imports.</li> <li>Warm: LRU or LFU for frequently used modules; prewarm on activation if policy allows.</li> <li>Evict: Under memory pressure, evict least-recently-used; keep provenance index regardless.</li> <li>Isolation: WASM instances single-threaded; no shared mutable state across invocations.</li> <li>Pure-function posture: Dances are stateless; all state arrives as inputs or accessed through explicit host capabilities.</li> </ul>"},{"location":"core/dances-design/#7-governance-licensing-and-flowshare-hooks","title":"7) Governance, Licensing, and Flowshare Hooks","text":"<ul> <li> <p>Activation workflow:</p> <ul> <li>A <code>DanceImplementation</code> arrives with <code>ActivationStatus=\"proposed\"</code>.</li> <li>Membrane policy may require two-key attest (Steward of <code>T</code> + Space Admin) and automated checks (hash, signature, license).</li> <li>On success, flip to <code>active</code> (space-scoped or schema default).</li> </ul> </li> <li> <p>Flowshare attachment:</p> <ul> <li>Implementations/Types may declare a ValueFlowPolicy holon that expresses revenue/reciprocity terms (e.g., non-extractive use-permitted; reciprocal flowshare when vital capitals exchanged).</li> <li>Dispatcher records <code>(T, D, impl_id)</code> in telemetry for downstream settlement.</li> </ul> </li> <li> <p>Non-extractive licensing posture:</p> <ul> <li>Free use in non-commercial/gift contexts remains unaffected.</li> <li>When reciprocal value flows are detected (per policy integration), contributors participate according to warrants/agreements.</li> </ul> </li> </ul>"},{"location":"core/dances-design/#8-validation-rules-import-time-and-activation-time","title":"8) Validation Rules (Import-time and Activation-time)","text":"<p>Import-time (schema-level) - <code>supports-impl-consistency</code>: If <code>(T ImplementsDance impl)</code> then <code>(impl ForDance) \u2208 (T Affords)</code>. Error otherwise. - <code>single-active-impl</code>: For each <code>(T, D, scope)</code>, at most one <code>ActivationStatus=\"active\"</code>. Error otherwise. - <code>engine-fields-required</code>: Property presence by engine:     - <code>WasmWasi</code> \u21d2 <code>ModuleRef</code>, <code>Entrypoint</code>, <code>ABI</code>     - <code>Process</code> \u21d2 <code>ModuleRef</code>, <code>ABI</code> (and <code>Entrypoint</code> if multiplexed)     - <code>RustDylib</code> \u21d2 <code>ModuleRef</code>, <code>Entrypoint</code>, <code>ABI</code>     - <code>Builtin</code> \u21d2 <code>Entrypoint</code>, <code>ABI</code> - <code>instance-type-kind-matches-extended-meta-type-name</code>: Continue enforcing your existing meta/type-kind rules.</p> <p>Activation-time (runtime policy) - <code>abi-compat</code>: <code>impl.ABI</code> supported by host. - <code>module-integrity</code>: <code>ModuleHash</code> matches fetched bytes; signatures and attestations verified. - <code>policy-eligibility</code>: Space policy permits activation (governance roles, allowlists, flowshare acceptance). - <code>parameters-schema-match</code> (optional): <code>parameters</code> conform to <code>DanceParameterSchema</code>.</p>"},{"location":"core/dances-design/#9-security-provenance-and-audit","title":"9) Security, Provenance, and Audit","text":"<ul> <li>Content addressing: <code>ModuleRef</code> and <code>ModuleHash</code> cryptographically bind code identity.</li> <li>Signatures: Contributors sign module manifests; Spaces countersign activation.</li> <li>Reproducibility: Prefer reproducible builds; include build-info holon.</li> <li>Supply chain: Maintain provenance graph from source \u2192 build \u2192 artifact; store as holons.</li> <li>Audit trail: Every dispatch logs <code>(timestamp, agent, space, T, D, impl_id, module_hash, status, duration, fuel_used)</code>.</li> </ul>"},{"location":"core/dances-design/#10-engines-host-integrations","title":"10) Engines &amp; Host Integrations","text":"<ul> <li> <p>WASM/WASI (preferred):</p> <ul> <li>Deterministic execution with resource caps (fuel, memory).</li> <li>Host imports expose capability-guarded functions.</li> <li>Versioned ABI adapters <code>map.dance.v1</code>, <code>v2</code>, \u2026 allow evolution.</li> </ul> </li> <li> <p>Process:</p> <ul> <li>IPC over stdin/stdout with canonical envelope.</li> <li>Strong isolation; higher overhead.</li> </ul> </li> <li> <p>Rust dylib:</p> <ul> <li>Stable FFI surface identical to ABI envelope.</li> <li>Platform coupling; reserved for controlled deployments.</li> </ul> </li> <li> <p>Builtin:</p> <ul> <li>Registered host handlers for critical hot paths.</li> <li>Still declared as <code>DanceImplementation</code> with <code>Scope=\"Builtin\"</code> for traceability.</li> </ul> </li> </ul>"},{"location":"core/dances-design/#11-performance-considerations","title":"11) Performance Considerations","text":"<ul> <li>Cold-start: Prewarm frequently-used <code>(T,D)</code> in background when allowed by policy.</li> <li>Batching: Allow vectorized invocation (<code>Render</code> for many instances) when ABI supports arrays.</li> <li>Streaming: Optional chunked results for large outputs (with exfiltration filter applied per chunk).</li> <li>Caching: Separate caches for (a) holons (state), (b) modules (code), (c) relationships (indices).</li> </ul>"},{"location":"core/dances-design/#12-compatibility-migration","title":"12) Compatibility &amp; Migration","text":"<ul> <li> <p>Holochain conductor:</p> <ul> <li>Aligns with zome WASM loading (single-threaded WASM, dynamic dispatch).</li> <li>This spec generalizes beyond zomes by attaching behavior to any TypeDescriptor.</li> </ul> </li> <li> <p>Incremental rollout:     1) Introduce descriptors/relationships with validators, no runtime usage.     2) Implement host-side dispatcher with <code>WasmWasi</code> only.     3) Add governance activation path and telemetry.     4) Add overrides (<code>SpaceOverride</code>) and precedence rules.     5) (Optional) Add <code>Process</code>/<code>RustDylib</code> engines.</p> </li> </ul>"},{"location":"core/dances-design/#13-open-questions","title":"13) Open Questions","text":"<ul> <li>ABI evolution: Which fields must be strictly stable vs. adapter-shimmed?</li> <li>Parameter schemas: Standardize on JSON Schema vs. ValueType holons?</li> <li>Multi-impl composition: Should a dance support ordered pipelines/compose-many?</li> <li>Sandbox capability surface: Minimum viable host imports per dance category?</li> <li>Flowshare metering: Best trigger points to detect \u201creciprocal value\u201d reliably and fairly?</li> </ul>"},{"location":"core/dances-design/#14-acceptance-criteria","title":"14) Acceptance Criteria","text":"<ul> <li>Types can declare <code>Affords</code> and bind one or more <code>DanceImplementation</code>s.</li> <li>Host can resolve <code>(T,D)</code> to an active implementation deterministically and execute it through <code>map.dance.v1</code> ABI.</li> <li>Import-time validators catch misconfigurations; activation-time checks enforce integrity and policy.</li> <li>Telemetry records every dispatch with provenance, enabling governance and (optional) flowshare settlement.</li> </ul>"},{"location":"core/dances-design/#15-risks-mitigations","title":"15) Risks &amp; Mitigations","text":"<ul> <li>Complexity creep \u2192 Keep dispatcher minimal; push variability to data + ABI.</li> <li>Security of third-party code \u2192 Content hashing, signatures, sandboxing, capability gates, resource caps.</li> <li>Version skew \u2192 Semantic ranges with explicit pins; strong precedence rules; safe fallbacks.</li> <li>Memory growth \u2192 LRU/LFU eviction, per-engine instance pooling, prewarm limits.</li> </ul>"},{"location":"core/dances-design/#16-next-steps","title":"16) Next Steps","text":"<ol> <li>Add new descriptors and relationships to the metaschema &amp; base-core import files.</li> <li>Implement import-time validation rules listed above.</li> <li>Define <code>map.dance.v1</code> ABI envelope precisely (field names, encoding, error codes).</li> <li>Build the host dispatcher (WASM/WASI path first) + module cache.</li> <li>Implement governance activation flows and attest capture.</li> <li>Instrument telemetry and add audit holons.</li> <li>Ship example: <code>BookType</code> with <code>Render</code> dance (schema default) and a Space-scoped override.</li> </ol>"},{"location":"core/holon-data-loader-design-spec/","title":"MAP Holon Data Loader Design Specification (Updated)","text":"<p>The Holon Data Loader will convert holon data presented in JSON files into Holons and HolonRelationships that are staged and committed to a (single) MAP Space using existing MAP APIs. Because all MAP types (e.g., PropertyType, HolonType, RelationshipType) are themselves holons, the Holon Data Loader can be used to load TypeDescriptors just like any other data \u2014 eliminating the need for a separate type-specific loader. Input files are syntactically validated against a JSON Schema to ensure they represent well-formed holons, properties, relationships and, eventually, dances.</p> <p>Validation of imported holons and their properties and relationships against their Type Descriptors is triggered by standard Holochain validation callbacks. These callback functions, implemented in the <code>holons_integrity_zome</code> invoke shared validation functions to actually perform the validations. All Holochain dependencies are isolated in the integrity zome so that the shared validation functions have no holochain dependencies.</p> <p>If the target space does not already contain all required TypeDescriptors (e.g., BookType, title, HAS_AUTHOR), they must be included as part of the import and loaded first. Since we do not yet have deployed instances of the MAP that persist data, all types and data required for an integration Test Case must be loaded as part of the test case itself. This includes importing the MAP Schema. Thus, the test case initialization includes the following steps:</p> <ol> <li>Import MAP Meta-Schema</li> <li>Import MAP Core Schema</li> <li>Import Domain-Specific Type Descriptors (if any)</li> <li>Import Domain-Specific Data (if any)</li> </ol> <p>All four test steps use the same Holon Data Loader. Each step imports the type descriptors needed to validate the data imported in the subsequent step.</p>"},{"location":"core/holon-data-loader-design-spec/#process-overview","title":"\ud83e\udde9 Process Overview","text":"<p>The following diagram shows the Holon Data Loading process.</p> <p></p>"},{"location":"core/holon-data-loader-design-spec/#step-by-step-map-holon-data-loader-flow","title":"\ud83e\udded Step-by-Step: MAP Holon Data Loader Flow","text":"<ol> <li> <p>Define Holons in Airtable -- For now, we are using Airtable as our source of truth for data imports. A user or domain expert defines holons, properties, and relationships as rows in a spreadsheet-like interface. NOTE: This is just one option \u2014 other JSON generation methods are possible.</p> </li> <li> <p>Export CSV from Airtable -- Airtable exports the holon definitions into a CSV file, which contains structured tabular data for each holon, including properties, types, and relationships.</p> </li> <li> <p>Convert CSV to JSON -- A Jupyter Notebook (written in Python) loads the CSV file and uses the MAP Holon JSON Generator to transform the rows into JSON-formatted Holon Definitions. These definitions conform to the MAP Holon Data Loader's expected schema.</p> </li> <li> <p>Run the JSON Schema Validator -- Before loading, the generated JSON input file is validated using a JSON Schema Validator. This ensures that the file:</p> </li> <li>Is structurally valid</li> <li>Uses valid type names and relationship formats</li> </ol> <p>The validated file represents well-formed Holons, Properties, and Relationships.</p> <ol> <li> <p>Parse and Prepare Holons  -- The validated JSON is parsed into in-memory data structures. The Holon Generator builds internal <code>HolonImportSpec</code> structs from the parsed data.</p> </li> <li> <p>Invoke the Holon Data Loader -- The Holon Generator passes the structured holon definitions to the Holon Data Loader, a Rust crate. This loader:</p> </li> <li>Handles all staging and relationship resolution</li> <li> <p>Works for both instance data and TypeDescriptors</p> </li> <li> <p>(Optional) Other Data Loaders -- Other data loaders may bypass JSON entirely and produce Rust-structured holon definitions directly. These are also accepted by the Holon Data Loader pipeline.</p> </li> <li> <p>Stage Holons -- The loader performs Pass 1, where each holon is:</p> </li> <li>Assigned a local ID or temp key</li> <li>Validated for syntactic structure</li> <li> <p>Staged with its properties only (relationships deferred)</p> </li> <li> <p>Stage Relationships -- The loader performs Pass 2, resolving all deferred relationships:</p> </li> <li>References to staged holons use <code>temp_key</code></li> <li>References to saved holons use keys or HolonIds</li> <li> <p>External references resolve via space proxies</p> </li> <li> <p>Commit Holons -- All staged holons are committed into the MAP space via the <code>holons_core</code> crate. This action triggers holochain\u2019s commit lifecycle.</p> </li> <li> <p>Trigger Validation -- As part of the commit, the Holochain Conductor invokes validation actions. These hit the HolonNode Validation Hooks in the <code>holons_integrity_zome</code>. The implementation of these hook functions converts the data into \"holochain-independent\" data structures in order to invoke the shared validation functions.</p> </li> <li> <p>Run Shared Validation Logic The hooks delegate to the Shared Holons Validator, which contains:</p> </li> <li>Validation against TypeDescriptors</li> <li>Enforcement of required properties and cardinalities</li> <li>No direct Holochain dependencies \u2014 enabling reuse of these validations from holons_core without pulling in holochain and its dependencies.</li> </ol>"},{"location":"core/holon-data-loader-design-spec/#design-philosophy","title":"\ud83e\udde0 Design Philosophy","text":"Principle Description Holonic Uniformity Everything \u2014 including types \u2014 is a holon Self-Describing Types The <code>type</code> and <code>key</code> fields provide identity and classification Declarative Imports Inverse relationships and embedded holons may be expressed naturally Keyed Reference Integrity Only keyed holons may be targeted by <code>$ref</code> Two-Pass Import Enables circular references and loose ordering in authoring Minimal, Consistent Format Supports both human authoring and automated generation"},{"location":"core/holon-data-loader-design-spec/#keyed-vs-keyless-holons","title":"\ud83d\udccc Keyed vs Keyless Holons","text":"<p>MAP distinguishes two structural categories of holons:</p> Feature Keyed Holons Keyless Holons Includes <code>key</code> \u2705 Yes \u274c No Unique within space \u2705 Yes \u274c Not applicable Can be referenced via <code>$ref</code> \u2705 Yes \u274c No Must be embedded in JSON \u274c Optional \u2705 Required Can be target of declared relationship \u2705 Yes \u274c No Must declare outgoing relationship to keyed holon \u274c Optional \u2705 Required <ul> <li>Keyed holons include a stable <code>key</code> (materialized from properties) and may be referenced by other holons via <code>$ref</code>.</li> <li>Keyless holons are contextual and must be embedded as part of another holon\u2019s relationship. They must not be referenced or stand alone.</li> </ul> <p>This pattern ensures clean graph semantics, staging integrity, and simplicity for authors.</p>"},{"location":"core/holon-data-loader-design-spec/#declared-vs-inverse-relationships-in-json","title":"\ud83d\udd01 Declared vs Inverse Relationships in JSON","text":"<p>MAP represents both Declared and Inverse relationships using SmartLinks, but only Declared Relationships are:</p> <ul> <li>Explicitly defined in schemas</li> <li>Directly populated and persisted</li> </ul> <p>Inverse Relationships are: - Inferred by the system - Automatically maintained as mirrors of their declared counterparts - Not directly writable in the storage layer</p>"},{"location":"core/holon-data-loader-design-spec/#ergonomic-authoring-support","title":"\u2728 Ergonomic Authoring Support","text":"<p>To improve JSON authoring, the Holon Data Loader supports:</p> <p>\u2705 Expressing inverse relationships in JSON \u2014 which are then automatically rewritten into their declared equivalents before staging</p> <p>For example, a JSON snippet like:</p> <pre><code>{\n  \"type\": \"#Schema\",\n  \"key\": \"LibrarySchema\",\n  \"relationships\": [\n    { \"name\": \"Components\", \"target\": [{ \"$ref\": \"BookType\" }] }\n  ]\n}\n</code></pre> <p>will be rewritten internally to:</p> <pre><code>{\n  \"type\": \"#BookType\",\n  \"relationships\": [\n    { \"name\": \"ComponentOf\", \"target\": { \"$ref\": \"LibrarySchema\" } }\n  ]\n}\n</code></pre> <p>This preserves the storage model while making authoring more intuitive.</p> <p>\ud83d\uded1 Note: If both directions of a relationship pair are expressed in the same import file, the loader will raise a warning or error.</p>"},{"location":"core/holon-data-loader-design-spec/#json-import-file-structure","title":"\ud83d\udcc2 JSON Import File Structure","text":"<p>Details about JSON formatting, required fields, reference expressions (<code>$ref</code>), embedded holons, and schema validation rules have been moved to the Holon Data Loader Guide.</p> <p>See: Holon Data Loader Guide \u2013 Authoring Valid JSON Files</p>"},{"location":"core/holon-data-loader-design-spec/#validation-lifecycle","title":"\ud83d\udd0d Validation Lifecycle","text":"<p>The Holon Data Loader and MAP system use multiple layers of validation to ensure correctness, schema alignment, and safe persistence.</p>"},{"location":"core/holon-data-loader-design-spec/#1-schema-validation-pre-load","title":"1. Schema Validation (Pre-Load)","text":"<p>Before holons are even staged, input files are validated using JSON Schema:</p> <ul> <li>The loader always begins by validating imports against the <code>bootstrap-import.schema.json</code> schema. This schema ensures:<ul> <li>Holons are properly structured</li> <li>Properties are well-formed</li> <li>Relationship targets follow required structure</li> <li>No invalid reference forms are present (e.g., unkeyed <code>$ref</code> targets)</li> </ul> </li> </ul>"},{"location":"core/holon-data-loader-design-spec/#cascading-schema-validation","title":"\ud83e\uddec Cascading Schema Validation","text":"<p>After loading the MAP Meta-Schema, additional JSON Schemas can be generated automatically for downstream validation:</p> <ul> <li>Meta-Schema \u2192 Used to validate Core Type imports (e.g., PropertyType, ValueType)</li> <li>Core Schema \u2192 Used to validate Domain-Specific Schema files</li> <li>Domain Schema \u2192 Used to validate Domain-Specific Data files</li> </ul> <p>This allows every import layer to be validated against a holon-based, introspected schema, enforcing MAP type rules long before runtime.</p>"},{"location":"core/holon-data-loader-design-spec/#2-runtime-validation-post-commit","title":"2. Runtime Validation (Post-Commit)","text":"<p>After holons are committed, Holochain's Conductor orchestrates the integrity checks by invoking validation callbacks defined in the <code>map_holons_integrity</code> zome.</p> <p>\u2757 Holons do not themselves trigger validation \u2014 the request to persist a holon causes the Conductor to invoke validation logic.</p> <p>The validation callbacks: - Receive Holochain-native types like <code>Record</code>, <code>Link</code>, <code>ActionHash</code> - Convert these into MAP-native, Holochain-independent structures:     - <code>Holon</code>     - <code>HolonRelationships</code>     - <code>LocalId</code>, etc.</p> <p>These converted forms are passed to shared validation functions (in <code>holons_core</code>) that enforce:</p> <ul> <li>Required and optional property rules</li> <li>Cardinality constraints on relationships</li> <li>Reference resolution and type compatibility</li> <li>Key and relationship uniqueness</li> <li>Schema-defined constraints (e.g., min/max values, enum values, etc.)</li> </ul> <p>This design allows the same validation logic to be reused across client tools, data loaders, and runtime validation \u2014 avoiding duplication and enabling introspection.</p>"},{"location":"core/holon-data-loader-design-spec/#3-loader-level-validations","title":"3. Loader-Level Validations","text":"<p>The Holon Data Loader performs additional checks during staging:</p> <ul> <li>Ensures no inverse relationship appears more than once (after rewriting)</li> <li>Validates that all <code>$ref</code> targets resolve to keyed holons or embedded holons</li> <li>Rejects direct references to keyless holons</li> <li>Ensures that all keyless holons are:<ul> <li>Embedded as relationship targets</li> <li>The source of at least one declared relationship</li> </ul> </li> <li>Ensures that keys (when present) are unique within the load scope</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#staging-and-commit-process","title":"\ud83d\udcbe Staging and Commit Process","text":""},{"location":"core/holon-data-loader-design-spec/#pass-1-stage-holons","title":"Pass 1: Stage Holons","text":"<ul> <li>Create in-memory Holon stubs for each input</li> <li>Only properties are staged; relationships are deferred</li> <li>Holons must include <code>type</code> (and <code>key</code>, if keyed)</li> <li>Relationships are stored for Pass 2</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#pass-2-stage-relationships","title":"Pass 2: Stage Relationships","text":"<ul> <li>Resolve all <code>relationships</code> from JSON</li> <li>References are resolved by <code>$ref</code>, <code>Type:Key</code>, or embedded inline</li> <li>Inverse relationships are rewritten to their declared form</li> <li>Embedded keyless holons are inlined into source holon relationships</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#commit-and-validate","title":"Commit and Validate","text":"<ul> <li>After all holons are staged, the loader invokes <code>holons_core</code> to commit</li> <li>Holochain callbacks are triggered</li> <li>Shared validation logic enforces type rules</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#schema-loading","title":"Schema Loading","text":"<p>As noted previously, the</p> Programming Concept MAP Base Type MAP <code>type_kind</code> <code>String</code> <code>MapStringValueType</code> <code>ValueString</code> <code>bool</code> <code>MapBooleanValueType</code> <code>ValueBoolean</code> <code>i64</code> / <code>number</code> <code>MapIntegerValueType</code> <code>ValueInteger</code> <code>Vec&lt;u8&gt;</code> / base64 <code>MapBytesValueType</code> <code>ValueBytes</code> Enum (string symbol) <code>MapEnumValueType</code> <code>ValueEnum</code> Holon descriptor <code>MapHolonType</code> <code>Holon</code> Relationship descriptor <code>MapRelationshipType</code> <code>Relationship</code> Property descriptor <code>MapPropertyType</code> <code>Property</code>"},{"location":"core/holon-data-loader-design-spec/#future-enhancements","title":"\ud83d\udd2e Future Enhancements","text":"<ul> <li>Add schema-based authoring for enum types, constraint types, and complex nested holons</li> <li>Expand support for symbolic references (<code>DanceRequest</code>)</li> <li>Enhance loader validation to support contextual awareness of target schemas</li> <li>Support streaming JSON parsing for very large imports</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#summary","title":"\ud83d\udcce Summary","text":"<p>The Holon Data Loader is the universal import engine for MAP Types and Instances. It supports:</p> <ul> <li>Bootstrap loading of MAP Meta-Schema and Core Schema</li> <li>Domain-specific extension imports</li> <li>Declarative instance creation with ergonomic syntax</li> <li>Unified graph population using a two-pass process</li> <li>Rewriting of inverse relationships for intuitive JSON authoring</li> <li>Holochain-independent shared validation</li> </ul> <p>Authors and tool builders can rely on a consistent, minimal JSON format while benefiting from full MAP introspection, validation, and schema enforcement.</p> <p>See also: Holon Data Loader Guide for JSON authoring rules and examples.</p>"},{"location":"core/holon-data-loader-design-spec/#obsolete-content","title":"========== OBSOLETE CONTENT ==============","text":"<p>Everything after this point is left-over from prior versions are targeted to be deleted.</p>"},{"location":"core/holon-data-loader-design-spec/#json-file-structure","title":"\ud83d\udd0e JSON File Structure","text":"<p>A JSON import file contains two top-level keys:</p> <pre><code>{\n   \"meta\": {\"... },\n   \"holons\": [ { ... }, { ... }, ... ]\n}\n</code></pre> <ul> <li><code>meta</code> contains metadata about the import (version, author, etc.).</li> <li><code>holons</code> contains the list of holons to be imported.</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#holon-structure","title":"Holon Structure","text":"<p>Each holon in the <code>holons</code> list is represented as a JSON object with the following keys:</p> <ul> <li><code>type</code> (string): Fully qualified <code>$ref</code> to the holon's type (e.g., <code>\"#MapStringValueType\"</code>). Replaces the older <code>DescribedBy</code> pattern.</li> <li><code>key</code> (optional): A unique identifier if the holon is keyed.</li> <li><code>temp_key</code> (optional): A temporary key for referencing other holons within the same import file.</li> <li><code>properties</code>: A map of property name to typed value.</li> <li><code>relationships</code>: A list of relationship objects, each containing:</li> <li><code>name</code>: Relationship name</li> <li><code>target</code>: Either a <code>$ref</code> string or an embedded holon</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#key-design-rules","title":"\ud83d\udd0e Key Design Rules","text":""},{"location":"core/holon-data-loader-design-spec/#type-implies-describedby","title":"\u2705 <code>type</code> Implies <code>DescribedBy</code>","text":"<ul> <li>Every holon must specify a <code>type</code> using <code>#Key</code> syntax.</li> <li>This replaces the need for an explicit <code>DescribedBy</code> relationship.</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#use-components-instead-of-iscomponentof","title":"\u2705 Use <code>Components</code> Instead of <code>IsComponentOf</code>","text":"<ul> <li>All imported holons are children of a <code>MapSchemaType</code> holon.</li> <li>The <code>Components</code> relationship replaces <code>IsComponentOf</code>.</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#declare-useskeyrule-for-keyed-holons","title":"\u2705 Declare <code>UsesKeyRule</code> for Keyed Holons","text":"<p>Each keyed holon must include a relationship: <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": {\n    \"type\": \"#FormatKeyRule\",\n    \"properties\": {\n      \"format\": \"$0\",\n      \"property_names\": [\"type_name\"]\n    }\n  }\n}\n</code></pre></p>"},{"location":"core/holon-data-loader-design-spec/#fully-qualified-keys-for-relationship-types","title":"\u2705 Fully Qualified Keys for Relationship Types","text":"<p>Use a <code>key</code> such as: <pre><code>(HolonType)-[DescribedBy]-&gt;(TypeDescriptor)\n</code></pre> This prevents ambiguity and supports inverse resolution.</p>"},{"location":"core/holon-data-loader-design-spec/#ref-is-the-only-reference-format","title":"\u2705 <code>$ref</code> Is the Only Reference Format","text":"<p>Reference targets in relationships must use <code>$ref</code> strings, such as: - <code>#temp-key</code> - <code>Type:Key</code> - <code>id:&lt;HolonId&gt;</code> - <code>@Proxy:Type:Key</code> - <code>ext:&lt;ProxyId&gt;:&lt;LocalId&gt;</code></p>"},{"location":"core/holon-data-loader-design-spec/#data-loader-flow","title":"\ud83d\udcca Data Loader Flow","text":"<ol> <li>Author Holons \u2013 Use Airtable or any editor</li> <li>Convert to JSON \u2013 Jupyter notebook or custom tool</li> <li>Validate \u2013 Run against JSON Schema</li> <li>Parse \u2013 Create internal <code>HolonImportSpec</code> structs</li> <li>Pass 1: Stage Holons<ul> <li>Assign temp_keys and validate shape</li> <li>Properties only; defer relationships</li> </ul> </li> <li>Pass 2: Stage Relationships<ul> <li>Resolve references using <code>$ref</code></li> </ul> </li> <li>Commit \u2013 Insert holons via <code>holons_core</code></li> <li>Validate \u2013 Trigger integrity zome and shared validators</li> </ol>"},{"location":"core/holon-data-loader-design-spec/#example-holon-with-relationships","title":"\ud83d\udd01 Example Holon with Relationships","text":"<pre><code>{\n  \"type\": \"#BookType\",\n  \"temp_key\": \"book-001\",\n  \"properties\": {\n    \"title\": { \"type\": \"#MapStringValueType\", \"value\": \"Future Primal\" }\n  },\n  \"relationships\": [\n    { \"name\": \"AUTHORED_BY\", \"target\": { \"$ref\": \"PersonType:charles-eisenstein\" } },\n    { \"name\": \"MENTORED_BY\", \"target\": { \"$ref\": \"#mentor-temp-001\" } }\n  ]\n}\n</code></pre>"},{"location":"core/holon-data-loader-design-spec/#meta-modeling-relationship-types","title":"\ud83c\udf93 Meta-Modeling: Relationship Types","text":""},{"location":"core/holon-data-loader-design-spec/#primary-vs-inverse-relationship-types","title":"\u2709\ufe0f Primary vs. Inverse Relationship Types","text":"<p>Use two types: - <code>MetaPrimaryRelationshipType</code>: explicitly declared by source - <code>MetaInverseRelationshipType</code>: inferred only</p>"},{"location":"core/holon-data-loader-design-spec/#inverse-links","title":"\ud83d\udd01 Inverse Links","text":"<p>Each relationship holon must link to its inverse using: <pre><code>{\n  \"name\": \"InverseOf\",\n  \"target\": { \"$ref\": \"#OtherRelationshipType\" }\n}\n</code></pre></p> <p>Only primary relationships are listed in <code>PRIMARY_SOURCE_FOR</code> of the source HolonType.</p>"},{"location":"core/holon-data-loader-design-spec/#key-rules-for-relationship-types","title":"\ud83d\udcc4 Key Rules for Relationship Types","text":"<pre><code>{\n  \"format\": \"($0)-[$1]-&gt;($2)\",\n  \"property_names\": [\"source_type\", \"type_name\", \"target_type\"]\n}\n</code></pre> <p>This ensures uniqueness and proper <code>$ref</code> resolution.</p>"},{"location":"core/holon-data-loader-design-spec/#validation-overview","title":"\ud83e\udd1d Validation Overview","text":"<ul> <li>Holon validation happens via Holochain callbacks</li> <li>Type validation uses shared holochain-independent logic</li> <li><code>$ref</code> entries must resolve in Pass 2 or trigger errors</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#design-philosophy_1","title":"\ud83c\udf10 Design Philosophy","text":"Principle Description Holonic Uniformity Everything (types, rules, instances) is a holon Self-Describing <code>type</code> and <code>key</code> provide all descriptor info Keyed Reference Integrity No reference unless <code>key</code> or <code>temp_key</code> defined Two-Pass Import Enables circular refs and easy authoring Minimal Format Concise JSON with embedded metadata"},{"location":"core/holon-data-loader-design-spec/#next-steps","title":"\ud83d\udd2e Next Steps","text":"<ul> <li>Add section on symbolic references via <code>DanceRequest</code></li> <li>Add schema examples for EnumType, PropertyType, etc.</li> <li>Publish complete reference <code>bootstrap-import.schema.json</code></li> </ul> <p>\u2e3b</p>"},{"location":"core/i18n-design-spec/","title":"Internationalization Design Spec","text":""},{"location":"core/i18n-design-spec/#map-internationalization-localized-holons-design","title":"\ud83c\udf0d MAP Internationalization &amp; Localized Holons Design","text":"<p>Version: August 2025 Status: Rough Consensus Architecture</p>"},{"location":"core/i18n-design-spec/#1-overview","title":"1. Overview","text":"<p>MAP\u2019s internationalization (i18n) model uses fully localized holons to support multilingual content and context-specific knowledge representation. Rather than extracting localized strings into separate holons or defining a specialized type, each holon is a complete locale-specific instance of a <code>HolonType</code>.</p> <p>Localization is modeled via relationships and properties directly on the core <code>HolonType</code>, enabling consistent treatment of localized holons as first-class data entities.</p>"},{"location":"core/i18n-design-spec/#terminology-internationalization-vs-localization","title":"\ud83e\udded Terminology: Internationalization vs. Localization","text":""},{"location":"core/i18n-design-spec/#internationalization-i18n","title":"Internationalization (i18n)","text":"<p>Internationalization is the process of designing software and data models in a way that makes them adaptable to multiple languages, regions, and cultures without requiring engineering changes for each new locale.</p> <p>In the context of MAP: - Internationalization enables holons to be stored, queried, and presented in multiple languages. - It introduces structural support for locale-specific resource pools, canonical representations, and fallback logic. - It ensures that holons, their properties, and relationships can vary by locale without breaking semantic or identity integrity.</p> <p>Mnemonic: \u201cDesign once, localize many times.\u201d</p>"},{"location":"core/i18n-design-spec/#localization-l10n","title":"Localization (l10n)","text":"<p>Localization is the process of adapting data or interface elements for a specific language, region, or cultural context. This includes translating human-readable strings and may involve restructuring or adapting content to fit local norms.</p> <p>In the context of MAP: - A localized holon is a full instance of a holon whose values and relationships are resolved in the context of a particular locale. - One holon per group is designated the canonical representation, and others reference it via a <code>CanonicalRepresentation</code> relationship. - Localization includes translated display names, descriptions, and possibly locale-specific relationships (e.g. tags, categorizations).</p> <p>Mnemonic: \u201cLocalization is applying the design to a specific place and language combination.\u201d</p> <p>These two processes are complementary: - Internationalization is an architectural concern. - Localization is a content and presentation concern.</p>"},{"location":"core/i18n-design-spec/#2-key-design-decisions","title":"2. Key Design Decisions","text":"<ul> <li>\u2705 Each localized representation is a full holon of the same <code>HolonType</code>, scoped to a specific locale</li> <li>\u2705 One representation per locale, grouped via <code>CanonicalRepresentation</code> relationship</li> <li>\u2705 One holon is designated as the canonical representation using <code>is_canonical_representation = true</code></li> <li>\u2705 All other localized holons declare a <code>CanonicalRepresentation</code> link to that canonical holon</li> <li>\u2705 All properties and relationships are resolved relative to locale context</li> <li>\u2705 Locale affiliation is modeled via a <code>LocalPool</code> relationship to a <code>LocalizedResourcePool</code></li> <li>\u2705 No <code>LocalizedString</code> holons or derived <code>LocalizedHolonType</code> subtype</li> </ul>"},{"location":"core/i18n-design-spec/#3-map-internationalization-structure","title":"3. MAP Internationalization Structure","text":"<p>A <code>LocalizedResourcePool</code> groups holons by a shared <code>locale</code> (e.g., <code>en</code>, <code>fr</code>, <code>fr-CA</code>).</p> <p>Each pool is associated with a single Locale (language/region combination)</p> <p>Each localized holon must belong to one such pool via <code>Pool</code>.</p> <p></p> <p>One localized holon is designated as the canonical representation, all others are designated LocalizedRepresentations of the canonical representation and have a relationship to it.</p>"},{"location":"core/i18n-design-spec/#3-holon-localization-semantics","title":"3. Holon Localization Semantics","text":""},{"location":"core/i18n-design-spec/#31-localized-holons","title":"3.1 Localized Holons","text":"<p>Each localized holon is a complete instance of its type (e.g., <code>Book</code>, <code>Person</code>, <code>Organization</code>) with values and links tailored to a specific locale. While string properties are typically the only materialized locale-specific values, all properties and relationships are conceptually locale-relative.</p> <p>Localized holons contain:</p> <ul> <li><code>Pool</code> relationship to their (single) locale-specific <code>LocalizedResourcePool</code></li> <li><code>is_canonical_representation</code> boolean property (true only for one holon per group)</li> <li>Fully materialized string values are expressed in the regional variant of their language (e.g., French Canadian)</li> <li>Relationships are resolved by the most appropriate representation of the target holon(s), given the source holon's locale.</li> </ul> <p>Consider the following example:</p> <p></p> <p>Le Petit Prince is the canonical representation of the Livre (fr:FR) and Antoine de Saint-Exup\u00e9ry is the canonical representation of a Personne. Both belong to the Un d\u00e9p\u00f4t de ressources en fran\u00e7ais pool (as does the Livre and Personne Type Descriptors) - Optional <code>CanonicalRepresentation</code> \u2192 reference to the canonical version (required for non-canonical variants)</p>"},{"location":"core/i18n-design-spec/#32-canonical-representation","title":"3.2 Canonical Representation","text":"<ul> <li>Exactly one localized holon per group should be flagged with <code>is_canonical_representation = true</code></li> <li>Updates should always be made to the canonical holon</li> <li>Other localized holons must eventually be kept in sync via explicit update/translation flows</li> <li>Each localized holon (except the canonical one) must declare a <code>CanonicalRepresentation</code> relationship</li> </ul>"},{"location":"core/i18n-design-spec/#4-locale-affiliation","title":"4. Locale Affiliation","text":"<p>All holons are scoped to a specific locale by including:</p> <pre><code>\"relationships\": {\n  \"LocalPool\": { \"$ref\": \"LocalizedResourcePool:fr-CA\" }\n}\n</code></pre> <p>This enables: - Organized partitioning of holons by language/culture - Locale-sensitive fallback resolution - Query and navigation behaviors that adapt to user preferences</p>"},{"location":"core/i18n-design-spec/#6-cross-locale-equivalence","title":"6. Cross-Locale Equivalence","text":"<p>Localized holons are grouped semantically via:</p> <ul> <li>Shared Type and conceptual identity</li> <li>One canonical representation identified via <code>is_canonical_representation = true</code></li> <li>All others linking back to that canonical holon via <code>CanonicalRepresentation</code></li> </ul> <p>This design supports: - Consistent object identity across languages - Round-trip translation and editing workflows - Clean integration with fallback logic and search resolution</p>"},{"location":"core/i18n-design-spec/#7-locale-precedence-and-fallback","title":"7. Locale Precedence and Fallback","text":"<p>Queries and navigation are executed with a contextual <code>locale_precedence</code> stack, e.g.:</p> <pre><code>{\n  \"requested_locale\": \"fr-CA\",\n  \"fallback_locales\": [\"fr-CA\", \"fr\", \"en-CA\", \"en\"]\n}\n</code></pre> <p>Used for: - Holon resolution - Property display and value substitution - Ranking search results</p>"},{"location":"core/i18n-design-spec/#8-heterogeneous-text-search","title":"8. Heterogeneous Text Search","text":""},{"location":"core/i18n-design-spec/#81-motivation","title":"8.1 Motivation","text":"<p>Text-based search is the first step in many MAP workflows (including AI-RAG). Users should be able to query across all types of holons, e.g. \"Tom Hanks\" \u2192 <code>Person</code>, <code>Film</code>, <code>Author</code>, etc.</p>"},{"location":"core/i18n-design-spec/#82-indexing-scope","title":"8.2 Indexing Scope","text":"<p>Each localized holon is indexed based on: - Locale-tagged <code>display_name</code>, <code>description</code>, <code>type_name</code>, etc. - Any string-bearing property - Relationship labels (for guidance/navigation)</p>"},{"location":"core/i18n-design-spec/#83-search-behavior","title":"8.3 Search Behavior","text":"<ul> <li>Query is matched against all localized holons</li> <li>Locale context guides scoring and fallback</li> <li>Results are enriched with type metadata and <code>DanceLink</code>s for structured navigation</li> </ul>"},{"location":"core/i18n-design-spec/#9-dance-query-integration","title":"9. Dance &amp; Query Integration","text":""},{"location":"core/i18n-design-spec/#91-locale-context","title":"9.1 Locale Context","text":"<p>All queries execute with a <code>locale_context</code>, which influences: - Holon resolution - Relationship traversal - Search indexing and scoring</p>"},{"location":"core/i18n-design-spec/#92-dance-integration","title":"9.2 Dance Integration","text":"<ul> <li><code>DANCE(\"viewBook\")</code> resolves to the localized holon variant matching the context</li> <li><code>DANCE(\"editBook\")</code> may route to the canonical version for source-of-truth editing</li> <li>Queries do not need to manually specify locale \u2014 fallback is automatic</li> </ul>"},{"location":"core/i18n-design-spec/#10-example","title":"10. Example","text":"Locale Holon Key <code>display_name</code> <code>is_canonical_representation</code> Pool Canonical Ref en-US Book:1@en-US \"Book\" true <code>LocalizedResourcePool:en-US</code> \u2014 fr Book:1@fr \"Livre\" false <code>LocalizedResourcePool:fr</code> \u2192 Book:1@en-US fr-CA Book:1@fr-CA \"Livre\" false <code>LocalizedResourcePool:fr-CA</code> \u2192 Book:1@en-US"},{"location":"core/i18n-design-spec/#11-implementation-roadmap","title":"11. Implementation Roadmap","text":"Phase Features \u2705 MVP Canonical holons, embedded string props \u23f3 v1 Localized holons + <code>LocalPool</code> relationships \u23f3 v2 Canonical representation logic (<code>is_canonical_representation</code>, <code>CanonicalRepresentation</code>) \u23f3 v3 Locale-aware fallback resolution \u23f3 v4 Indexed multilingual search \u23f3 v5 Dance integration + canonical update tooling"},{"location":"core/i18n-design-spec/#12-open-design-questions","title":"12. Open Design Questions","text":"<ul> <li>Should canonical holons be excluded from a <code>LocalizedResourcePool</code>, or have a special <code>canonical</code> pool? NO</li> <li>Should properties like <code>is_canonical_representation</code> be enforced at the type level? NO</li> <li>How are canonical updates tracked and propagated (e.g. via translation queues)? TBD</li> <li>How should locale-specific validation be applied to ensure completeness and fidelity? TBD</li> </ul>"},{"location":"core/i18n-design-spec/#13-summary","title":"13. Summary","text":"<p>MAP\u2019s localized holon design enables a powerful, consistent, and high-performance internationalization strategy that:</p> <ul> <li>Keeps all holons in a uniform representation</li> <li>Avoids fragmentary or per-property lookup logic</li> <li>Fully supports multilingual search and navigation</li> <li>Integrates seamlessly with canonical edit flows and localization workflows</li> </ul> <p>This architecture is designed to scale with complexity while remaining intuitive and developer-friendly across all layers of the MAP platform.</p>"},{"location":"core/map-catalist-security-models/","title":"Proposal: Migrating from Catalist\u2019s Fine-Grained Security to MAP\u2019s Group-Oriented Model","text":""},{"location":"core/map-catalist-security-models/#1-core-dimensions-of-security","title":"1. Core Dimensions of Security","text":"<p>Both Catalist and MAP need to address the same underlying dimensions: - Who (agents/people/groups) - What Data (holons, attributes, views)  - What Actions (verbs/Dances) - Entitlements vs. Permissions (purchased rights vs. delegated rights)</p> <p>Catalist encodes these as fine-grained decisions at the level of individuals and attributes. MAP lifts them into higher-order groupings:</p> Dimension Catalist (fine-grain) MAP (group-oriented) Who Each person has direct grants People belong to Groups Actions Each verb toggled per person Actions grouped into Roles Entitlements Tied to specific individuals Entitled actions bundled into Products Data Attributes assigned per person Attributes bundled into Views"},{"location":"core/map-catalist-security-models/#2-simplifying-the-decision-surface","title":"2. Simplifying the Decision Surface","text":"<p>Instead of N\u00d7M\u00d7K\u00d7L micro-decisions (people \u00d7 attributes \u00d7 actions \u00d7 contexts), MAP collapses the surface area:</p> <ul> <li>Grant = (Group, Role, View)<ul> <li>Which group has which role over which view?</li> </ul> </li> <li>Entitlements = (Product \u2192 Role associations)<ul> <li>Purchasing a product expands the action set for associated roles.</li> </ul> </li> </ul> <p>This makes permissioning a macro-level governance decision rather than an endless stream of micro-decisions.</p>"},{"location":"core/map-catalist-security-models/#3-change-management-and-migration-path","title":"3. Change Management and Migration Path","text":"<ul> <li>Step 1: Define canonical Groups, Roles, Products, Views   Translate existing Catalist entitlements/permissions into these higher-order bundles.</li> <li>Step 2: Map existing fine-grained grants into group memberships   (e.g., \u201cFrank has access to X, Y, Z\u201d \u2192 Frank is in Group A, which carries Role B over View C).</li> <li>Step 3: Retire individual grants in favor of group membership operations   Adding/removing people from groups now handles churn events (onboarding, offboarding, role shifts).</li> </ul>"},{"location":"core/map-catalist-security-models/#4-alignment-with-map-security-model","title":"4. Alignment with MAP Security Model","text":"<p>This approach fits cleanly with MAP\u2019s core security principles:</p> <ul> <li>Membrane-based boundaries \u2014 Groups correspond to AgentSpace membranes </li> <li>Consent-based access \u2014 Views and Products are exposed only via explicit Agreements </li> <li>Sovereign custody \u2014 All data lives in private Data Groves, shared only through Information Access Agreements </li> <li>Role-based actions \u2014 Roles map directly to permitted Dances within the Uniform API </li> </ul>"},{"location":"core/map-catalist-security-models/#5-benefits","title":"5. Benefits","text":"<ul> <li>Reduces cognitive load for administrators and members.</li> <li>Improves resilience by making permissions more transparent and auditable.</li> <li>Supports migration: existing fine-grained Catalist grants can be bulk-mapped into initial groups/roles/views without losing fidelity.</li> <li>Future-proof: easily maps into MAP\u2019s holistic model of Promises, Agreements, and Vital Capital flows </li> </ul> <pre><code>flowchart LR\n  subgraph Inputs[Normalized Inputs]\n    SM[SpaceMembership (user \u2208 Group@Space)]\n    RP[RolePolicy (Group \u2192 can_*)]\n    PUB[Publish/Unpublish (Thing \u2194 Space)]\n    OWN[Home Transfer]\n    ENT[Entitlement (Plan@Space)]\n    ASG[EntitlementAssignment (seat)]\n    PF[Plan/Feature/Action mapping]\n    TREF[ThingEntitlementRef (Thing \u2194 Entitlement)]\n    AS[Audience Set (Space:is_audience_set)]\n  end\n\n  subgraph Compiler[Backend \"Compiler\" Workflows]\n    P1[Recompute eff_perm_* for impacted Things]\n    E1[Recompute eff_ent_* for impacted Things]\n    I1[(Optional) Write eff_allowed_* = \u2229]\n  end\n\n  subgraph Outputs[Thing Runtime Lists]\n    EPV[eff_perm_view]\n    EPA[eff_perm_annotate]\n    EPE[eff_perm_edit]\n    EPM[eff_perm_manage]\n    EEV[eff_ent_view]\n    EEA[eff_ent_annotate]\n    EEE[eff_ent_edit]\n    EAL[(optional) eff_allowed_*]\n  end\n\n  SM --&gt; P1\n  RP --&gt; P1\n  PUB --&gt; P1\n  OWN --&gt; P1\n  ENT --&gt; E1\n  ASG --&gt; E1\n  PF --&gt; E1\n  TREF --&gt; E1\n  AS --&gt; P1\n\n  P1 --&gt; EPV &amp; EPA &amp; EPE &amp; EPM\n  E1 --&gt; EEV &amp; EEA &amp; EEE\n  I1 --&gt; EAL\n\n  style EPM fill:#ffd8bf,stroke:#c44,color:#222\n  style AS fill:#eef,stroke:#88a,color:#222\n</code></pre>"},{"location":"core/map-content-distribution-arch/","title":"Map content distribution arch","text":""},{"location":"core/map-content-distribution-arch/#a-sovereign-content-distribution-architecture","title":"\ud83e\uddd0 A Sovereign Content-Distribution Architecture","text":"<p>Imagine a MAP-native alternative to the content stack that currently looks like: - YouTube/Vimeo for hosting - Social platforms for distribution - Extractive attention algorithms for reach - Fragmented identity and limited sovereignty</p> <p>But in the MAP model, you invert the entire structure:</p> Traditional Model MAP-Native Equivalent Videos are hosted on platforms Videos are hosted in the creator\u2019s I-Space Content copied to many silos Content stays in one canonical Space, shared via Holon IDs Algorithmic discovery Pull-based discovery via Memetic alignment and consent-based Trust Channels One-size-fits-all platforms Distribution flows through Sense adapters, tailored to each channel Platform owns access &amp; analytics Agent retains full sovereignty; access is granted, tracked, and revocable"},{"location":"core/map-content-distribution-arch/#how-this-works-in-practice","title":"\ud83d\udd78\ufe0f How This Works in Practice","text":""},{"location":"core/map-content-distribution-arch/#1-a-thought-leaders-video-is-a-holon","title":"1. A Thought Leader's Video is a Holon","text":"<ul> <li>They record a 60\u201390 min talk or dialogue.</li> <li>The file is stored in their I-Space, possibly mirrored through a HoliPort.</li> <li>The Holon (representing the video) is described with:<ul> <li>A <code>LifeCode</code> alignment</li> <li><code>Promise</code> conditions (e.g., under CC license, or available to certain roles)</li> <li><code>Memetic Signature</code> metadata</li> <li>Distribution preferences (e.g., \"make public,\" or \"share with Activation Space\")</li> </ul> </li> </ul>"},{"location":"core/map-content-distribution-arch/#2-shared-into-a-map-space-eg-memetic-activation-space","title":"2. Shared into a MAP Space (e.g., Memetic Activation Space)","text":"<ul> <li>That Holon is not copied, just referenced in the shared space.</li> <li>The activation space now becomes a coherent memetic feed \u2014 a MAP-native YouTube channel.</li> <li>This space can be visualized with timeline, graph, or gallery visualizers.</li> </ul>"},{"location":"core/map-content-distribution-arch/#3-distributed-via-sense-adapters","title":"3. Distributed via Sense Adapters","text":"<ul> <li>Each space (like the Activation Series) is paired with a Sense app that can:<ul> <li>Announce new content to preconfigured outbound channels (e.g., Instagram, YouTube, Email, BlueSky)</li> <li>Translate a MAP-native Promise into a shareable teaser or link</li> <li>Upload or synchronize content to external platforms where needed</li> </ul> </li> </ul> <p>In early days, upload adapters trade sovereignty for reach. Later, more audience finds the content via MAP-native pull flows (search, DAHN filters, or space feeds).</p>"},{"location":"core/map-content-distribution-arch/#why-the-no-copying-model-is-so-powerful","title":"\ud83d\udca1 Why the \u201cNo Copying\u201d Model is So Powerful","text":"<p>Every Holon lives in exactly ONE home space. This is the ONLY space where its properties and relationships are stored. References to a Holon can be shared in other spaces via agreement-mediated Trust Channels. Stated more simply, what is shared is not copies of the holon's data, it is cryptographically-secured access to that holon's data. I'm not sharing data, I'm promising access to that data. This is  a foundational differentiator \u2014 and a key performance optimization.</p>"},{"location":"core/map-content-distribution-arch/#benefits-of-holon-id-only-sharing","title":"Benefits of Holon-ID Only Sharing:","text":"Benefit Implication Data Sovereignty Creator retains ultimate control; can revoke or update access at any time Reduced Storage/Cost No need to duplicate video files across every space or participant\u2019s store Dynamic Caching Popular or active content is pulled to local caches for speed/resilience Immutable History + Live Control Viewers see the same content \u2014 but only as long as it\u2019s still being offered Fine-Grained Access Control Promises and Agreements can govern who gets what, when, and under what terms <p>This isn\u2019t just elegant \u2014 it\u2019s ecological. The system only pulls what is needed, when it is needed, in alignment with consent and context.</p>"},{"location":"core/map-content-distribution-arch/#sense-adapters-for-video","title":"\ud83d\udd0c Sense Adapters for Video","text":"<p>You're right to generalize from chat-like adapters (WhatsApp, email, BlueSky) to video-capable adapters.</p>"},{"location":"core/map-content-distribution-arch/#these-adapters-would","title":"These adapters would:","text":"<ul> <li>Detect new video Holons shared into a Space</li> <li>Render shareable artifacts:<ul> <li>Thumbnails</li> <li>Snippets (possibly via AI video summarization)</li> <li>Promise metadata</li> </ul> </li> <li>Format for outbound platforms</li> <li>Perform actions like:<ul> <li>Upload to YouTube</li> <li>Post a teaser clip to Instagram</li> <li>Email a newsletter</li> <li>Push to Matrix/Slack/Discord</li> </ul> </li> </ul> <p>Adapters are modular and swappable. So the same Holon can be represented differently across platforms, yet still link back to a canonical MAP-native location.</p>"},{"location":"core/map-content-distribution-arch/#planetary-distribution-space-optional-layer","title":"\ud83c\udf00 Planetary Distribution Space (Optional Layer)","text":"<p>You suggest another intriguing pattern:</p> <p>A Distribution Space may be separate from the Memetic Activation Space.</p> <p>That\u2019s elegant.</p> <ul> <li>The Memetic Activation Series is curated \u2014 the interviews, contributions, and lifecycle.</li> <li>The Distribution Space is infrastructure \u2014 the technical gateway to outbound flows.<ul> <li>It might include:<ul> <li>Sense adapters</li> <li>Analytics dashboards</li> <li>Caching and QoS policies</li> <li>Terms of Service for media collaboration</li> </ul> </li> </ul> </li> </ul> <p>This separation mirrors the publishing / distribution split of traditional media \u2014 but in a holonic, consent-based, sovereignty-preserving way. Distribution Spaces allow content creators to publish their stewarded media content into a variety of distribution channels without having to stand up their own content distribution infrastructures. Stewards <code>Connect</code> with Distribution Spaces using Join Enquires that spell out the reciprocal promises constituting the terms and conditions for membership in the space. Once a member, content stewards can selectively choose which of their stewarded media content they would like distributed via which channels.</p> <p>It is important to note the trade-offs here.</p>"},{"location":"core/map-content-distribution-arch/#trade-offs-navigating-reach-resonance-and-sovereignty","title":"\u2696\ufe0f Trade-offs: Navigating Reach, Resonance, and Sovereignty","text":"<p>Distribution Spaces serve as intentional bridges between MAP-native environments and external distribution channels. They give content stewards fine-grained control over what, where, and how their creations are shared \u2014 and under what terms.</p> <p>Unlike traditional media platforms, this is not a forced trade-off, but a selective, composable strategy.</p> <p>You can place your video in the Memetic Activation Space and distribute it via YouTube. These are not mutually exclusive paths \u2014 they are complementary facets of your distribution strategy.</p>"},{"location":"core/map-content-distribution-arch/#early-stage-dynamics","title":"\ud83e\uddfd Early Stage Dynamics","text":"<ul> <li> <p>Sharing into MAP-native spaces (like the Memetic Activation Space) is primarily about:</p> <ul> <li>Seeding aligned spaces with meaningful content</li> <li>Surfacing memes into the Global Meme Pool</li> <li>Modeling MAP-native presence and collaborative potential</li> <li>Building connection and resonance with early adopters</li> </ul> </li> <li> <p>Distributing through external channels (via Sense adapters) is about:</p> <ul> <li>Building awareness of the steward\u2019s work \u2014 amplifying their message beyond the MAP</li> <li>Reaching broader audiences and inviting resonance</li> <li>Building recognition and narrative coherence across ecosystems</li> <li>Creating entry points into the MAP via pull-links and aligned invitations</li> <li>Expanding the visibility and uptake of both their content and the Memetic Activation Series</li> </ul> </li> </ul> <p>In early phases, this two-pronged strategy helps content stewards grow both external reach and internal depth, nurturing visibility while anchoring sovereignty.</p>"},{"location":"core/map-content-distribution-arch/#evolving-dynamics-over-time","title":"\ud83d\udd01 Evolving Dynamics Over Time","text":"<p>As MAP-native spaces grow in: - Membership, - Meme density, and - Promise Weave activity</p> <p>\u2026 they begin to rival or even surpass external platforms in terms of: - Relevance - Discovery quality - Collaboration potential</p> <p>Eventually, for many participants, the highest-value audiences may be found inside the MAP \u2014 not outside.</p>"},{"location":"core/map-content-distribution-arch/#what-distribution-spaces-enable","title":"\ud83e\udde9 What Distribution Spaces Enable","text":"<ul> <li>Selective distribution: Share only specific Holons to specific channels.</li> <li>Sovereign participation: Retain ownership and revocability of content inside the MAP.</li> <li>Trust-based distribution: Join Distribution Spaces through Join Enquiries, agreeing to mutual promises about how content is used, shared, and attributed.</li> <li>Multichannel coordination: Use Sense adapters to simultaneously reach both MAP-native and external audiences \u2014 without fragmenting control or identity.</li> </ul> <p>MAP doesn\u2019t eliminate trade-offs. It makes them visible, governable, and revocable. You choose the channels. You define the conditions. You steward the flow.</p>"},{"location":"core/map-content-distribution-arch/#ecosystem-use-cases-that-emerge","title":"\ud83e\udeb4 Ecosystem Use Cases That Emerge","text":"<p>Once this foundation exists, it becomes:</p> <ul> <li>A MAP-native YouTube alternative</li> <li>A video podcast engine for small collectives</li> <li>A learning archive for educational programs (e.g., bioregional schools)</li> <li>A collaborative docu-series space</li> <li>A regenerative media syndication network</li> </ul> <p>And most powerfully:</p> <p>A commons-owned distribution stack where memetic alignment \u2014 not algorithmic extraction \u2014 determines reach.</p>"},{"location":"core/map-content-distribution-arch/#where-to-prototype","title":"\ud83d\ude80 Where to Prototype","text":"<p>You could start with: - Memetic Activation Series Space     - Each new guest drops a video holon into it     - It becomes the testbed for:         - Media visualizers (timeline, constellation, or ritual journey)         - Sense adapter integration (email newsletter + YouTube)         - DAHN navigation (trending, filters by meme) - Distribution Commons Space     - Configures adapters and publishes policies     - Tracks usage metrics (without surveillance)     - Offers services to other MAP Spaces (i.e., distribution-as-a-service)</p>"},{"location":"core/map-content-distribution-arch/#strategic-questions-to-explore-next","title":"\ud83d\udd1d Strategic Questions to Explore Next","text":"<ol> <li> <p>What\u2019s the minimum viable video Sense adapter?</p> <ul> <li>Would a YouTube \u201cupload &amp; post\u201d adapter be enough to prove the concept?</li> <li>Can we mock or simulate it for testing?</li> </ul> </li> <li> <p>How are Promises tagged for distribution?</p> <ul> <li>What metadata must be present?</li> <li>Can they include visual teasers and memetic tags?</li> </ul> </li> <li> <p>What is the guest-facing onboarding flow for this?</p> <ul> <li>Upload video \u2192 Create Promise \u2192 Join Space \u2192 Review distribution options</li> </ul> </li> <li> <p>What should the canonical visualizer for a media-rich space look like?</p> <ul> <li>Can it show: content + flows + memes + resonance + access rights?</li> </ul> </li> <li> <p>How does DAHN handle retrieval + caching + playback in this model?</p> <ul> <li>Are there progressive fallback strategies (e.g., local cache \u2192 peer \u2192 HoliPort \u2192 gateway)?</li> </ul> </li> </ol>"},{"location":"core/map-content-distribution-arch/#final-thought","title":"\ud83d\udd16 Final Thought","text":"<p>What we\u2019re modeling here is a decentralized, consent-based, memetically-aligned media ecosystem \u2014 one where: - Content creators own their work - Distribution is aligned with intention - Viewers discover through resonance, not manipulation - And the entire thing scales via trust, not surveillance</p> <p>This is the beginning of a post-platform media commons.</p>"},{"location":"core/map-deployment-arch/","title":"MAP Rust-API Developer Guide","text":"<p>The Rust-API is the boundary between your application code and the underlying holon store and services. It provides:</p> <ul> <li>Uniform handles (\u201creferences\u201d) to holons, regardless of whether they are transient, staged, or cached/saved.</li> <li>A small, consistent read/write API that hides internal manager and phase differences.</li> <li>High-level operations for staging, committing, and deleting.</li> <li>A curated prelude for ergonomic imports and a stable public API.</li> </ul> <p>This guide explains the API surface and shows how to perform the most common tasks.</p>"},{"location":"core/map-deployment-arch/#part-i-foundations","title":"Part I \u2013 Foundations","text":""},{"location":"core/map-deployment-arch/#1-prelude","title":"1. Prelude","text":"<p>To simplify imports, use the MAP prelude:</p> <p>```rust,ignore use holons_prelude::prelude::*; <pre><code>This brings into scope:\n\n* Core value and identifier types (`BaseValue`, `MapString`, `HolonId`)\n* Reference traits and types (`HolonReference`, `ReadableHolon`, `WritableHolon`, `TransientReference`, `StagedReference`, `SmartReference`)\n* Context traits (`HolonsContextBehavior`)\n* Common operations (`stage_new_holon_api`, `commit_api`, etc.)\n* Type-name helpers (`CorePropertyTypeName`, `CoreRelationshipTypeName`, `ToPropertyName`, `ToRelationshipName`)\n* Dance protocol builders (`holon_dance_builders::*`)\n* Query types (`Node`, `NodeCollection`, `QueryExpression`)\n\n&gt; Use `holons_prelude::prelude::v1::*` if you need to pin to a stable prelude version.\n\n---\n\n## 2. Context: your execution environment\n\nEvery holon operation in MAP runs within a **context** that implements the `HolonsContextBehavior` trait. This context is the execution environment for all read, write, and commit actions\u2014it provides access to the active workspace where your holons live.\n\nAs a developer, you don\u2019t create or manage the context yourself. Your mApp receives it from the runtime whenever you perform operations that touch holons.  \nYou simply pass it along to each API call that needs it.\n\nExample \u2014 staging and committing a holon:\n\n```rust,no_run\nuse holons_prelude::prelude::*;\n\nfn create_and_commit(\n    context: &amp;dyn HolonsContextBehavior,\n) -&gt; Result&lt;(), HolonError&gt; {\n    // Create a new transient holon of a given type\n    let transient = new_holon(context, MapString(\"ExampleType\".into()));\n    transient.with_property_value(context, P::Key, \"example-1\".into())?;\n\n    // Stage it for persistence\n    let _staged = stage_new_holon_api(context, transient)?;\n\n    // Commit all staged changes\n    let response = commit_api(context)?;\n    println!(\"Committed {} holons.\", response.commits_attempted);\n\n    Ok(())\n}\n</code></pre></p>"},{"location":"core/map-deployment-arch/#key-points-for-developers","title":"Key points for developers","text":"<ul> <li> <p>The context is always the first parameter to any read or write call.    It carries all the state needed to resolve references, access relationships, and enforce permissions.</p> </li> <li> <p>You can think of it as your \u201csession\u201d or \u201cworkspace.\u201d    Everything that happens during a transaction\u2014reads, writes, staging, commits\u2014occurs within this context.</p> </li> <li> <p>The context automatically routes requests to the right implementation based on the holon\u2019s phase (transient, staged, or saved).  You never need to know which storage or cache layer is involved.</p> </li> <li> <p>Contexts are lightweight and short-lived. They are passed around as immutable references (<code>&amp;dyn HolonsContextBehavior</code>), so you can safely use them in async or concurrent flows.</p> </li> </ul> <p>In short: the context is your gateway to the MAP. You use it everywhere, but you don\u2019t manage or configure it\u2014just pass it through to the reference-layer API.</p>"},{"location":"core/map-deployment-arch/#3-reference-kinds","title":"3. Reference Kinds","text":"<p><code>HolonReference</code> is the universal handle for accessing any holon in MAP\u2014whether it\u2019s newly created, staged for commit, or already persisted. It abstracts over three underlying reference types that represent different lifecycle phases of a holon.</p> <ul> <li><code>TransientReference</code> \u2014 in-memory, mutable, not yet persisted.</li> <li><code>StagedReference</code> \u2014 managed by the staging layer and ready to commit.</li> <li><code>SmartReference</code> \u2014 read-only, backed by a saved holon in cache or storage.</li> </ul> <p>All three implement the <code>ReadableHolon</code> trait; <code>TransientReference</code> and <code>StagedReference</code> additionally implement <code>WritableHolon</code>.</p> Type Backing store Read Write Commit Notes <code>HolonReference</code> Delegates to underlying phase \u2705 \u2705 / \u274c \u2705 / \u274c Unified handle that wraps any reference type. Enforces access rules automatically. <code>TransientReference</code> In-memory \u2705 \u2705 \u274c Must be staged before commit. <code>StagedReference</code> Staging area \u2705 \u2705 \u2705 Prepared for persistence. <code>SmartReference</code> Saved/cache \u2705 \u274c \u274c Read-only view of a saved holon."},{"location":"core/map-deployment-arch/#unified-trait-implementation","title":"Unified trait implementation","text":"<p><code>HolonReference</code> implements both <code>ReadableHolon</code> and <code>WritableHolon</code>. This means you can call read or write methods directly on a <code>HolonReference</code> without downcasting to its internal variant.</p> <p>However, write access is phase-dependent:</p> <ul> <li>If the reference wraps a <code>TransientReference</code> or <code>StagedReference</code>, write operations (e.g., <code>with_property_value</code>, <code>add_related_holons</code>) will succeed normally.</li> <li>If the reference wraps a <code>SmartReference</code>, any attempt to modify it will result in <code>HolonError::NotAccessible</code>.</li> </ul> <p>This design provides ergonomic consistency while maintaining strict access guarantees.</p>"},{"location":"core/map-deployment-arch/#typical-usage-pattern","title":"Typical usage pattern","text":"<p>```rust,ignore // Works regardless of phase let title = holon_ref.property_value(context, &amp;P::Title)?;</p> <p>// Safe to call; will fail gracefully if reference is read-only holon_ref.with_property_value(context, P::Title, \"Updated\".into())?; <pre><code>In short:  \n**`HolonReference` provides a single, uniform API for all holon phases**, while the combination of context and reference phase determines which operations are actually permitted.\n\n---\n\n# Part II \u2013 Holon Operations (HolonOperationsApi)\n\nThe **HolonOperationsApi** provides high-level functions for creating, staging, committing, and deleting holons.  It serves as the main entry point for mApp developers who need to persist holons, abstracting away the lower-level service lookups handled by the `HolonSpaceManager`. Where the `ReadableHolon` and `WritableHolon` traits focus on *individual holon content*, the operations in this API focus on *holon lifecycle actions* \u2014 such as preparing holons for persistence, committing them to storage, and querying what\u2019s currently staged.\n\n---\n\n## 4. Creating and staging holons\n\nHolons can be created or staged in several ways, depending on the source and intent. All staging operations result in a `StagedReference`, representing a holon managed by the **Nursery** and ready for commit.\n\n### A. Creating a new transient holon\n\nUse `new_holon` to create a new, empty transient holon. Once created, you can use its TransientReference to et its properties or relationships (see `WritableHolon` operations below).\n\n```rust,ignore\nlet transient = new_holon(context, MapString(\"BookType\".into()))?;\ntransient.with_property_value(context, P::Title, \"The Rustonomicon\".into())?;\n</code></pre></p> <p>Transient holons are purely in-memory \u2014 they can be used ephemerally (e.g., as temporary parameters in a Dance), or later staged for persistence.</p>"},{"location":"core/map-deployment-arch/#b-staging-a-new-holon-from-scratch","title":"B. Staging a new holon from scratch","text":"<p>To prepare a transient holon for persistence, call <code>stage_new_holon</code>. This registers it in the Nursery and returns a <code>StagedReference</code>.</p> <p>```rust,ignore let transient = new_holon(context, MapString(\"BookType\".into()))?; transient.with_property_value(context, P::Key, \"example-1\".into())?;</p> <p>let staged = stage_new_holon(context, transient)?; <pre><code>The newly staged holon now participates in commit operations and can have relationships or properties safely modified.\n\n---\n\n### C. Staging a holon by cloning another\n\nUse `stage_new_from_clone` to create a new staged holon based on an existing one. The `original_holon` may be a transient, staged, or saved holon.  NOTE: stage_new_from_clone on a Transient HolonReference is equivalent to `stage_new_holon`. To distinguish the new holon from the holon it is being cloned from, pass the \"key\" for the new holon as a parameter.\n\n```rust,ignore\nlet staged_clone = stage_new_from_clone(context, existing_ref, MapString(\"copy-001\".into()))?;\n</code></pre></p> <p>Use this form when you want to derive a new holon from an existing one without creating a lineage relationship.</p>"},{"location":"core/map-deployment-arch/#d-staging-a-new-version-of-a-saved-holon","title":"D. Staging a new version of a saved holon","text":"<p>Saved holons (accessed via <code>SmartReference</code>) are immutable. To \u201cupdate\u201d one, you must stage a new holon that explicitly declares the saved holon as its predecessor. This ensures historical lineage and preserves auditability.</p> <p>```rust,ignore let staged_version = stage_new_version(context, saved_ref)?; staged_version.with_property_value(context, P::Status, \"Revised\".into())?; <pre><code>&gt; Conceptually, `stage_new_version` is the canonical \u201cupdate\u201d mechanism in MAP.  \n&gt; Instead of mutating data, it creates a new holon with lineage continuity.\n\n---\n\n### Summary of staging options\n\n| Use case                      | Input reference kind | Function               | Result            | Lineage | Notes                                |\n|-------------------------------|----------------------|------------------------|-------------------|---------|--------------------------------------|\n| Create new holon from scratch | None (new)           | `stage_new_holon`      | `StagedReference` | \u274c       | Typical create workflow              |\n| Derive holon from another     | Any                  | `stage_new_from_clone` | `StagedReference` | \u274c       | Copy data from any source            |\n| Create new version (update)   | `SmartReference`     | `stage_new_version`    | `StagedReference` | \u2705       | Adds predecessor link for versioning |\n\nAll three return `StagedReference`, ready to commit.\n\n---\n\n## 5. Committing staged holons\n\nOnce one or more holons have been staged, you can persist them together using `commit`.\n\n```rust,ignore\nlet response = commit(context)?;\nprintln!(\n    \"Saved: {}, Abandoned: {}, Attempted: {}\",\n    response.saved_holons.len(),\n    response.abandoned_holons.len(),\n    response.commits_attempted\n);\n</code></pre></p>"},{"location":"core/map-deployment-arch/#commitresponse-contents","title":"CommitResponse contents","text":"<ul> <li><code>saved_holons</code> \u2014 list of successfully persisted holons.</li> <li><code>abandoned_holons</code> \u2014 holons that were skipped or invalidated.</li> <li><code>commits_attempted</code> \u2014 total count of staged holons processed.</li> </ul> <p>A complete commit satisfies: <code>(saved + abandoned == attempted)</code></p>"},{"location":"core/map-deployment-arch/#commit-outcomes","title":"Commit outcomes","text":"<p>Complete Commit \u2013 All staged holons and relationships persisted successfully. The Nursery is cleared of committed entries.</p> <p>Partial Commit \u2013 Some holons committed successfully, others remain staged with error details. No staged holons are automatically removed, allowing retries.</p> <p>Failure \u2013 System-level issue prevented commit; no changes persisted.</p>"},{"location":"core/map-deployment-arch/#e-counting-and-retrieving-staged-holons","title":"E. Counting and retrieving staged holons","text":"<p>Helper methods are available for diagnostics or introspection:</p> <p>```rust,ignore let staged_total = staged_count(context); let transient_total = transient_count(context); println!(\"Currently staged: {}, transient: {}\", staged_total, transient_total); <pre><code>You can also look up specific holons by key:\n\n```rust,ignore\nlet staged_by_key = get_staged_holon_by_base_key(context, &amp;MapString(\"example-1\".into()))?;\n</code></pre></p>"},{"location":"core/map-deployment-arch/#f-deleting-holons","title":"F. Deleting holons","text":"<p>Holons can be deleted via <code>delete_holon</code>, but only local (i.e., space-owned) saved holons may be deleted.</p> <p>```rust,ignore delete_holon(context, local_id)?; <pre><code>Deletion removes the holon from the current holon space and, if invoked from the guest side, from the DHT as well.\n\n---\n\n### Conceptual overview\n\nThe **HolonOperationsApi** provides the primary bridge between mApp logic and the MAP storage layer.  \nIt\u2019s designed for developer clarity and consistency:\n\n* **`new_holon`** \u2192 Creates new in-memory holons.\n* **`stage_new_*`** \u2192 Moves holons into the staging area, ready for commit.\n* **`commit`** \u2192 Persists all staged holons atomically.\n* **`delete_holon`** \u2192 Removes holons permanently.\n\nTogether, these functions represent the canonical workflow for managing holon persistence.\n\n---\n\n# Part III \u2013 Individual Holons (ReadableHolon, WritableHolon)\n\n## 7. Reading holons (ReadableHolon)\n\nEvery `HolonReference` implements `ReadableHolon`.  \nReads are *kind-safe* and work consistently across transient, staged, and saved holons.\n\n---\n\n### Core reads\n\n`key(context) -&gt; Option&lt;MapString&gt;`\n\nThe human-meaningful identifier for the holon, if defined.  \nSome holon kinds are keyless, so this may return `None`.\n\nExample:\n```rust,ignore\nlet key_opt = reference.key(context)?;\n</code></pre></p> <p><code>versioned_key(context) -&gt; MapString</code></p> <p>A stable, fully-qualified identifier that includes the base key plus version information (when applicable). Since saved holons are immutable, updating a saved holon creates a new version with a distinct <code>versioned_key</code>. If the update doesn\u2019t alter the underlying key properties, the new holon will share the same base key.</p> <p>Example: ```rust,ignore let vkey = reference.versioned_key(context)?; <pre><code>---\n\n`property_value(context, name) -&gt; Option&lt;PropertyValue&gt;`\n\nReads a property by name using **ergonomic inputs**:  \n`&amp;str`, `String`, `MapString`, `PropertyName`, or a core enum such as `CorePropertyTypeName::Title`.  \nReturns `None` if the property is absent.\n\nExample:\n```rust,ignore\nlet title_opt = reference.property_value(context, \"title\")?;\n</code></pre></p> <p><code>related_holons(context, name) -&gt; HolonCollection</code></p> <p>Navigates an outgoing relationship and returns a collection of <code>HolonReference</code>s to the linked holons. Accepts <code>&amp;str</code>, <code>String</code>, <code>MapString</code>, <code>RelationshipName</code>, or a core enum. Always returns a <code>HolonCollection</code> (possibly empty), never <code>None</code>.</p> <p>Example: ```rust,ignore let children = reference.related_holons(context, \"HAS_CHILD\")?; <pre><code>---\n\n### When to use which\n\n| Method               | Purpose                                                                                                        |\n|----------------------|----------------------------------------------------------------------------------------------------------------|\n| **`key`**            | Retrieve or display a meaningful base key. Use for routing, URLs, and user-facing identifiers.                 |\n| **`versioned_key`**  | Generate stable identifiers for logging, caching, and cross-system references.                                 |\n| **`property_value`** | Read domain fields (e.g., `title`, `status`). Use ergonomic names: `\"title\"` or `CorePropertyTypeName::Title`. |\n| **`related_holons`** | Traverse graph links (e.g., `\"HAS_CHILD\"`, `CoreRelationshipTypeName::HasChild`) and iterate results.          |\n\n---\n\n### Ergonomic property and relationship access\n\nMAP\u2019s ergonomic wrapper traits make property and relationship access feel natural:\n\n* **`ToPropertyName`** \u2014 allows property lookups using core enums, strings, or `MapString`s.\n* **`ToRelationshipName`** \u2014 allows relationship lookups using core enums or strings.\n\nThese remove the need to manually construct `PropertyName(MapString(...))` or `BaseValue::StringValue(...)` and unify access across core and dynamic names.\n\n#### Examples\n\n**Before (verbose):**\n```rust,ignore\nlet title = reference.property_value(\n    context,\n    PropertyName(MapString(\"title\".into())),\n)?;\n</code></pre></p> <p>Now (ergonomic): ```rust,ignore let title = reference.property_value(context, \"title\")?; let author = reference.property_value(context, CorePropertyTypeName::Author)?; let children = reference.related_holons(context, CoreRelationshipTypeName::HasChild)?; <pre><code>All inputs are normalized internally (e.g., `\"friends\"`, `\"Friends\"`, and `\"FRIENDS\"` are equivalent).\n\n---\n\n### Example: Reading a property with a default\n\n```rust,ignore\nlet title = item.property_value(context, \"title\")?\n    .and_then(|v| v.as_string())\n    .unwrap_or_else(|| \"Untitled\".to_string());\n</code></pre></p> <p>This retrieves the <code>\"title\"</code> property, converts it to a string if possible, and falls back to <code>\"Untitled\"</code> when the property is missing or not a string.</p> <p>Step-by-step: 1. <code>property_value</code> returns a <code>Result&lt;Option&lt;PropertyValue&gt;, HolonError&gt;</code>.    The <code>?</code> operator unwraps the <code>Result</code>, leaving an <code>Option&lt;PropertyValue&gt;</code>. 2. <code>.and_then(|v| v.as_string())</code> converts the property to a <code>String</code> if it\u2019s string-typed. 3. <code>.unwrap_or_else(|| \"Untitled\".to_string())</code> substitutes a default when missing.</p> <p>In plain language:</p> <p>\u201cGet the holon\u2019s title if available; otherwise use <code>'Untitled'</code>.\u201d</p>"},{"location":"core/map-deployment-arch/#example-traversing-relationships","title":"Example: Traversing relationships","text":"<p>```rust,ignore let children = reference.related_holons(context, \"HAS_CHILD\")?; for child in children.iter() {     let ck = child.key(context)?;     println!(\"Child key: {:?}\", ck); } <pre><code>This fetches and iterates through all linked child holons using an ergonomic relationship lookup.\n\n## 8. Writing holons (WritableHolon)\n\nThe `WritableHolon` trait provides mutation APIs for holons that can be modified \u2014 namely,  \n**`TransientReference`** and **`StagedReference`**.  \nAttempting to call any of these methods on a `SmartReference` (saved holon) will return  \n`HolonError::NotAccessible`.\n\nWritable methods are kind-safe: they automatically update both the in-memory property/relationship maps and any synchronization state used during staging or commit.\n\n---\n\n### Setting property values\n\n`with_property_value(context, name, value) -&gt; Result&lt;(), HolonError&gt;`\n\nAssigns or replaces a property value.  \nAccepts property names using ergonomic `ToPropertyName` conversions (e.g., string literals or core enums) and automatically wraps primitive Rust types into their appropriate `PropertyValue`.\n\nExample:\n```rust,ignore\nreference.with_property_value(context, \"title\", \"Hello World\")?;\nreference.with_property_value(context, CorePropertyTypeName::Status, \"Draft\")?;\n</code></pre></p> <p>You can pass Rust primitives such as <code>&amp;str</code>, <code>String</code>, <code>bool</code>, <code>i64</code>, or <code>f64</code>. Internally these are converted into the appropriate MAP <code>BaseValue</code> variant.</p>"},{"location":"core/map-deployment-arch/#removing-properties","title":"Removing properties","text":"<p><code>remove_property_value(context, name) -&gt; Result&lt;(), HolonError&gt;</code></p> <p>Removes the specified property, if present.</p> <p>Example: ```rust,ignore reference.remove_property_value(context, \"obsolete\")?; <pre><code>If the property does not exist, the method simply returns `Ok(())`.\n\n---\n\n### Managing relationships\n\n`add_related_holons(context, name, targets) -&gt; Result&lt;(), HolonError&gt;`\n\nAdds one or more related holons under the given relationship name.  \nEach target is a `HolonReference`.  \nThe relationship name accepts the same ergonomic types as property names.\n\nExample:\n```rust,ignore\nreference.add_related_holons(\n    context,\n    CoreRelationshipTypeName::HasChild,\n    vec![child_ref],\n)?;\n</code></pre></p> <p><code>remove_related_holons(context, name, targets) -&gt; Result&lt;(), HolonError&gt;</code></p> <p>Removes one or more holons from a relationship set. Has no effect if the target references are not already related.</p> <p>Example: ```rust,ignore reference.remove_related_holons(     context,     \"HAS_CHILD\",     vec![child_ref], )?; <pre><code>&gt; Relationship mutations automatically update the holon\u2019s local relationship map.  \n&gt; The changes become durable only after commit.\n\n---\n\n### Setting the descriptor\n\n`with_descriptor(context, descriptor_ref) -&gt; Result&lt;(), HolonError&gt;`\n\nSets or replaces the holon\u2019s **descriptor**, which declares its type.  \nDescriptors are always holons themselves (of a `HolonType` kind).  \nThis call is uncommon in normal app code \u2014 it\u2019s primarily used by loaders or editors creating new holons from schema types.\n\nExample:\n```rust,ignore\nreference.with_descriptor(context, descriptor_ref)?;\n</code></pre></p>"},{"location":"core/map-deployment-arch/#setting-the-predecessor","title":"Setting the predecessor","text":"<p><code>with_predecessor(context, predecessor_ref) -&gt; Result&lt;(), HolonError&gt;</code></p> <p>Establishes a lineage relationship between the current holon and its immediate predecessor. Used mainly in versioned workflows to record \u201cwhat this holon was derived from.\u201d</p> <p>Example: ```rust,ignore reference.with_predecessor(context, Some(prev_ref))?; <pre><code>To clear a predecessor link, pass `None`.\n\n---\n\n### Summary of writable operations\n\n| Operation               | Purpose                    | Typical use                                                 |\n|-------------------------|----------------------------|-------------------------------------------------------------|\n| `with_property_value`   | Set or replace a property. | Create or edit domain fields before staging or commit.      |\n| `remove_property_value` | Remove a property.         | Clean up unused or obsolete fields.                         |\n| `add_related_holons`    | Add linked holons.         | Associate new relationships (e.g., add tasks to a project). |\n| `remove_related_holons` | Remove linked holons.      | Detach related entities.                                    |\n| `with_descriptor`       | Assign a type descriptor.  | Loader-level operation for schema-driven creation.          |\n| `with_predecessor`      | Record lineage.            | Used in versioned updates (`stage_new_version`).            |\n\n---\n\n### Example workflow\n\nHere\u2019s a typical editing flow for a staged holon:\n\n```rust,ignore\n// 1. Stage a new version of an existing holon\nlet staged = stage_new_version(context, saved_ref)?;\n\n// 2. Update its properties\nstaged.with_property_value(context, \"title\", \"Updated Title\")?;\nstaged.with_property_value(context, CorePropertyTypeName::Status, \"Revised\")?;\n\n// 3. Add and remove related holons\nstaged.add_related_holons(context, \"HAS_CHILD\", vec![child_a])?;\nstaged.remove_related_holons(context, \"HAS_CHILD\", vec![child_b])?;\n\n// 4. Commit all staged changes\nlet resp = commit(context)?;\nprintln!(\"{} holons saved.\", resp.saved_holons.len());\n</code></pre></p> <p>This demonstrates the complete writable lifecycle: create or stage \u2192 modify \u2192 commit.</p>"},{"location":"core/map-deployment-arch/#error-conditions","title":"Error conditions","text":"<p>All writable operations return <code>Result&lt;(), HolonError&gt;</code>. Common error cases:</p> <ul> <li><code>HolonError::NotAccessible</code> \u2014 write attempted on a read-only holon (<code>SmartReference</code>).</li> <li><code>HolonError::InvalidHolonReference</code> \u2014 target or relationship not resolvable in the current context.</li> <li><code>HolonError::InvalidType</code> \u2014 provided value type doesn\u2019t match the property\u2019s declared type.</li> <li><code>HolonError::UnexpectedValueType</code> \u2014 incompatible runtime conversion.</li> </ul> <p>Writable APIs follow a fail-fast design \u2014 operations either succeed immediately or return a specific <code>HolonError</code> explaining what went wrong.</p> <p>In summary: WritableHolon methods make it easy to set, update, and link holons safely, with ergonomic property and relationship access, automatic type conversion, and strong context enforcement.</p>"},{"location":"core/map-deployment-arch/#part-iv-collections-holoncollectionapi","title":"Part IV \u2013 Collections (HolonCollectionApi)","text":""},{"location":"core/map-deployment-arch/#9-working-with-collections-of-holons","title":"9. Working with collections of holons","text":"<p>A <code>HolonCollection</code> represents an unordered set of holon references\u2014often returned when traversing relationships.</p>"},{"location":"core/map-deployment-arch/#access-and-iteration","title":"Access and iteration","text":"<p>```rust,ignore let count   = tasks.len(); let first   = tasks.first(); let by_index  = tasks.get(2); for holon_ref in &amp;tasks {     println!(\"{:?}\", holon_ref.key(context)?); } <pre><code>### Membership and lookup\n```rust,ignore\nif tasks.contains(&amp;some_ref) {\n    println!(\"Already linked!\");\n}\n</code></pre></p> <p>```rust,ignore if let Some(found) = tasks.get_by_key(&amp;MapString(\"task-42\".into())) {     println!(\"Found task 42: {:?}\", found.key(context)?); } <pre><code>### Mutation\nAvailable only for transient and staged holons.\n\n```rust,ignore\ntasks.add(context, HolonReference::Transient(new_task_ref))?;\ntasks.remove(context, HolonReference::Smart(old_task_ref))?;\n</code></pre></p>"},{"location":"core/map-deployment-arch/#part-v-queries","title":"Part V \u2013 Queries","text":""},{"location":"core/map-deployment-arch/#10-querying-holons","title":"10. Querying holons","text":"<p>The query layer provides a high-level way to search for holons that meet specific criteria.</p>"},{"location":"core/map-deployment-arch/#example","title":"Example","text":"<p>```rust,ignore let expr = QueryExpression::property_equals(P::Title, \"Hello\".into()); let nodes: NodeCollection = run_query(context, expr)?; for node in nodes {     println!(\"Found: {:?}\", node.key(context)?); } <pre><code>&gt; Note: The query API is evolving and currently supports basic property and relationship predicates.\n\n---\n\n# Part VI \u2013 Cross-cutting Topics\n\n## 11. Access Control\n\n| AccessType | Transient | Staged | Smart |\n|------------|-----------|--------|-------|\n| Read       | \u2705         | \u2705      | \u2705     |\n| Write      | \u2705         | \u2705      | \u274c     |\n| Clone      | \u2705         | \u2705      | \u2705     |\n| Commit     | \u274c         | \u2705      | \u274c     |\n| Abandon    | \u2705         | \u2705      | \u274c     |\n\nUnauthorized actions raise `HolonError::NotAccessible`.\n\n---\n\n## 12. Error Handling\n\nAll MAP API functions return `Result&lt;_, HolonError&gt;`.  This unified error type is used consistently across the reference layer and ensures that mApp code can handle errors uniformly\u2014whether they originate in the local runtime, the staging layer, or a distributed DHT operation.\n\n---\n\n### How errors propagate\n\n1. **Local logic errors** (e.g., missing property, invalid type) are raised directly by reference-layer methods.\n2. **Access control errors** are enforced by context and reference kind before reaching service layers.\n3. **Service errors** (e.g., during commit or DHT access) bubble up through the same `HolonError` type for consistent handling.\n\nWhen using `?`, errors automatically propagate to the caller; explicit matches can be used for fine-grained control.\n\nExample:\n\n```rust,ignore\nmatch reference.property_value(context, \"title\") {\n    Ok(Some(val)) =&gt; println!(\"Title: {:?}\", val.as_string()),\n    Ok(None) =&gt; println!(\"Title missing.\"),\n    Err(HolonError::NotAccessible) =&gt; println!(\"You do not have read access.\"),\n    Err(err) =&gt; eprintln!(\"Unexpected error: {:?}\", err),\n}\n</code></pre></p>"},{"location":"core/map-deployment-arch/#error-categories","title":"Error categories","text":"Category Typical causes Handling strategy Access Attempted write or read on an inaccessible holon or context. Verify reference kind and permissions. Resolution Reference could not be found or resolved. Check that the target holon exists in the current space. Schema / Type Property value type mismatches or missing required fields. Validate property types before assignment; use defaults for missing values. Persistence / Service Errors during staging, commit, or DHT operations. Retry commit or surface to user; check <code>CommitResponse</code> for details. Internal Unexpected internal conditions or bugs. Log and escalate."},{"location":"core/map-deployment-arch/#mapping-to-responsestatuscode","title":"Mapping to ResponseStatusCode","text":"<p>When holon operations are invoked through Dances, <code>HolonError</code> variants are automatically mapped to appropriate <code>ResponseStatusCode</code> values (e.g., <code>BadRequest</code>, <code>Conflict</code>, <code>ServerError</code>). This allows API clients to interpret results consistently across in-process and distributed boundaries.</p>"},{"location":"core/map-deployment-arch/#best-practices","title":"Best practices","text":"<ul> <li>Use pattern matching to handle expected errors gracefully (e.g., missing properties).</li> <li>Use the <code>?</code> operator when you want errors to bubble up.</li> <li>Always log or display <code>HolonError::message()</code> when debugging.</li> <li>Treat <code>HolonError::InternalError</code> as a bug indicator \u2014 report it.</li> </ul> <p>For a complete list of <code>HolonError</code> variants, see Appendix B \u2013 HolonError Reference.</p>"},{"location":"core/map-deployment-arch/#13-style-conventions","title":"13. Style &amp; Conventions","text":"<ul> <li>Use explicit suffixes (<code>*_reference</code>) for reference variables.</li> <li>When APIs expect <code>Vec&lt;HolonReference&gt;</code>, wrap explicitly:</li> </ul> <p>```rust,ignore HolonReference::Transient(transient_reference) <pre><code>---\n\n## 14. Where to Look\n\n* **Prelude:** `holons_prelude::prelude`\n* **Context behavior:** `reference_layer/context_behavior.rs`\n* **Operations API:** `reference_layer/holon_operations_api.rs`\n* **Reference traits and types:** `reference_layer/holon_reference.rs`, `readable_holon.rs`, `writable_holon.rs`, `staged_reference.rs`, `transient_reference.rs`\n* **Access and state:** `core_shared_objects/holon/state.rs`\n* **Dance builders:** `holon_dance_builders`\n* **Query layer:** `reference_layer/query_api.rs`\n\n---\n\n## 15. Evolving Areas\n\n* Validation runs primarily at commit.\n* Fluent chaining (`&amp;Self`) is being standardized in setters.\n* The query API will expand to richer predicates.\n* Additional Dances (Loader, Validation) will reuse the same reference layer interface.\n\n---\n\n# Appendix A \u2013 API Quick Reference Card\n\n## HolonOperationsApi\n\n```rust,ignore\nfn new_holon(\n    context: &amp;dyn HolonsContextBehavior,\n    type_name: MapString,\n) -&gt; TransientReference;\n\nfn stage_new_holon_api(\n    context: &amp;dyn HolonsContextBehavior,\n    transient: TransientReference,\n) -&gt; Result&lt;StagedReference, HolonError&gt;;\n\nfn stage_new_version(\n    context: &amp;dyn HolonsContextBehavior,\n    current_version: SmartReference,\n) -&gt; Result&lt;StagedReference, HolonError&gt;;\n\nfn stage_new_from_clone(\n    context: &amp;dyn HolonsContextBehavior,\n    original_holon: HolonReference,\n    new_key: MapString,\n) -&gt; Result&lt;StagedReference, HolonError&gt;;\n\nfn commit_api(\n    context: &amp;dyn HolonsContextBehavior,\n) -&gt; Result&lt;CommitResponse, HolonError&gt;;\n</code></pre></p>"},{"location":"core/map-deployment-arch/#readableholon","title":"ReadableHolon","text":"<p>```rust,ignore fn key(&amp;self, context: &amp;dyn HolonsContextBehavior)     -&gt; Result, HolonError&gt;; <p>fn versioned_key(&amp;self, context: &amp;dyn HolonsContextBehavior)     -&gt; Result; <p>fn property_value(     &amp;self,     context: &amp;dyn HolonsContextBehavior,     property_name: &amp;PropertyName, ) -&gt; Result, HolonError&gt;; <p>fn related_holons(     &amp;self,     context: &amp;dyn HolonsContextBehavior,     relationship_name: &amp;RelationshipName, ) -&gt; Result; <p>fn all_related_holons(     &amp;self,     context: &amp;dyn HolonsContextBehavior, ) -&gt; Result, HolonError&gt;; <p>fn holon_id(&amp;self, context: &amp;dyn HolonsContextBehavior)     -&gt; Result; <p>fn predecessor(&amp;self, context: &amp;dyn HolonsContextBehavior)     -&gt; Result, HolonError&gt;; <p>fn essential_content(&amp;self, context: &amp;dyn HolonsContextBehavior)     -&gt; Result; <pre><code>---\n\n## WritableHolon\n\n```rust,ignore\nfn with_property_value(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n    property_name: CorePropertyTypeName,\n    value: PropertyValue,\n) -&gt; Result&lt;(), HolonError&gt;;\n\nfn remove_property_value(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n    property_name: CorePropertyTypeName,\n) -&gt; Result&lt;(), HolonError&gt;;\n\nfn add_related_holons(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n    relationship_name: RelationshipName,\n    targets: Vec&lt;HolonReference&gt;,\n) -&gt; Result&lt;(), HolonError&gt;;\n\nfn remove_related_holons(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n    relationship_name: RelationshipName,\n    targets: Vec&lt;HolonReference&gt;,\n) -&gt; Result&lt;(), HolonError&gt;;\n\nfn with_descriptor(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n    descriptor_ref: HolonReference,\n) -&gt; Result&lt;(), HolonError&gt;;\n\nfn with_predecessor(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n    predecessor_ref: Option&lt;HolonReference&gt;,\n) -&gt; Result&lt;(), HolonError&gt;;\n</code></pre>"},{"location":"core/map-deployment-arch/#holoncollectionapi","title":"HolonCollectionApi","text":"<p>```rust,ignore fn len(&amp;self) -&gt; usize; fn is_empty(&amp;self) -&gt; bool; fn first(&amp;self) -&gt; Option&lt;&amp;HolonReference&gt;; fn get(&amp;self, index: usize) -&gt; Option&lt;&amp;HolonReference&gt;; fn get_by_key(&amp;self, key: &amp;MapString) -&gt; Option&lt;&amp;HolonReference&gt;; fn contains(&amp;self, target: &amp;HolonReference) -&gt; bool; fn to_vec(&amp;self) -&gt; Vec; fn add(     &amp;self,     context: &amp;dyn HolonsContextBehavior,     target: HolonReference, ) -&gt; Result&lt;(), HolonError&gt;; fn remove(     &amp;self,     context: &amp;dyn HolonsContextBehavior,     target: HolonReference, ) -&gt; Result&lt;(), HolonError&gt;; <pre><code>---\n\n## Query Layer\n\n```rust,ignore\nfn property_equals(\n    property_name: CorePropertyTypeName,\n    value: PropertyValue,\n) -&gt; QueryExpression;\n\nfn run_query(\n    context: &amp;dyn HolonsContextBehavior,\n    expr: QueryExpression,\n) -&gt; Result&lt;NodeCollection, HolonError&gt;;\n</code></pre> <p>This appendix serves as a concise signature-only reference for all key API areas, grouped by their functional domains.</p>"},{"location":"core/map-deployment-arch/#appendix-b-holonerror-reference","title":"Appendix B \u2013 HolonError Reference","text":"<p>The <code>HolonError</code> enum defines all possible error conditions that may occur while working with holons. Each variant captures a distinct failure domain within the MAP reference layer.</p> Variant Description Common Origin <code>NotAccessible</code> Operation not permitted under current context/kind combination. Attempting to modify a <code>SmartReference</code>; restricted access context. <code>InvalidHolonReference</code> Reference cannot be resolved or is malformed. Dangling or out-of-scope references; deleted holons. <code>InvalidType</code> The provided value or descriptor does not match the expected type. Assigning the wrong <code>ValueType</code> or <code>Descriptor</code>. <code>UnexpectedValueType</code> Runtime value type mismatch (e.g., expected string, found integer). Property read or write with incompatible type. <code>EmptyField</code> A required field or property is missing or empty. Validation of incomplete holon data. <code>MissingDescriptor</code> The holon lacks an associated type descriptor. Loader or schema definition error. <code>MissingRelationship</code> A requested relationship does not exist. Using an undefined relationship name. <code>DuplicateKey</code> Attempted to create or stage a holon with a key that already exists. Staging or import conflicts. <code>StagingConflict</code> Two staged holons conflict on lineage or key. Concurrent edits in the Nursery. <code>CommitFailure</code> One or more holons failed to commit. DHT or persistence layer error. <code>Abandoned</code> The holon was marked abandoned during commit. Validation failure during persistence. <code>InvalidContext</code> The provided context is invalid or no longer active. Using an expired or mismatched context reference. <code>SerializationError</code> Failure to encode or decode a holon or property value. Cross-boundary transmission or storage. <code>DeserializationError</code> Failure to parse persisted data into a holon. Import or cache corruption. <code>NetworkError</code> Communication failure with remote service or DHT. Distributed commit or fetch. <code>InternalError</code> Unexpected internal condition. Logic bugs or invariant violations."},{"location":"core/map-deployment-arch/#example-usage-in-pattern-matches","title":"Example usage in pattern matches","text":"<p><code>rust,ignore match commit(context) {     Ok(resp) if resp.is_complete() =&gt; println!(\"Commit succeeded!\"),     Ok(resp) =&gt; eprintln!(\"Partial commit: {:?}\", resp.summary()),     Err(HolonError::CommitFailure) =&gt; eprintln!(\"Commit failed.\"),     Err(HolonError::NetworkError) =&gt; eprintln!(\"Network issue, retry later.\"),     Err(e) =&gt; eprintln!(\"Unhandled error: {:?}\", e), }</code></p>"},{"location":"core/map-deployment-arch/#notes","title":"Notes","text":"<ul> <li>Most variants are recoverable \u2014 for example, <code>StagingConflict</code> and <code>DuplicateKey</code> can be retried after correction.</li> <li>Use <code>HolonError::to_string()</code> for concise error summaries in logs.</li> <li><code>InternalError</code> and <code>InvalidContext</code> indicate deeper systemic problems that typically warrant investigation.</li> </ul> <p>Together, these definitions provide a full picture of how the MAP reference layer communicates problems \u2014 predictably, type-safely, and with context.</p>"},{"location":"core/map-holons-testing-strategy/","title":"MAP testing follows two general approaches:","text":"<ol> <li>Sweetests leverage Rust's rstest testing framework.</li> <li>Tryorama tests leverages Holochain's Tryorama JavaScript-based testing framework.</li> </ol>"},{"location":"core/map-holons-testing-strategy/#sweetest-integration-tests","title":"Sweetest Integration Tests","text":""},{"location":"core/map-holons-testing-strategy/#test-contexts","title":"Test Contexts","text":"<p>The <code>HolonsContextBehavior</code> trait provides access to a space manager.</p> <pre><code>pub trait HolonsContextBehavior {\n    /// Provides access to the holon space manager for interacting with holons and their relationships.\n    fn get_space_manager(&amp;self) -&gt; Rc&lt;&amp;dyn HolonSpaceBehavior&gt;;\n}\n</code></pre> <p>Concrete implementations of that trait provide access to a HolonSpaceManager that has been configured for either client-side or guest-side use. Note that HolonSpaceManager is a holons_core component, so the source code is the same for both client and guest space managers. They differ in the HolonService they have been injected with upon initialization of their context.</p> <p>The <code>HolonSpaceBehavior</code> trait implemented by HolonSpaceManager provides access to a set of services.</p> <pre><code>pub trait HolonSpaceBehavior {\n    fn get_cache_access(&amp;self) -&gt; Arc&lt;dyn HolonCacheAccess&gt;;\n    fn get_holon_service(&amp;self) -&gt; Arc&lt;dyn HolonServiceApi&gt;;\n    fn get_nursery_access(&amp;self) -&gt; Arc&lt;RefCell&lt;dyn NurseryAccess&gt;&gt;;\n    fn get_space_holon(&amp;self) -&gt; Option&lt;HolonReference&gt;;\n    fn get_staging_behavior_access(&amp;self) -&gt; Arc&lt;RefCell&lt;dyn HolonStagingBehavior&gt;&gt;;\n    fn export_staged_holons(&amp;self) -&gt; SerializableHolonPool;\n    fn import_staged_holons(&amp;self, staged_holons: SerializableHolonPool);\n    fn get_transient_state(&amp;self) -&gt; Rc&lt;RefCell&lt;dyn HolonCollectionApi&gt;&gt;;\n}\n</code></pre> <p>There are three different contexts relevant to sweetests.</p>"},{"location":"core/map-holons-testing-strategy/#fixture_context-client-side","title":"fixture_context (client-side)","text":"<ul> <li> <p>Test fixtures are responsible for setting up the test steps for a given test case along with the test data (holons and relationships) those steps require. Notice that relationships are expressed via <code>HolonReferences</code>. The <code>fixture_context</code> allows access to the actually holon they being references by providing access to the services that resolve them: <code>CacheAccess</code> (for <code>SmartReferences</code>) or <code>NurseryAccess</code> (for <code>StagedReferences</code>).</p> </li> <li> <p>An empty context is initialized by each fixture and goes out of scope when the fixture ends. Fixture contexts are never shipped between client and guest and their <code>Nursery's</code> are never committed.</p> </li> </ul>"},{"location":"core/map-holons-testing-strategy/#test_context-client-side","title":"test_context (client-side)","text":"<ul> <li> <p>Each test case executes within its own client-side context. Test step executors (i.e., the rust functions that implement test steps), use the test_context to stage holons and their relationships (via the NurseryAccess service) and to get persisted holons and their relationships (via the CacheAccess service).</p> </li> <li> <p>an empty context is initialized by the <code>rstest_dance_test</code> function at the beginning of each test case execution and a reference to it (as a <code>&amp;dyn HolonsContextBehavior</code> trait object) is passed as a parameter to each test step executor.   if a test step invokes a dance, its <code>Nursery</code> is shipped to the guest-side via the <code>session_state</code> field on <code>DanceRequest</code>.</p> </li> <li>when the dance result is returned the <code>test_context</code> is restored from <code>session_state</code> so that any changes to the <code>Nursery</code> that were made by the guest are now reflected back in the client's <code>Nursery</code>.</li> <li>the <code>commit_dance</code> persists any staged holons in the <code>Nursery</code>. Once completed successfully, it clears the staged holons and keyed_index from the Nursery, making it available to stage additional holons and relationships.</li> </ul>"},{"location":"core/map-holons-testing-strategy/#guest_context-guest-side","title":"guest_context (guest-side)","text":"<ul> <li>The guest_context is used by dance implementation functions that rely on the space manager and the services it provides.</li> <li>When Dancer's dance function is invoked for a new DanceRequest, it initializes the guest_context from the session_state passed via the DanceRequest.</li> <li>The dancer passes a reference to the context (as a <code>&amp;dyn HolonsContextBehavior</code> trait object) to the DanceFunction it dispatches to handle the dance request.</li> <li>DanceFunctions may perform operations that add, remove, update or clear the Nursery.</li> <li>The dancer is responsible for including the updated Nursery via the session_state field in the DanceResponse.</li> </ul>"},{"location":"core/map-holons-testing-strategy/#rstest_dance_tests-function","title":"rstest_dance_tests Function","text":"<p>Sweetests are organized around a set of test cases. Since the external API to the MAP guest is organized around dances, all integration testing is driven from the dances crate -- specifically, the <code>rstest_dance_tests</code> function defined in the <code>dances_tests.rs</code> module.</p> <pre><code>#[rstest]\n#[case::simple_undescribed_create_holon_test(simple_create_holon_fixture())]\n#[case::simple_add_related_holon_test(simple_add_remove_related_holons_fixture())]\n\n#[tokio::test(flavor = \"multi_thread\")]\nasync fn rstest_dance_tests(#[case] input: Result&lt;DancesTestCase, HolonError&gt;)\n</code></pre> <p>Notice this function is parameterized by <code>#[case]</code>. Preceding the function declaration with one or more <code>#[case]</code> statements allows selective control over which test cases are invoked in any given test run. For example, the following code will result in the <code>rstest_dance_tests</code> function being invoked twice -- once for the <code>simple_undescribed_create_holon_test</code> case and once for the <code>simple_add_related_holon_test</code> case. Each test case is invoked asynchronously and independently from other test cases.</p> <p>Each case has an associated fixture function that sets up the test steps and associated data for that test case and returns a <code>DancesTestCase</code> object that is passed as an input parameter to the <code>rstest_dance_tests</code> function. Every test case follows the same basic flow: 1. Initialization -- sets up tracing, a mock conductor, an empty <code>HolonsContext</code>, and an empty <code>test_state</code>. Note that <code>test_context</code> is different from the <code>fixture_context</code> used by the fixture and the <code>guest_context</code> used by the back-end (guest-side) during dance execution (as described above). 2. Test Step Execution. Unpack the test case and iterate through the steps for that test case. Matching on the test step allows different <code>execute_xxx</code> functions to be dispatched for each kind of test step.</p> <p>The <code>test_state</code> accumulates state as the test case progresses and a mutable reference to it is passed into every test step executor.</p> <pre><code>// from dances/tests/shared_test/test_data_types.rs\npub struct DanceTestState {\n    pub session_state: SessionState,\n    pub created_holons: BTreeMap&lt;MapString, Holon&gt;,\n}\n</code></pre> <p>The <code>session_state</code> field holds the state that is ping-ponged back and forth between client and guest. The <code>created_holons</code> map allows holons that have been successfully committed during the execution of this test case to be retrieved via their key in later test steps.</p> <pre><code>// from dances/src/session_state.rs\npub struct SessionState {\n    staging_area: StagingArea,\n    local_holon_space: Option&lt;HolonReference&gt;,\n}\n\n// from dances/src/staging_area.rs\npub struct StagingArea {\n    staged_holons: Vec&lt;Holon&gt;,         // Contains all holons staged for commit\n    index: BTreeMap&lt;MapString, usize&gt;, // Allows lookup by key to staged holons for which keys are defined\n}\n</code></pre> <p>The <code>session_state</code> is included as part of the <code>DanceRequest</code> by the <code>build_xxx_</code> function. It is part of every dance call and is restored from the <code>DanceResponse</code> when a response is received.</p> <p>```let response: DanceResponse = conductor.call(&amp;_cell.zome(\"dances\"), \"dance\", valid_request).await; _test_state.session_state = response.state.clone(); <pre><code>## Test Fixtures\nEach case has an associated fixture function that sets up the test steps and associated data for that test case and returns a `DancesTestCase` object that is passed as an input parameter to the `rstest_dance_tests` function. The fixture can stage a set of holons and relationships in its `fixture_context`. Such holons can be supplied to the `test_steps` the fixture is setting up in order to supply the data required by that `test_step`.\n\n## Test Data Types\n\nWe have defined a set of data structures and protocols designed to make it easier to quickly define test cases.\n\n### DanceTestStep\n\nEach test case is composed of a set of test steps. Test steps are defined independently so that may be reused in different test cases. The `DanceTestStep` enum defines the set of available test steps and the data associated with each test step. Here is an excerpt:\n</code></pre> pub enum DanceTestStep {   AbandonStagedChanges(StagedReference, ResponseStatusCode), // Marks a staged Holon as 'abandoned'     AddRelatedHolons(         StagedReference,         RelationshipName,         Vec,         ResponseStatusCode,         Holon,     ), // Adds relationship between two Holons     Commit,       <p>} <pre><code>Each test step generally invokes one or more dances.\n\n### DancesTestCase\n\nEach test case is defined by an instance of DancesTestCase:\n</code></pre> pub struct DancesTestCase {     pub name: String,     pub description: String,     pub steps: VecDeque,     pub test_session_state: TestSessionState, } <p>pub struct TestSessionState {     transient_holons: SerializableHolonPool, } <pre><code>Including `test_session_state` in the `DancesTestCase` allows the TransientHolons created by a fixture to be passed from the `fixture_context` into the `test_context`. As part of its initialization sequence, the `rstest_dance_tests` function initializes its `test_context` from the `test_session_state`. This means the `test_context's` TransientHolonManager will start with its HolonPool in the same state as the `fixture_context's` HolonPool. **_Key Takeaway: any TransientReferences created by the fixture are resolvable within the test_context_**. However, the fixtures Nursery is NOT passed into the test context. This means that StagedReferences created in the fixture are NOT resolvable in the `test_context`. For this reason, _**fixtures should NOT, themselves, stage any holons.**_\n\nNotice that the test case defines a sequential set of steps. `DancesTestCase` offers a set of `add_xxx_step` methods that allow test steps to be added to the test case, where xxx specifies a particular a specific test step. For example, the following method adds a stage_holon_step to test case.\n</code></pre>  pub fn add_stage_holon_step(&amp;mut self, holon: TransientReference) -&gt; Result&lt;(), HolonError&gt; {         self.steps.push_back(DanceTestStep::StageHolon(holon));         Ok(())     } <pre><code>Notice the holon to be staged is identified via its TransientReference. Since this reference will resolve in the test_context, the test_stage_new_holon function can resolve that reference during test execution.\n\n### Referencing Holons Staged or Saved within a Test Case Execution\n\nSome test cases require the ability to refer to holons staged or saved in earlier test steps. For example, suppose I want to add related holons (either staged or saved) to a holon staged in a prior step. Likewise, in the `stage_new_from_clone` test case we want to test the ability so clone a transient holon, staged holon, and saved holon (to make sure all three possibilities are tested).\n\nThe fixture doesn't know what temporary id the test executor will assign for the holons staged during the test, nor does it know what HolonId will be assigned by holochain for holons committed to the DHT during the test. **_So how can it pass references to those holon to subsequent steps it is adding to the test case?_**\n\n\n### Current Approach: Test References and DanceTestExecutionState\n\nOur current solution was implemented prior to the introduction of the TransientHolonManager. This section describes the current approach and is then followed by a proposed approach.\n</code></pre> pub struct DanceTestExecutionState {     context: Arc,     pub dance_call_service: Arc&gt;,     pub created_holons: BTreeMap, } <pre><code>### TestReference\n\n`TestReferences` are created by fixtures. They are used to pass references to holons created in prior test steps to be passed into subsequent test steps. For example, the `simple_stage_new_from_clone_fixture`:\n\n1. Stages several holons into the fixture's Nursery\n2. Adds a `stage_new_from_clone_step` to the TestCase that (during execution phase) will stage a new holon that is a clone of one of the previously staged holons.\n2. Adds a stageClones the staged holon\n3. Phase 2 clones a saved holon, changes some of its\\n\\\n   properties, adds a relationship, commits it and then compares essential content of existing \\n\\\n   holon and cloned holon\n</code></pre> pub enum TestReference {     SavedHolon(MapString),     StagedHolon(StagedReference),     TransientHolon(TransientReference), } ```"},{"location":"core/map-holons-testing-strategy/#tryorama-tests-tbd","title":"Tryorama Tests (TBD)","text":""},{"location":"core/map-onboarding-experience/","title":"\ud83c\udf00 \u201cPut Yourself on the MAP\u201d","text":""},{"location":"core/map-onboarding-experience/#from-memetic-perimeter-to-living-spiral-onboarding","title":"From Memetic Perimeter to Living Spiral Onboarding","text":"<p>This document represents a first cut at defining the experience of discovering the MAP and initial on-boarding. It is presented in three parts:</p> <ul> <li>Part I \u2014 The Memetic Perimeter -- how the invitation to \"Put Yourself on the MAP\" is presented and discovered in the broader world.</li> <li>Part II:  The Living Spiral: Non-Linear Onboarding Ecology -- general outline and principles of the on-boarding experience</li> <li>Part III: MAP Onboarding Storyboard Narrative -- a narrative vision for the on-boarding experience</li> </ul>"},{"location":"core/map-onboarding-experience/#part-i-the-memetic-perimeter","title":"Part I \u2014 The Memetic Perimeter","text":""},{"location":"core/map-onboarding-experience/#the-outer-membrane-of-discovery-attraction-not-promotion","title":"The Outer Membrane of Discovery: Attraction, Not Promotion","text":""},{"location":"core/map-onboarding-experience/#the-common-line","title":"The Common Line","text":"<p>Across every artifact of the MAP\u2019s outer membrane \u2014 every card, video, micro-site, or whispered story \u2014 one phrase repeats like a heartbeat:</p> <p>Put yourself on the MAP.</p> <p>It is more than a tagline. It is a call to presence, to sovereignty, to participation in a living world of meaning. It names the transition from the attention-driven internet to a network of trust, consent, and life-aligned relationship.</p>"},{"location":"core/map-onboarding-experience/#what-it-means","title":"What It Means","text":""},{"location":"core/map-onboarding-experience/#1-a-return-to-place","title":"1. A Return to Place","text":"<p>Putting yourself on the MAP begins literally: locating yourself in the web of life \u2014 your watershed, your bioregion, your community, your culture. It says: You belong somewhere. Start there.</p>"},{"location":"core/map-onboarding-experience/#2-an-act-of-sovereignty","title":"2. An Act of Sovereignty","text":"<p>To put yourself on the MAP is to own your data, your story, and your relationships. No corporation curates you. No platform defines you. You create your own I-Space \u2014 a private grove where you hold your values, promises, and intentions.</p>"},{"location":"core/map-onboarding-experience/#3-an-invitation-to-connection","title":"3. An Invitation to Connection","text":"<p>You decide what parts of yourself you want to express \u2014 through personas and promises \u2014 and where you wish to connect. Putting yourself on the MAP doesn\u2019t expose you; it makes you discoverable to resonance.</p>"},{"location":"core/map-onboarding-experience/#4-a-gesture-of-alignment","title":"4. A Gesture of Alignment","text":"<p>Each artifact that carries this invitation is a memetic signal: \u201cHere is a doorway to coordination grounded in consent and care.\u201d It\u2019s not a call to sign up \u2014 it\u2019s a call to coherence.</p>"},{"location":"core/map-onboarding-experience/#how-it-appears-across-the-memetic-perimeter","title":"How It Appears Across the Memetic Perimeter","text":"<p>Printed Seeds A small hand-made card in a library book or caf\u00e9:</p> <p>\u201cPut yourself on the MAP \u2014 begin with your values.\u201d A short URL or QR code leads to a minimalist landing page that opens with silence, beauty, and curiosity.</p> <p>Micro-Sites One sentence fades in:</p> <p>\u201cPut yourself on the MAP.\u201d Scrolling reveals what it means \u2014 not as features, but as experiences: privacy, resonance, belonging.</p> <p>Short Films / Audio Spots Whispered or sung:</p> <p>\u201cPut yourself on the MAP \u2014 where your presence matters and your data stays yours.\u201d</p> <p>Collaborative Art Murals or exhibitions depicting constellations of light, each point a person:</p> <p>\u201cEvery spark is a story. Put yourself on the MAP.\u201d</p> <p>Partnership Placements Regenerative projects, learning centers, and commons initiatives include a quiet footer line:</p> <p>\u201cPart of the Memetic Activation Platform \u2014 put yourself on the MAP.\u201d</p>"},{"location":"core/map-onboarding-experience/#the-meaning-framework","title":"The Meaning Framework","text":"Dimension Phrase Emotional Tone Self \u201cPut yourself\u201d Empowerment, agency, dignity Relation \u201con\u201d Connection, belonging, interdependence System \u201cthe MAP\u201d Living intelligence, shared orientation, regenerative flow <p>Together they form an invocation:</p> <p>You matter. You belong. You can help weave what comes next.</p>"},{"location":"core/map-onboarding-experience/#visual-language","title":"Visual Language","text":"<ul> <li>The words \u201cPut yourself on the MAP\u201d should always appear with organic motion \u2014 pulsing, breathing, or unfolding like mycelial growth.</li> <li>Use light gradients that evoke dawn, emergence, or bioluminescence.</li> <li>Typography should feel hand-touched or alive, not corporate.</li> <li>The phrase may sit beside a subtle symbolic MAP mark \u2014 a small pulse or seed pattern representing the living network.</li> </ul>"},{"location":"core/map-onboarding-experience/#integrating-into-the-threshold-experience","title":"Integrating into the Threshold Experience","text":"<p>When a person follows any invitation from the outer membrane, the first screen or sound they meet should greet them with that same line:</p> <p>\u201cWelcome. You\u2019re about to put yourself on the MAP.\u201d</p> <p>Then:</p> <p>\u201cHere, nothing watches you. Nothing owns you. You begin as yourself.\u201d</p> <p>From there the onboarding unfolds \u2014 cultivation of the I-Space, expression of the first LifeCode, discovery of resonant spaces.</p>"},{"location":"core/map-onboarding-experience/#why-this-matters","title":"Why This Matters","text":"<p>A unified line creates coherence across all outer-world artifacts without turning them into advertisements. It anchors the experience in a single memetic gesture that is both simple and profound \u2014 a phrase anyone can say, gift, or remember.</p> <p>\u201cPut yourself on the MAP\u201d becomes a living mantra of self-sovereignty and planetary belonging. Every time it appears, it carries the same gentle promise:</p> <p>There is a world where your presence is honored, your data is yours, and your participation helps life thrive. Put yourself on the MAP.</p>"},{"location":"core/map-onboarding-experience/#part-ii-the-living-spiral-non-linear-onboarding-ecology","title":"\ud83c\udf00 Part II:  The Living Spiral: Non-Linear Onboarding Ecology","text":""},{"location":"core/map-onboarding-experience/#iterative-reciprocal-and-ever-evolving","title":"Iterative, Reciprocal, and Ever-Evolving","text":""},{"location":"core/map-onboarding-experience/#core-metaphor","title":"Core Metaphor","text":"<p>Onboarding in the MAP isn\u2019t a staircase \u2014 it\u2019s a spiral garden. Each loop through the spiral deepens self-understanding, branches new relationships, and reveals previously invisible ecosystems of relation.</p> <p>Every seed you plant in your LifeCode changes what becomes visible to you. Every connection you form feeds new nutrients back into your LifeCode.</p>"},{"location":"core/map-onboarding-experience/#the-feedback-loops","title":"The Feedback Loops","text":""},{"location":"core/map-onboarding-experience/#lifecode-persona-connection-reflection-lifecode","title":"LifeCode \u2192 Persona \u2192 Connection \u2192 Reflection \u2192 LifeCode","text":"<ol> <li>You articulate a few core values and principles in your LifeCode.</li> <li>You choose a facet of that LifeCode to make visible as a Persona.</li> <li>That persona\u2019s inquiries reveal matching invitations in shared Connection Spaces.</li> <li>Encounters inspire Reflection, prompting edits or expansions of your LifeCode.</li> <li>The loop repeats \u2014 each cycle widens your field of resonance and depth of alignment.</li> </ol>"},{"location":"core/map-onboarding-experience/#promise-agreement-weave-threshold-promise","title":"Promise \u2192 Agreement \u2192 Weave \u2192 Threshold \u2192 Promise","text":"<ol> <li>You make and fulfill Promises that generate Agreements.</li> <li>Agreements interlink into living Promise Weaves.</li> <li>Weaves surface sustainability thresholds \u2014 awareness of Vital Capital balance.</li> <li>Those thresholds reshape what Promises you feel ready to make next.</li> </ol> <p>DAHN gently supports these loops with soft prompts like:</p> <p>\u201cThis new value has opened five nearby Connection Spaces. Would you like to explore them?\u201d</p>"},{"location":"core/map-onboarding-experience/#dynamic-visibility","title":"Dynamic Visibility","text":"<p>Nothing is ever static or globally exposed.</p> <ul> <li>Adding a value doesn\u2019t broadcast it \u2014 it merely changes what you can perceive.</li> <li>Joining a Space doesn\u2019t expose your I-Space \u2014 it expands your membrane of visibility.</li> <li>Refining a Persona retunes the filters through which invitations appear.</li> </ul> <p>Discovery becomes a dance of mutual revelation \u2014 a living field rather than a recommendation engine.</p>"},{"location":"core/map-onboarding-experience/#the-spiral-experience-architecture","title":"The Spiral Experience Architecture","text":"Cycle Emotional Tone Key Gestures System Response First Planting Wonder, curiosity Add LifeCode seeds New memes unlock in Planetary Space First Persona Playful courage Sculpt and release an aspect of self Connection Spaces shimmer into view First Connection Recognition Accept an invitation Persona signs its first Agreement First Reflection Integration Journal, refine, withdraw Updated LifeCode re-syncs resonance map Subsequent Spirals Agency, coherence Mix new LifeCode and Persona layers Broader ecosystems reveal themselves <p>Each return to the garden shows growth \u2014 previous choices persist as living holons, not static forms.</p>"},{"location":"core/map-onboarding-experience/#design-principles-for-iterative-flow","title":"Design Principles for Iterative Flow","text":"Principle Design Expression Non-linearity DAHN never \u201clocks\u201d you into next steps; it offers soft prompts based on resonance. Reciprocal Disclosure Visibility grows symmetrically \u2014 you only see what you\u2019ve become able to meet. Cumulative Trust Each Agreement expands your trust quotient and safe connection range. Evolutionary Aesthetics Visuals and soundscapes subtly evolve with each iteration \u2014 your world literally grows. Time as Ally Nothing demands completion; you can pause mid-loop and return later \u2014 continuity is organic."},{"location":"core/map-onboarding-experience/#narrative-reframe","title":"Narrative Reframe","text":"<p>Replace \u201conboarding\u201d with \u201cTaking Root on the MAP.\u201d Each person\u2019s path is organic, seasonal, and unique. DAHN visualizes this as a living mycelial map \u2014 new threads pulsing outward as LifeCode and Persona co-evolve.</p>"},{"location":"core/map-onboarding-experience/#emotional-arc-of-iteration","title":"Emotional Arc of Iteration","text":"Cycle Inner Feeling Outer Expression Awakening Safe solitude Cultivating the private grove Exploration Playful discovery Creating and releasing a persona seed Encounter Resonance and surprise Doorways opening, invitations arriving Integration Gratitude and coherence Revising LifeCode, pruning and reseeding Renewal Empowered curiosity Planting new seeds, branching further"},{"location":"core/map-onboarding-experience/#summary-insight","title":"Summary Insight","text":"<p>The MAP\u2019s onboarding is not an entry procedure but the first living weave between self-definition and world participation. Every act of expression reshapes what the MAP can reveal to you. Every discovery refines who you are becoming.</p>"},{"location":"core/map-onboarding-experience/#part-3-map-onboarding-storyboard-narrative","title":"\ud83c\udf33 Part 3: MAP Onboarding Storyboard Narrative","text":""},{"location":"core/map-onboarding-experience/#from-invitation-to-belonging-a-journey-of-sovereign-discovery","title":"From Invitation to Belonging \u2014 A Journey of Sovereign Discovery","text":""},{"location":"core/map-onboarding-experience/#scene-1-the-invitation","title":"Scene 1 \u2014 The Invitation","text":"<p>Setting: The open world. A person encounters a small, beautiful artifact \u2014 a handmade card, a whispered story, a quiet film, or a word-of-mouth gesture. Across it, a single line:</p> <p>\u201cPut yourself on the MAP.\u201d</p> <p>It feels different \u2014 not a promotion, but an invitation. No pressure. No demand. Just curiosity and care.</p> <p>Voiceover / Copy:</p> <p>\u201cThere is a world beyond the noise \u2014 a place where technology serves life. A place where your presence matters, and your data remains yours. You are invited to take your place in that living web.\u201d</p> <p>They scan the code or follow the link. A minimal, luminous page unfolds \u2014 soft motion, organic sound.</p> <p>\u201cYou are about to step from the open web into a sovereign world of relationships. Here, nothing watches you. Nothing owns you. You begin as yourself.\u201d</p> <p>They accept \u2014 and cross the threshold.</p>"},{"location":"core/map-onboarding-experience/#scene-2-arrival-the-private-grove","title":"Scene 2 \u2014 Arrival: The Private Grove","text":"<p>Setting: A quiet, living landscape \u2014 the interior of their new I-Space. There is no sign-up form. No profile picture. Only a feeling of safety and possibility.</p> <p>Voiceover / Copy:</p> <p>\u201cThis is your garden \u2014 your Data Grove. It lives on your devices. Nothing here leaves without your consent.\u201d</p> <p>They are welcomed not as a user, but as a steward. A soft prompt invites reflection:</p> <p>\u201cWho are you when nobody is watching?\u201d</p> <p>Around them, the DAHN interface shows fertile soil, open space, and faint pathways waiting to be formed.</p>"},{"location":"core/map-onboarding-experience/#scene-3-cultivating-the-lifecode","title":"Scene 3 \u2014 Cultivating the LifeCode","text":"<p>They begin to articulate what matters most \u2014 their values, principles, aspirations, and ways of knowing. It\u2019s not a checklist, but a creative act: planting seeds, arranging constellations, weaving threads.</p> <p>Voiceover / Copy:</p> <p>\u201cYour LifeCode is your inner compass \u2014 the pattern of values, intentions, and meaning that guide your choices. Start with what feels alive in you.\u201d</p> <p>They can draw from shared memes and principles in the Global Meme Pool, or write their own. Each addition causes subtle ripples \u2014 their world begins to shimmer with latent potential.</p>"},{"location":"core/map-onboarding-experience/#scene-4-creating-a-persona","title":"Scene 4 \u2014 Creating a Persona","text":"<p>As they complete their first LifeCode seeds, a question emerges:</p> <p>\u201cWhich part of yourself would you like to share?\u201d</p> <p>They sculpt a Persona \u2014 a partial expression of self, drawn from their LifeCode but distinct from it. This Persona carries its own cryptographic key, allowing both sovereignty and selective visibility.</p> <p>Voiceover / Copy:</p> <p>\u201cA Persona is your bridge to the world \u2014 a facet of your being, offered in trust. It carries only what you choose to reveal, and it signs only what you promise to honour.\u201d</p> <p>Creating a Persona feels like donning a ceremonial mask \u2014 personal, aesthetic, intentional.</p>"},{"location":"core/map-onboarding-experience/#scene-5-the-first-enquiry","title":"Scene 5 \u2014 The First Enquiry","text":"<p>With their Persona alive, a new option appears:</p> <p>\u201cWould you like to connect with others around these values?\u201d</p> <p>They craft a Join Enquiry \u2014 a statement of curiosity and intent:</p> <p>\u201cI\u2019m looking to connect with others exploring regenerative education in my region.\u201d or \u201cI\u2019m seeking fellow travellers interested in ethical AI and planetary care.\u201d</p> <p>They send the Enquiry into the Connection Space. No feeds. No algorithms. Only resonance.</p>"},{"location":"core/map-onboarding-experience/#scene-6-discovery-in-connection-space","title":"Scene 6 \u2014 Discovery in Connection Space","text":"<p>The Connection Space comes alive \u2014 a cosmos of glowing doorways. Each doorway represents an Agent Space: a bioregion, a practice community, an art collective, a commons.</p> <p>Each has its own imagery, music, and tone \u2014 its LifeCode expressed as invitation. They hover over one: Regenerating Earth. A short soundscape plays \u2014 water, birdsong, human laughter.</p> <p>Voiceover / Copy:</p> <p>\u201cEvery Space you see here is alive \u2014 a membrane of shared intention. Some are near your bioregion. Others share your principles. Each one invites you to cross its threshold.\u201d</p>"},{"location":"core/map-onboarding-experience/#scene-7-crossing-a-membrane","title":"Scene 7 \u2014 Crossing a Membrane","text":"<p>They approach an invitation that resonates. The visual changes \u2014 an illuminated gateway, text slowly appearing:</p> <p>\u201cTo enter this Space, you must honour these Promises: \u2022 To act with care for all life. \u2022 To share knowledge freely within the commons. \u2022 To uphold honesty and mutual respect.\u201d</p> <p>They read, feel, and consent.</p> <p>Their Persona signs the Agreement \u2014 cryptographically, ceremonially. The gateway opens, light flows through. They step inside.</p>"},{"location":"core/map-onboarding-experience/#scene-8-first-belonging","title":"Scene 8 \u2014 First Belonging","text":"<p>Inside the new Space \u2014 perhaps a bioregional network or learning community \u2014 they\u2019re greeted by introductions, shared resources, and invitations to contribute.</p> <p>A Weave map glows faintly, showing flows of Vital Capital \u2014 care, knowledge, attention \u2014 moving among participants.</p> <p>Voiceover / Copy:</p> <p>\u201cWelcome. You\u2019ve joined a living ecosystem \u2014 not a platform, but a partnership. Here, belonging is cultivated through promises kept, and value flows through trust.\u201d</p> <p>The feeling is not transactional \u2014 it\u2019s participatory, real, and human.</p>"},{"location":"core/map-onboarding-experience/#scene-9-reflection-and-return","title":"Scene 9 \u2014 Reflection and Return","text":"<p>Back in their I-Space, DAHN displays the new threads now connecting their garden to the wider MAP. The soil looks richer, alive with colour.</p> <p>A prompt appears:</p> <p>\u201cHow did this connection change you? Would you like to evolve your LifeCode?\u201d</p> <p>They revise a few values, add new inspirations, maybe prune some old ones. The system quietly notes new resonances, unlocking fresh potential connections. The spiral turns again.</p>"},{"location":"core/map-onboarding-experience/#scene-10-the-living-spiral","title":"Scene 10 \u2014 The Living Spiral","text":"<p>Over time, they repeat this dance: - Refining their LifeCode - Creating new Personas - Exploring new Connection Spaces - Joining and stewarding new Weaves</p> <p>Each cycle deepens coherence, widens perspective, and strengthens trust.</p> <p>Voiceover / Copy:</p> <p>\u201cOn the MAP, every act of expression reshapes what the world can reveal to you. Every connection refines who you are becoming. You are not a user \u2014 you are a participant in a living civilisation.\u201d</p> <p>The onboarding experience never ends \u2014 it evolves.</p>"},{"location":"core/map-onboarding-experience/#scene-11-belonging-to-the-planetary-field","title":"Scene 11 \u2014 Belonging to the Planetary Field","text":"<p>As their engagement deepens, they begin to sense the full Planetary Space \u2014 a shimmering holon of bioregional networks, creative collectives, and shared LifeCodes forming a planetary organism.</p> <p>Voiceover / Copy:</p> <p>\u201cTogether we are remembering what it means to live in partnership with life. Every new Space, every fulfilled Promise, strengthens the planetary field. You are part of that weave now.\u201d</p> <p>The DAHN zooms out \u2014 thousands of luminous nodes connected by threads of trust and meaning. Their I-Space glows among them \u2014 sovereign, private, yet fully connected.</p>"},{"location":"core/map-onboarding-experience/#closing-scene-integration","title":"Closing Scene \u2014 Integration","text":"<p>The final prompt:</p> <p>\u201cYou are home. You are sovereign. You are part of the weave. Keep tending your garden. Keep putting yourself on the MAP.\u201d</p> <p>Soft music fades. The scene dissolves back to their private grove, now full of life.</p> <p>End of Onboarding Journey \u2014 Beginning of Participation.</p>"},{"location":"core/map-type-system-revised/","title":"MAP Type System","text":"<p>The MAP Type System provides a holonic, self-describing, and extensible foundation for representing knowledge in an agent-centric world. Every type in MAP is a holon \u2014 a versioned, queryable, and linkable unit of meaning. Every holon is, in turn, typed \u2014 grounded in a rich schema of interrelated descriptors.</p> <p>This holonic approach means:</p> <ul> <li>Types can describe types.</li> <li>Types can inherit from other types.</li> <li>Types can be extended, queried, and versioned just like data.</li> </ul> <p>The MAP Type System enables agents to: - Define their own schemas and vocabularies - Share and evolve types collaboratively - Validate, introspect, and visualize holons at runtime</p> <p></p> <p>This document introduces the architecture of the MAP Type System, structured into three foundational layers and supported by unified schema import, key rules, and introspection semantics.</p>"},{"location":"core/map-type-system-revised/#1-introduction-what-is-the-map-type-system","title":"1. Introduction: What Is the MAP Type System?","text":"<p>The MAP Type System is: - \ud83e\udde0 Self-describing \u2014 Every type is a holon, and every holon can describe itself. - \ud83e\uddf1 Compositional \u2014 Holons can be connected through typed relationships to build meaningful graphs. - \ud83d\udd0d Introspectable \u2014 Any holon can answer:   \u2192 What kind of Holon am I?   \u2192 What properties do I have?   \u2192 What relationships do I participate in? - \ud83c\udf31 Extensible \u2014 Agents can define new types without altering the core codebase.</p>"},{"location":"core/map-type-system-revised/#maps-ontology-as-data-meta-modeling-approach","title":"MAP\u2019s Ontology-as-Data Meta-Modeling Approach","text":"<p>The Memetic Activation Platform (MAP) models its entire ontology as data\u2014not as code, not as syntax-bound models, but as a fully introspectable, declarative system of holons. Every type, property, relationship, and rule in the MAP ecosystem is represented as a holon\u2014a data entity described by other data entities\u2014creating a self-describing, semantically rigorous system.</p>"},{"location":"core/map-type-system-revised/#what-it-is","title":"What It Is","text":"<ul> <li>Ontology-as-data: All type system elements (e.g. <code>BookType</code>, <code>MetaEnumValueType</code>, <code>MapStringValueType</code>) are modeled as structured data instances. These are holons described by <code>TypeDescriptor</code> holons, forming a fully reflective type graph.</li> <li>Declarative architecture: Relationships, constraints, and inheritance are declared explicitly, rather than implied by code or assumed by syntax. Examples include <code>Extends</code>, <code>InstanceProperties</code>, and <code>UsesKeyRule</code>.</li> <li>Syntax-independent: The data model is not coupled to any specific concrete syntax like OWL, LinkML, JSON Schema, or Ecore. This allows MAP to remain neutral and flexible.</li> <li>Portable and generative: Because the ontology is described entirely in data, it can be programmatically transformed into any number of target modeling formats, including OWL (RDF), Ecore, LinkML, JSON Schema, or domain-specific APIs.</li> </ul>"},{"location":"core/map-type-system-revised/#why-this-matters","title":"Why This Matters","text":"<ul> <li>Interoperability: By remaining syntax-agnostic, MAP avoids vendor lock-in and promotes compatibility across tooling ecosystems.</li> <li>Transparency and introspection: Every element of the type system is visible and inspectable\u2014users and systems can query, reason about, and validate types and their relationships using the same underlying structures.</li> <li>Extensibility: New type kinds, validation rules, or relationship semantics can be introduced declaratively without requiring changes to core code or parsers.</li> <li>Automation: The data-native structure supports auto-generation of syntax-bound schemas, documentation, forms, validators, and converters across ecosystems.</li> <li>Evolvability: Standards, formats, and tools evolve over time. By anchoring the MAP ontology in a neutral, declarative core, it remains resilient to external changes. New representations can be generated as needed, without requiring redefinition of the underlying semantics.</li> </ul>"},{"location":"core/map-type-system-revised/#a-foundation-for-federated-semantics","title":"A Foundation for Federated Semantics","text":"<p>This architecture positions MAP not just as a platform, but as a semantic engine capable of supporting fluid translation between formal modeling environments. It is particularly well-suited to decentralized systems, federated knowledge graphs, and commons-oriented technology\u2014where semantic clarity, flexibility, and sovereignty are paramount.</p>"},{"location":"core/map-type-system-revised/#2-organizing-the-map-type-system","title":"2. Organizing the MAP Type System","text":"<p>At the heart of the MAP architecture is a self-describing type system built entirely from data. The foundational building block of this system is the TypeDescriptor\u2014a holon that defines the structure, semantics, and constraints of a particular type within MAP. These TypeDescriptors describe not only data instances, but also other types, enabling a fully introspectable and evolvable modeling framework.</p> <p>A relatively small number of these type descriptors are \"built-in\" to the MAP. These provide the foundation from which an open-ended set of types can be derived.</p> <p>TypeDescriptors are grouped into schemas, which are cohesive collections of related type definitions. Each schema defines its own conceptual namespace and boundary of meaning. In turn, every schema is stewarded within a single HolonSpace, anchoring it in a governance and trust context. While a schema belongs to exactly one HolonSpace, it may be referenced by types or instances across other spaces, supporting reuse and interoperability without centralization.</p> <p>This layered organization follows a clear pattern:</p> <ul> <li>TypeDescriptors define types.</li> <li>Schemas group TypeDescriptors.</li> <li>HolonSpaces steward schemas.</li> </ul> <p>This structure allows types to evolve in well-bounded contexts while participating in broader federated semantics.</p>"},{"location":"core/map-type-system-revised/#type-kind-a-semantic-organizing-principle","title":"Type Kind: A Semantic Organizing Principle","text":"<p>Every TypeDescriptor in MAP declares a type kind\u2014a high-level classification that serves dual purposes:  1. Organizational: They help group and reason about types across schemas. All <code>Relationship</code> types, for instance, share common structural expectations and validation behavior. 2. Semantic: They convey the ontological category of the type\u2014what kind of \"thing\" it is in the MAP worldview.</p> <p>In this way, Type Kind functions as a semantic meta-tag that informs how a type is expected to behave, how it is validated, and how it can be composed within other types. While it doesn't encode structure directly (like <code>DescribedBy</code> or <code>Extends</code>), <code>type_kind</code> plays a central role in how types are declared, introspected, and extended across the system.</p>"},{"location":"core/map-type-system-revised/#complete-list-of-type-kinds","title":"$ \ud83d\udcda Complete List of Type Kinds","text":"<p>The current set of supported Type Kinds is listed in the following table. This set will continue to evolve as the MAP matures. Adding Type Kinds (e.g., adding support for a Value(Video) Type Kind) requires a new MAP release. Adding <code>TypeDescriptors</code> does not. </p> Type Kind Category Description <code>Holon</code> Structural Describes a type that classifies data-bearing holons <code>Property</code> Structural Describes a scalar property of a holon <code>Relationship</code> Structural Describes a directed link between holons <code>EnumVariant</code> Structural Describes a variant in a defined enum <code>Collection</code> Structural Describes a named group or set of holons <code>Dance</code> Behavioral Describes an interactive protocol or workflow <code>Value(String)</code> Scalar Value A scalar value based on a string <code>Value(Integer)</code> Scalar Value A scalar value based on an integer <code>Value(Boolean)</code> Scalar Value A scalar value based on a boolean <code>Value(Enum)</code> Scalar Value A scalar value selected from a known enumeration <code>Value(Bytes)</code> Scalar Value A binary value serialized as base64 <code>ValueArray(String)</code> Scalar Array An array of strings <code>ValueArray(Integer)</code> Scalar Array An array of integers <code>ValueArray(Boolean)</code> Scalar Array An array of booleans <code>ValueArray(Enum)</code> Scalar Array An array of enum values <code>ValueArray(Bytes)</code> Scalar Array An array of binary values"},{"location":"core/map-type-system-revised/#3-four-level-model","title":"3. Four-Level Model","text":"<p>To support full self-description, schema extensibility, and type safety, MAP organizes its entire type system using a four-level model. This layered structure spans from abstract meta-concepts to concrete, instantiable types and data.</p> <p></p> \ud83d\udd17 Compositional Inheritance via <code>Extends</code> <p>MAP embraces compositional inheritance as its primary structuring mechanism. Rather than relying on rigid class hierarchies, MAP types declare structure by extending other types \u2014 combining properties, relationships, and semantic expectations through composition.</p> <pre><code>The `Extends` relationship is used throughout the type system to:\n- Declare that a type fulfills the obligations of a more general type\n- Inherit shared properties and relationship definitions\n- Align a descriptor with the structural pattern of its kind\n\nThis enables:\n- Meta-types to declare required features (Level 1)\n- Abstract types to specialize those features per TypeKind (Level 2)\n- Concrete types to fulfill both (Level 3)\n\n&gt; Compositional inheritance keeps MAP types modular, transparent, and incrementally extensible \u2014 without locking them into brittle class hierarchies.\n</code></pre>"},{"location":"core/map-type-system-revised/#level-1-meta-types","title":"\ud83e\uddf1 Level 1: Meta-Types","text":"<p>Meta-types define the structural obligations for categories of types. Each meta-type declares: - Required <code>InstanceProperties</code> and <code>InstanceRelationships</code> (and, soon, <code>Validations</code> and <code>Dances</code>) - The <code>type_kind</code> it governs</p> <p>Examples: - <code>MetaPropertyType</code> defines the structure of all <code>PropertyType</code> descriptors - <code>MetaRelationshipType</code> defines shared expectations for relationship descriptors - <code>MetaTypeDescriptor</code> defines common expectations for all descriptor types</p> <p>These are the most abstract holons. They describe the kinds of type descriptors MAP supports.</p> <p>Top-Level Meta-types themselves extend nothing \u2014 their obligations are fulfilled for them, not by them. Meta-Types can have sub-meta types that <code>Extend</code> them (e.g., <code>MetaInverseRelationship</code> <code>Extends</code> <code>MetaRelationship</code>).</p>"},{"location":"core/map-type-system-revised/#level-2-abstract-type-descriptors","title":"\ud83e\udde9 Level 2: Abstract Type Descriptors","text":"<p>Abstract type descriptors <code>Extend</code> meta-types and anchor relationships for a type kind. </p> <p>Examples: - <code>PropertyType</code> extends <code>MetaPropertyType</code> - <code>HolonType</code> extends <code>MetaHolonType</code> - <code>EnumValueType</code> extends <code>MetaEnumValueType</code></p> <p>These abstract types are not instantiated directly. They serve as category-specific templates for concrete descriptors and provide end-points for core relationships.</p>"},{"location":"core/map-type-system-revised/#level-3-concrete-typedescriptors","title":"\ud83d\udce6 Level 3: Concrete TypeDescriptors","text":"<p>Concrete <code>TypeDescriptor</code> holons define actual, instantiable MAP types. These are the types agents use to define schemas and classify holons. Concrete type descriptors <code>Extend</code> (and fulfill the obligations of) BOTH <code>TypeDescriptor</code> AND the Abstract Type specific to their TypeKind</p> <p>Each concrete descriptor: - Extends both an Abstract Type and TypeDescriptor - Is a holon that participates in schemas - Carries metadata (<code>type_name</code>, <code>description</code>, etc.) - Declares structure via <code>InstanceProperties</code> and <code>InstanceRelationships</code></p> <p>Examples: - <code>BookType</code> extends <code>TypeDescriptor</code> and <code>HolonType</code> - <code>MapStringValueType</code> extends <code>TypeDescriptor</code> and <code>StringValueType</code> - <code>HAS_AUTHOR</code> extends <code>TypeDescriptor</code> and <code>DeclaredRelationshipType</code></p> <p>Every concrete type in MAP is described by a single, self-contained <code>TypeDescriptor</code>.</p>"},{"location":"core/map-type-system-revised/#level-4-instances-of-types","title":"\ud83d\udd01 Level 4: Instances of Types","text":"<p>These are the actual holons that populate MAP Spaces. They: - Are typed by one of the concrete type descriptors (via <code>DescribedBy</code>) - Include values for properties and relationships specified by their type - May be keyed or keyless, depending on the <code>UsesKeyRule</code> of their type</p> <p>Examples: - <code>\"Future Primal\"</code> is an instance of <code>BookType</code> - <code>\"title\"</code> is an instance of <code>PropertyName</code> - <code>\"LibrarySchema\"</code> is an instance of <code>SchemaName</code></p> <p>Holons in this layer are the data-level objects that conform to a schema.</p>"},{"location":"core/map-type-system-revised/#typedescriptor-the-keystone-type","title":"\ud83e\udde0 TypeDescriptor: The Keystone Type","text":"<p>The <code>TypeDescriptor</code> holon plays a special dual role in this hierarchy:</p> <ul> <li>It is a concrete type descriptor (Level 3)</li> <li>It is the type used to describe all other type descriptors, including itself (Level 4)</li> <li>It extends both <code>MetaTypeDescriptor</code> and <code>HolonType</code>, fulfilling the obligations of both</li> </ul> <p>This elegant recursion prevents infinite regress and anchors MAP\u2019s fully self-describing architecture.</p>"},{"location":"core/map-type-system-revised/#abstract-types-as-anchors","title":"\ud83e\udde9 Abstract Types as Anchors","text":"<p>In MAP, every relationship type (such as <code>DescribedBy</code>, <code>InstanceProperties</code>, or <code>ValueType</code>) must declare a <code>SourceType</code> and a <code>TargetType</code>. These define which types of holons a relationship is valid between.</p> <p>To support reusable relationships across many schemas and domains, MAP anchors relationship types to abstract type descriptors. For example: - The <code>DescribedBy</code> relationship has <code>HolonType</code> (abstract) as its <code>TargetType</code> - The <code>ValueType</code> relationship has <code>PropertyType</code> (abstract) as its <code>SourceType</code></p> <p>While these abstract types are not instantiable, they are valid, referenceable holons in their own right\u2014each described by a <code>TypeDescriptor</code>. This means they can serve as targets in relationships, enabling relationship types to be defined at the abstract level and reused across all concrete types that extend them.</p> <p>\ud83d\udd0d In practice: when a concrete type descriptor (like <code>BookType</code>) declares a relationship such as <code>HAS_AUTHOR</code>, the validation logic walks the <code>Extends</code> chain to ensure that the concrete type conforms to the <code>SourceType</code> and <code>TargetType</code> expectations anchored in the abstract layer.</p> <p>This leads to a clean separation: - Core relationships are defined once and anchored to abstract types. - Concrete descriptors, whether core or domain-specific, extend those abstract types and automatically participate in those relationships.</p>"},{"location":"core/map-type-system-revised/#validation-behavior","title":"Validation Behavior","text":"<p>The use of abstract types as anchors supports a flexible but robust validation model: - Holon instances must be <code>DescribedBy</code> a concrete type descriptor. - Relationship instances (e.g., SmartLinks) are validated by:   1. Looking up the <code>SourceType</code> and <code>TargetType</code> of the relationship's descriptor   2. Ensuring the instance's actual types extend (or are equal to) those expected types</p> <p>This allows core relationships to be broadly defined and applied without coupling them to specific schemas or concrete descriptors.</p>"},{"location":"core/map-type-system-revised/#domain-extensions","title":"Domain Extensions","text":"<p>Domain-specific types (e.g., <code>BookType</code>, <code>FilmType</code>) are: - <code>DescribedBy</code> \u2192 <code>TypeDescriptor</code> - <code>Extend</code> \u2192 their TypeKind's abstract template (e.g., <code>HolonType</code>)</p> <p>These extension types never extend a concrete core type like <code>HolonType</code>; instead, they instantiate their own concrete descriptors aligned with the abstract templates.</p> <p>This means that application developers never need to deal with meta-types or abstract scaffolding directly\u2014they simply define concrete types that extend templates and conform to a known pattern.</p>"},{"location":"core/map-type-system-revised/#design-principles-recap","title":"\ud83d\udccc Design Principles Recap","text":"<ul> <li>Each Type Kind has a single (top-level) Meta Type </li> <li>Meta Types declare a Type Kind\u2019s obligations via instance properties and instance relationships.</li> <li>Top-level Meta Types do not <code>Extend</code> anything \u2014 their obligations are fulfilled for them, not by them.</li> <li>Meta Types may have sub\u2013meta types that <code>Extend</code> them (e.g., <code>MetaInverseRelationship</code> <code>Extends</code> <code>MetaRelationship</code>).</li> <li>Abstract type descriptors <code>Extend</code> Meta Types and anchor core relationship types for a Type Kind.</li> <li>Each MAP type is <code>DescribedBy</code> a single concrete Type Descriptor.</li> <li><code>TypeDescriptor</code> declares the instance properties and instance relationships shared by all type descriptors (including itself).</li> <li><code>TypeDescriptor</code> is a concrete Type Descriptor that <code>Extends</code> both <code>MetaTypeDescriptor</code> and the abstract <code>HolonType</code>. It acts as both an abstract and a concrete type, preventing infinite regress.</li> <li>Concrete Type Descriptors <code>Extend</code> both the general <code>TypeDescriptor</code> and the Abstract Type for their Type Kind, fulfilling both.</li> </ul> <p>This 4-level model ensures that types, schemas, and even schema-of-schemas are composable, inspectable, and extensible \u2014 enabling MAP to support open-ended, agent-defined semantics.</p>"},{"location":"core/map-type-system-revised/#map-type-system-design-abstract-types-as-anchors","title":"\ud83e\udded MAP Type System Design: Abstract Types as Anchors","text":"<p>This document formalizes the design principle that abstract types serve as anchors for relationship definitions within the MAP type system. This approach preserves both the structural integrity of the type system and the flexibility needed for large-scale domain modeling.</p>"},{"location":"core/map-type-system-revised/#starting-premises","title":"\u2705 Starting Premises","text":"Concept Clarification Abstract types Are real holons with referenceable identity. They are <code>TypeDescriptor</code> instances with <code>is_abstract_type = true</code>. They are not instantiable (i.e., no holon may declare <code>DescribedBy \u2192 [abstract type]</code>). Concrete types Are also <code>TypeDescriptor</code>s, but with <code>is_abstract_type = false</code>. They can be used in <code>DescribedBy</code> to describe holons. Relationship types Are concrete <code>DeclaredRelationshipType</code> holons that declare their expected <code>SourceType</code> and <code>TargetType</code>. SmartLink validation Ensures that the holons involved in a SmartLink conform to the type constraints of the relationship type. This requires comparing the <code>DescribedBy</code> of the source/target holons to the relationship type\u2019s <code>SourceType</code> and <code>TargetType</code>."},{"location":"core/map-type-system-revised/#design-principle-abstract-types-as-anchors","title":"\ud83e\udde9 Design Principle: Abstract Types as Anchors","text":""},{"location":"core/map-type-system-revised/#core-concept","title":"\ud83d\udcd0 Core Concept","text":"<p>Abstract types (e.g., <code>HolonTypeTemplate</code>, <code>PropertyType</code>, <code>ValueType</code>) are used as the <code>SourceType</code> and <code>TargetType</code> in the declaration of relationship types.</p> <p>Validation is based not on strict equality, but on type conformance: A holon is valid as the source or target of a SmartLink if its <code>DescribedBy</code> extends the relationship\u2019s <code>SourceType</code> or <code>TargetType</code>.</p>"},{"location":"core/map-type-system-revised/#smartlink-validation-rule","title":"\u2705 SmartLink Validation Rule","text":"<p>When validating a SmartLink instance:</p> <ul> <li>Let <code>R</code> be the <code>DeclaredRelationshipType</code> describing the link</li> <li>Let <code>S</code> be the source holon</li> <li>Let <code>T</code> be the target holon</li> <li>Then the SmartLink is valid if:</li> <li><code>S.DescribedBy</code> Extends <code>R.SourceType</code></li> <li><code>T.DescribedBy</code> Extends <code>R.TargetType</code></li> </ul> <p>This preserves the non-instantiability of abstract types while still allowing them to define broad, reusable relationship categories.</p>"},{"location":"core/map-type-system-revised/#why-this-matters_1","title":"\ud83e\udde0 Why This Matters","text":"<ul> <li>Abstract types define type-kind-specific obligations via their <code>InstanceProperties</code> and <code>InstanceRelationships</code>.</li> <li>They act as anchors for relationships such as:</li> <li><code>(PropertyType)-[ValueType]-&gt;(ValueType)</code></li> <li><code>(HolonType)-[InstanceProperties]-&gt;(PropertyType)</code></li> <li><code>(RelationshipType)-[SourceType]-&gt;(HolonType)</code></li> <li>Domain-specific concrete types (e.g., <code>Book.HolonType</code>) extend these abstract types and inherit their structural expectations.</li> </ul>"},{"location":"core/map-type-system-revised/#example-author-relationship","title":"\ud83d\udd17 Example: Author Relationship","text":""},{"location":"core/map-type-system-revised/#relationship-definition","title":"Relationship Definition","text":"<pre><code>{\n  \"key\": \"(Holon)-[AuthorOf]-&gt;(Holon)\",\n  \"type\": \"#TypeDescriptor\",\n  \"properties\": {\n    \"type_name\": \"AuthorOf\",\n    \"type_kind\": \"Relationship\",\n    \"is_abstract_type\": false\n  },\n  \"relationships\": [\n    { \"name\": \"Extends\", \"target\": \"#DeclaredRelationshipType\" },\n    { \"name\": \"SourceType\", \"target\": \"#Person.HolonTypeTemplate\" },\n    { \"name\": \"TargetType\", \"target\": \"#CreativeWork.HolonTypeTemplate\" }\n  ]\n}\n</code></pre>"},{"location":"core/map-type-system-revised/#valid-smartlink","title":"Valid SmartLink","text":"<pre><code>{\n  \"key\": \"person123-authorOf-book456\",\n  \"type\": \"#AuthorOf\",\n  \"source\": \"#person123\",\n  \"target\": \"#book456\"\n}\n</code></pre> <p>Where:</p> <ul> <li><code>person123.DescribedBy \u2192 Person.HolonType</code></li> <li> <p><code>Person.HolonType Extends \u2192 Person.HolonTypeTemplate</code></p> </li> <li> <p><code>book456.DescribedBy \u2192 Book.HolonType</code></p> </li> <li><code>Book.HolonType Extends \u2192 CreativeWork.HolonTypeTemplate</code></li> </ul> <p>\u2705 The validation passes: the SmartLink conforms because both source and target types extend the expected abstract anchors.</p>"},{"location":"core/map-type-system-revised/#summary","title":"\u2705 Summary","text":"<p>This approach provides: - A unified, extensible model of type descriptors - Support for validation against abstract categories - Clean modeling of relationship expectations without sacrificing type safety - A clear separation between instantiable and non-instantiable types</p> <p>By anchoring relationships in abstract types and validating against the extension hierarchy, MAP maintains both strict type safety and maximal reuse of schema structures.</p> <p>Several of the <code>type_kind</code> variants \u2014 such as <code>Value(String)</code>, <code>Value(Boolean)</code>, or <code>ValueArray(Enum)</code> \u2014 correspond to scalar value types. These are backed by a fixed set of Base Types that define how values are represented, stored, and validated across environments. Let\u2019s look next at the Base Types and Base Values that support these value type kinds.</p>"},{"location":"core/map-type-system-revised/#base-types-and-base-values","title":"Base Types and Base Values","text":"<p>BaseTypes are the foundational, portable types in the MAP system. A Base Type determines how a given value is represented across programming environments \u2014 such as Rust on the backend and TypeScript or JSON on the client. The Base Types layer includes scalar types (e.g., MapInteger, MapString) and compound types (e.g., MapBytes). The set of Base Types is fixed for any given version of the MAP. Changes or additions to any of these types requires a recompile of the MAP code and an evolution of the persistent data stored using a prior version of the MAP.</p> <p>\u2705 Principle: Preserve Type Identity Across Platforms * The Base Type name should be treated as portable name, used consistently across environments, and interpretable as such by the MAP type system. * In Rust, we get this via <code>pub struct MapString(pub String)</code> \u2014 which gives us a unique type identity at the compiler level. * In TypeScript, and even JSON, we can do similar things \u2014 not with strong typing, but through type aliases, tagging, or enforced schema constraints.</p>"},{"location":"core/map-type-system-revised/#current-base-types-with-portable-name-bindings","title":"Current Base Types with Portable Name Bindings","text":"<p>The following table shows each MAP Base Type alongside its language-specific bindings and its portable JSON representation.</p> Base Type Rust Binding TypeScript Binding JSON Binding (Tagged Format) <code>MapString</code> <code>pub struct MapString(pub String)</code> <code>export type MapString = string;</code> <code>{ \"type\": \"MapString\", \"value\": \"...\" }</code> <code>MapBoolean</code> <code>pub struct MapBoolean(pub bool)</code> <code>export type MapBoolean = boolean;</code> <code>{ \"type\": \"MapBoolean\", \"value\": true }</code> <code>MapInteger</code> <code>pub struct MapInteger(pub i64)</code> <code>export type MapInteger = number;</code> <code>{ \"type\": \"MapInteger\", \"value\": 42 }</code> <code>MapEnumValue</code> <code>pub struct MapEnumValue(pub String)</code> <code>export type MapEnumValue = string;</code> <code>{ \"type\": \"MapEnumValue\", \"value\": \"DRAFT\" }</code> <code>MapBytes</code> <code>pub struct MapBytes(pub Vec&lt;u8&gt;)</code> <code>export type MapBytes = string; // base64</code> <code>{ \"type\": \"MapBytes\", \"value\": \"aGVsbG8=\" }</code>"},{"location":"core/map-type-system-revised/#base-values","title":"Base Values","text":"<p>MAP represents actual runtime values using the <code>BaseValue</code> enum. This enum wraps each of the base types, enabling them to be used uniformly in property maps, serialized holons, and validation contexts.</p> <pre><code>pub enum BaseValue {\n    StringValue(MapString),\n    BooleanValue(MapBoolean),\n    IntegerValue(MapInteger),\n    EnumValue(MapEnumValue),\n    BytesValue(MapBytes),\n}\n</code></pre> <p>Each variant corresponds to a specific MAP Base Type. This allows property values to be stored and inspected in a type-safe and introspectable way.</p> <p>Only <code>BaseValue</code> variants may be used as <code>PropertyValue</code>s within a holon's <code>PropertyMap</code>:</p> <pre><code>pub type PropertyValue = BaseValue;\npub type PropertyMap = BTreeMap&lt;PropertyName, Option&lt;PropertyValue&gt;&gt;;\n</code></pre> <p>By wrapping all scalar values in a unified enum, MAP ensures that holon properties are portable, self-describing, and easy to serialize and deserialize across environments.</p>"},{"location":"core/map-type-system-revised/#notes","title":"Notes","text":"<ul> <li> <p>Rust bindings use the newtype pattern (e.g. <code>pub struct MapString(pub String)</code>) to distinguish each base type with a unique identity while still leveraging native Rust primitives. This allows custom trait implementations, typed serialization, and compile-time safety.</p> </li> <li> <p>All types derive <code>Clone</code>, <code>PartialEq</code>, and other basic traits, ensuring they are usable in Holochain entry types, maps, and standard logic.</p> </li> <li> <p>Display implementations are provided for all base types and for <code>BaseValue</code>, with formatting that is human-readable and variant-specific. This is especially helpful for debugging, logging, or visualization.</p> </li> <li> <p><code>BaseValue</code> acts as the unified runtime representation of scalar values. Its variant names are aligned with the base type wrappers (e.g., <code>StringValue(MapString)</code>), and it includes:</p> </li> <li>A method <code>into_bytes()</code> for deterministic binary encoding</li> <li>A <code>Display</code> implementation</li> <li> <p>A <code>From&lt;&amp;BaseValue&gt; for String</code> conversion (via <code>Into&lt;String&gt;</code>)</p> </li> <li> <p>TypeScript bindings are currently defined as simple aliases (e.g., <code>type MapString = string</code>) for interoperability with JSON and browser-based UIs. This preserves the MAP naming scheme in typed code.</p> </li> <li> <p>JSON bindings assume a tagged format for clarity and round-tripping, such as:</p> </li> </ul> <p>{   \"type\": \"StringValue\",   \"value\": \"Hello\"   }</p> <ul> <li> <p><code>ValueType</code> defines the kind of scalar value a property can hold, and is used within type descriptors to constrain values semantically (e.g., enforce that a field is a <code>String</code>, <code>Integer</code>, etc.).</p> </li> <li> <p>The previously defined <code>BaseType</code> enum has been removed. Its responsibilities are now handled more cleanly by:</p> </li> <li><code>TypeKind</code> \u2014 for classifying descriptors at the schema level (e.g., <code>Property</code>, <code>Value</code>, <code>Relationship</code>)</li> <li><code>ValueType</code> \u2014 for describing scalar semantics in descriptors</li> <li><code>BaseValue</code> \u2014 for representing actual runtime values</li> </ul>"},{"location":"core/map-type-system-revised/#older-stuff-ignore-everything-that-follows","title":"OLDER STUFF -- Ignore everything that follows","text":"<p>MAP distinguishes types by their role in the type system. Each layer builds on the one below it:</p> Layer Role Example Types Meta Types Describe types themselves <code>MetaPropertyType</code>, <code>MetaHolonType</code> Core Types Used by MAP system logic and behavior <code>PropertyType</code>, <code>SchemaName</code> Extension Types Defined by agents to model domains <code>BookType</code>, <code>LibrarySchema</code> <ul> <li>Meta Types form the introspective backbone of MAP \u2014 they define how all other types are structured and understood.</li> <li>Core Types provide the foundational categories and semantic roles that MAP depends on to validate, model, and interpret holons.</li> <li>Extension Types let agents build on the core by defining their own reusable, introspectable structures \u2014 without any need to modify system logic.</li> </ul> <p>Each type in MAP is a holon, and every holon is typed by another holon \u2014 its TypeDescriptor \u2014 via the <code>DescribedBy</code> relationship. That descriptor defines the holon\u2019s properties, relationships, and structural expectations. This self-describing pattern ensures that every holon carries with it enough semantic metadata to be interpreted, validated, and extended \u2014 without relying on external schemas.</p> <p>Together, these layers support a fully self-aware, agent-defined ecosystem of meaning.</p>"},{"location":"core/map-type-system-revised/#3-meta-types-holons-that-describe-types","title":"3. Meta Types: Holons That Describe Types","text":"<p>Every holon in MAP is DescribedBy a <code>TypeDescriptor</code>. That descriptor serves two essential roles:</p> <ul> <li>It classifies the holon as a specific type (e.g., <code>BookHolonType</code>, <code>SchemaHolonType</code>)</li> <li>It describes the structure that instances of that type must or may include \u2014 such as properties, relationships, and (eventually) dances</li> </ul> <p>But each <code>TypeDescriptor</code> is itself a holon. For example, <code>BookHolonType</code> and <code>SchemaHolonType</code> are both type descriptors \u2014 and also holons that can be queried, versioned, and linked.</p> <p>So what describes a type descriptor?</p> <p>The types that describe other types are known as meta-types.</p>"},{"location":"core/map-type-system-revised/#31-map-meta-schema","title":"3.1 MAP Meta-Schema","text":"<ul> <li><code>MetaHolonType</code>, <code>MetaTypeDescriptor</code>, <code>MetaSchemaType</code></li> <li><code>DescribedBy</code>, <code>Extends</code>, <code>InstanceProperties</code></li> <li>\ud83d\udcca Diagram: Meta-Schema Graph</li> </ul>"},{"location":"core/map-type-system-revised/#311-typedescriptor-anatomy-and-inheritance","title":"3.1.1 TypeDescriptor Anatomy and Inheritance","text":"<ul> <li>Holon structure: <code>type</code>, <code>properties</code>, <code>relationships</code></li> <li>Semantic role of <code>Extends</code></li> <li>Reflexive closure of the type system</li> </ul>"},{"location":"core/map-type-system-revised/#32-map-meta-value-schema","title":"3.2 MAP Meta-Value Schema","text":"<ul> <li><code>MetaValueType</code>, <code>MetaStringValueType</code>, <code>MetaEnumValueType</code>, etc.</li> <li>\ud83d\udcca Diagram: Meta-Value Schema</li> </ul>"},{"location":"core/map-type-system-revised/#33-map-keyrule-schema","title":"3.3 MAP KeyRule Schema","text":"<ul> <li><code>KeyRuleType</code> and its subtypes:<ul> <li><code>Format.KeyRuleType</code>, <code>None.KeyRuleType</code>, <code>Relationship.KeyRuleType</code></li> </ul> </li> <li>\ud83d\udcca Diagram: KeyRule Schema</li> </ul>"},{"location":"core/map-type-system-revised/#331-keyed-vs-keyless-holon-types","title":"3.3.1 Keyed vs. Keyless Holon Types","text":"<ul> <li>Structural rules and constraints</li> <li>Key derivation formats and <code>UsesKeyRule</code></li> <li>Bootstrapping with materialized keys</li> </ul>"},{"location":"core/map-type-system-revised/#34-semantic-vs-structural-inheritance-in-the-map-type-system","title":"3.4 Semantic vs Structural Inheritance in the MAP Type System","text":"<p>The MAP <code>Extends</code> relationship enables a flexible form of type composition and lineage. But the meaning and effect of <code>Extends</code> depends on whether the type being extended is abstract or concrete.</p> <p>This section distinguishes semantic vs structural inheritance, and clarifies how <code>Extends</code> behaves in each case.</p>"},{"location":"core/map-type-system-revised/#semantic-inheritance-extending-abstract-types","title":"\ud83d\udd39 Semantic Inheritance (Extending Abstract Types)","text":"<p>Abstract types in MAP define expectations, not structure. They play a role similar to Interfaces in Java and Traits in Rust.</p> <ul> <li>They specify what kinds of properties and relationships their concrete subtypes must declare.</li> <li>But, abstract types are not instantiated; they do not automatically contribute structural content to the types that extend them.</li> <li>In MAP, the first instantiable subtype in the Extends chain must explicitly declare the union of all InstanceProperties and InstanceRelationships expected by its abstract ancestors. This means its instances that it describes must populate values for those properties and relationships.</li> </ul>"},{"location":"core/map-type-system-revised/#example","title":"\u2705 Example","text":"<p><pre><code>MetaTypeDescriptor  (abstract) with InstanceProperties: TypeName, Description, etc.\n  \u2191 Extends\nMetaHolonType       (abstract) with InstanceRelationships: DescribedBy and OwnedBy\n  \u2191 Extends\nTypeDescriptor      (concrete)\n  \u2191 Describe\n BookHolonType\n</code></pre> TypeDescriptor is the first concrete type descriptor in the chain and therefore must declare the union of all InstanceProperties and InstanceRelationships required by its abstract ancestors (MetaTypeDescriptor, MetaHolonType).</p> <p>Likewise, BookType \u2014 a concrete extension of HolonType \u2014 fulfills the expectations declared by HolonType. - <code>TypeDescriptor</code> must declare its own <code>InstanceProperties</code> and <code>InstanceRelationships</code> that are the union of those declared by all the abstract types up its Extends chain, because those expectations come from its ancestors.</p> <p>This pattern supports: - Schema validation rules (e.g., \"all MetaHolonType subtypes must declare <code>InstanceRelationships</code>\") - Introspection tools that identify \u201cWhat kind of thing is this descriptor?\u201d</p> <p>\ud83e\udde0 Think of semantic inheritance as interface or trait conformance.</p>"},{"location":"core/map-type-system-revised/#structural-inheritance-extending-concrete-types","title":"\ud83d\udd39 Structural Inheritance (Extending Concrete Types)","text":"<p>Concrete types in MAP define structure \u2014 real properties and relationships that apply to all instances of the type.</p> <p>When a concrete type <code>A</code> extends another concrete type <code>B</code>: - A new holon instance is created for each \u2014 one for <code>A</code>, one for <code>B</code>. - The holon instance of <code>A</code> populates the <code>InstanceProperties</code> and <code>InstanceRelationships</code> declared by <code>A</code>. - The holon instance of <code>B</code> populates the structure declared by <code>B</code>.</p> <p>Together, these form a compositional chain of holons, and the effective structure of a holon is the combined result of traversing the <code>Extends</code> chain.</p>"},{"location":"core/map-type-system-revised/#example_1","title":"\u2705 Example","text":"<p>Consider a library containing lots of different kinds of items -- magazines, tools, books, CD's, DVD's, etc. There are some characteristics shared by all of these items and additional charactertistics that are specific to the kind of element.</p> <pre><code>LibraryItemType       (concrete)\n  \u2191\nBookType              (concrete)\n</code></pre> <ul> <li>An instance of <code>BookType</code>:</li> <li>Is its own holon</li> <li>Declares and populates properties like <code>author</code>, <code>publisher</code>, <code>isbn</code></li> <li>It also <code>Extends</code> an instance of <code>LibraryItemType</code>, which:</li> <li>Is a separate holon</li> <li>Declares and populates properties like <code>title</code>, <code>language</code>, <code>identifier</code></li> </ul> <p>The full shape of the book holon is realized by composing these layered instances. Each contributes to the structure through its declared type.</p> <p>\ud83e\udde0 Think of structural inheritance in MAP as compositional layering \u2014 not property flattening.</p>"},{"location":"core/map-type-system-revised/#summary-table","title":"\u2705 Summary Table","text":"Feature Abstract Type Concrete Type Declares expectations \u2705 Yes \u274c No Declares structure \u274c No \u2705 Yes Must be re-declared \u2705 (by subtypes) \u274c (structure accumulates) Used for validation rules \u2705 Yes \u2705 Yes Used for type conformance \u2705 Yes \u2705 Yes Affects instance shape \u274c No \u2705 Yes Produces a holon instance \u274c No \u2705 Yes"},{"location":"core/map-type-system-revised/#design-principle","title":"\ud83e\udde0 Design Principle","text":"<p>In MAP, inheritance is explicit and introspectable. - Abstract types guide what must be declared. - Concrete types contribute actual structure. - Each concrete type produces its own holon instance. - The effective holon shape is the result of traversing the Extends chain.</p> <p>This makes the MAP type system composable, schema-validatable, and fully self-describing \u2014 with no hidden inheritance or magical behavior.</p>"},{"location":"core/map-type-system-revised/#4-core-types-semantic-foundations-of-map","title":"4. Core Types: Semantic Foundations of MAP","text":"<ul> <li><code>PropertyType</code>, <code>RelationshipType</code>, <code>EnumVariantType</code></li> <li><code>PropertyName</code>, <code>RelationshipName</code>, <code>SchemaName</code></li> <li>Core enum types (e.g. <code>DeletionSemantic</code>)</li> <li>Role in validation, schema definition, and system behavior</li> </ul>"},{"location":"core/map-type-system-revised/#5-extension-types-agent-defined-semantics","title":"5. Extension Types: Agent-Defined Semantics","text":"<ul> <li>Instances of core types</li> <li>Examples: <code>BookType</code>, <code>\"HAS_AUTHOR\"</code>, <code>\"LibrarySchema\"</code></li> <li>Dual role: type + data</li> <li>Cross-schema interoperability and reuse</li> </ul>"},{"location":"core/map-type-system-revised/#6-base-types-language-portable-value-kinds","title":"6. Base Types: Language-Portable Value Kinds","text":"<ul> <li><code>MapString</code>, <code>MapBoolean</code>, <code>MapInteger</code>, etc.</li> <li><code>BaseValue</code> enum</li> <li>Rust, TypeScript, JSON bindings</li> <li>Tagged JSON format and display conventions</li> <li>Open design questions</li> </ul>"},{"location":"core/map-type-system-revised/#7-self-describing-holons","title":"7. Self-Describing Holons","text":"<p>Transition section: from types to instances</p> <ul> <li>Introspection via <code>DescribedBy</code>, <code>InstanceProperties</code>, etc.</li> <li>Aggregating inherited structure through <code>Extends</code></li> <li>How any holon reveals:<ul> <li>What kind of thing it is</li> <li>What properties it has</li> <li>What relationships it participates in</li> <li>(Future) what dances it supports</li> </ul> </li> </ul>"},{"location":"core/map-type-system-revised/#8-authoring-and-importing-types","title":"8. Authoring and Importing Types","text":"<ul> <li>JSON structure: <code>key</code>, <code>type</code>, <code>properties</code>, <code>relationships</code></li> <li><code>$ref</code> and embedding</li> <li>Key rules and validation</li> <li>Authoring conventions and import-time enforcement</li> </ul>"},{"location":"core/meta-value-types-import-guide/","title":"Meta-Value Import Guide","text":""},{"location":"core/meta-value-types-import-guide/#starting-point-types-as-holons","title":"\ud83e\uddec Starting Point: Types as Holons","text":"<p>In MAP, every type description is, itself, a holon.</p> <p>This means that every type must: - Be described by a <code>TypeDescriptor</code> - Be owned by a <code>HolonSpace</code></p> <p>These aren't optional conventions \u2014 they are defining structural obligations of being a holon.</p> <p>\u2705 Every type in MAP is a holon. Therefore: every type must have <code>DescribedBy</code> and <code>OwnedBy</code> relationships.</p>"},{"location":"core/meta-value-types-import-guide/#modeling-map-value-types","title":"Modeling MAP Value Types","text":""},{"location":"core/meta-value-types-import-guide/#example-mapstringvaluetype-and-propertynamevaluetype","title":"\ud83d\udd20 Example: MapStringValueType and PropertyNameValueType","text":"<p>Consider two value types:</p> <ul> <li><code>MapStringValueType</code>: A general-purpose string type</li> <li><code>PropertyNameValueType</code>: A string type used specifically for property names</li> </ul> <p>They both represent strings at the data level, but differ in usage and constraint.</p> <p>Both are:</p> <ul> <li>Holons \u2192 Must be <code>DescribedBy</code> and <code>OwnedBy</code></li> <li>TypeDescriptors \u2192 Must be instances of <code>MetaValueType</code></li> </ul> <p>So the following relationships apply:</p> <pre><code>MapStringValueType \u2014[DescribedBy]\u2192 MetaValueType  \nPropertyNameValueType \u2014[DescribedBy]\u2192 MetaValueType\n</code></pre> <p>At this point, we know these two holons are not just any holons \u2014 they are type descriptors used in the schema.</p>"},{"location":"core/meta-value-types-import-guide/#shared-constraints-via-compositional-inheritance","title":"\ud83e\uddf1 Shared Constraints via Compositional Inheritance","text":"<p>Different value types require different constraints:</p> <ul> <li>Strings \u2192 min/max length, format, case convention</li> <li>Integers \u2192 min/max values</li> <li>Enums \u2192 allowed variants</li> <li>Bytes \u2192 fixed length, encoding</li> </ul> <p>But many types share these constraints. For example:</p> <pre><code>MapStringValueType        \u2500\u2510\n                          \u251c\u2500[Extends]\u2192 StringValueConstraints\nPropertyNameValueType     \u2500\u2518\n</code></pre> <p>In this pattern:</p> <ul> <li><code>MapStringValueType</code> and <code>PropertyNameValueType</code> are both holons and descriptors.</li> <li><code>StringValueConstraints</code> is just a constraint facet \u2014 it contributes properties like <code>min_length</code>, <code>max_length</code>, or <code>case_convention</code>.</li> </ul> <p>Importantly:</p> <p><code>StringValueConstraints</code> is not a type. It\u2019s not a descriptor. It doesn\u2019t have a <code>type_name</code>, doesn\u2019t need to be <code>DescribedBy</code>, and doesn\u2019t appear in any schema.</p> <p>It just extends the value type it\u2019s associated with, in a purely compositional way.</p>"},{"location":"core/meta-value-types-import-guide/#why-keys-matter","title":"\ud83e\uddf7 Why Keys Matter","text":"<p>Semantic keys are foundational to the MAP architecture \u2014 not just for expressing relationships during import, but for enabling retrieval, referencing, and bootstrapping in a decentralized, descriptor-driven system.</p> <p>They enable holons to be meaningfully identified and linked across the full lifecycle \u2014 from initial import to runtime introspection \u2014 even before they've been committed to the system or assigned a permanent ID.</p>"},{"location":"core/meta-value-types-import-guide/#staged-relationships-without-ids","title":"\ud83d\udd04 Staged Relationships Without IDs","text":"<p>In staged or import workflows, holons frequently reference other holons that haven\u2019t yet been committed \u2014 and therefore lack a system-assigned ID (e.g., a Holochain <code>ActionHash</code>).</p> <p>Keys solve this by allowing holons to be referenced using <code>$ref: \"key\"</code> rather than relying on fragile temporary identifiers or rigid load ordering.</p> <p>\u2705 Keys enable: - Cross-file linkage between staged holons - ID-free <code>$ref</code> expressions in JSON - Relationship validation prior to commit - Deduplication and merging of equivalent entries</p> <p>\ud83d\udcd8 Example: <pre><code>{\n  \"type_name\": \"RelationshipType\",\n  \"key\": \"(PersonType)-[MentoredBy]-&gt;(PersonType)\",\n  \"relationships\": [\n    { \"name\": \"SOURCE_FOR\", \"target\": [{ \"$ref\": \"PersonType\" }] },\n    { \"name\": \"TARGET_FOR\", \"target\": [{ \"$ref\": \"PersonType\" }] }\n  ]\n}\n</code></pre></p> <p>This relationship type can be referenced by other holons using its <code>key</code>, without requiring an ID to exist yet.</p>"},{"location":"core/meta-value-types-import-guide/#bootstrapping-descriptors-before-descriptor-logic-exists","title":"\ud83e\uddf1 Bootstrapping Descriptors Before Descriptor Logic Exists","text":"<p>Many MAP behaviors \u2014 including validation, inverse relationship population, and declarative key generation \u2014 depend on descriptors like <code>PropertyType</code>, <code>RelationshipType</code>, or <code>HolonType</code>.</p> <p>But you can\u2019t run logic that depends on descriptors until descriptors are present.</p> <p>By requiring materialized <code>key</code> fields in the JSON of Keyed Holons, we can: - Import descriptors without requiring key generation logic - Reference them from other holons in the same import graph - Stage and introspect schemas and data prior to persistence</p> <p>This makes it possible to: - Import the MAP Meta-Schema - Import domain-specific schema extensions - Import valid data instances   ...all in a single, unified process.</p>"},{"location":"core/meta-value-types-import-guide/#associative-retrieval-in-distributed-systems","title":"\ud83d\udd0d Associative Retrieval in Distributed Systems","text":"<p>In distributed architectures like Holochain, data is stored in Distributed Hash Tables (DHTs) \u2014 meaning:</p> <ul> <li>You cannot \u201cquery the whole database\u201d as you would in a centralized store</li> <li>You typically need a known hash or path to locate content efficiently</li> </ul> <p>Materialized keys provide the critical link between semantic meaning and retrieval paths:</p> <p>\u2705 They support: - Associative lookup: finding content based on associated properties (e.g., type, relationship role) - Path-based indexing: storing holons under DHT paths that reflect their keys (e.g., <code>path!((\"HolonType\", key))</code>) - Declarative retrieval APIs: enabling callers to say \u201cget me the [MentoredBy] relationship\u201d without knowing its ID</p> <p>Without keys: - Content is only retrievable via opaque identifiers - Queries become tightly coupled to global indexes or full scans (inefficient or unavailable in DHTs) - Schema introspection and semantic queries are significantly harder</p>"},{"location":"core/meta-value-types-import-guide/#summary","title":"\ud83e\udde0 Summary","text":"<p>Keys are not just syntactic sugar \u2014 they are critical infrastructure for:</p> <ul> <li>Declarative, schema-linked imports</li> <li>ID-free reference resolution across files</li> <li>Bootstrapping descriptors before runtime logic is available</li> <li>Efficient, semantic-based retrieval in distributed systems</li> <li>Federated schema evolution and shared introspection</li> </ul> <p>By embracing materialized, semantically meaningful keys, MAP achieves a powerful combination of:</p> <ul> <li>Structural clarity</li> <li>Introspectable relationships</li> <li>Decentralized operability</li> <li>Self-hosted schema evolution</li> </ul> <p>This makes keys one of the most essential capabilities in the MAP Type System.</p>"},{"location":"core/meta-value-types-import-guide/#layered-inheritance-the-value-type-stack","title":"\ud83d\udcd0 Layered Inheritance: The Value Type Stack","text":"<pre><code>MetaValueType \u2014[Describes]\u2192 MapStringValueType \u2014[Extends]\u2192 StringValueConstraints\n</code></pre> <p>This gives us three clear layers:</p> <ol> <li>Meta Descriptor Level \u2014 defines what a value type must contain</li> <li>Descriptor Level \u2014 a value type like <code>MapStringValueType</code> or <code>PropertyNameValueType</code></li> <li>Constraint Layer \u2014 reusable modular constraints via <code>Extends</code></li> </ol> Layer Holon Purpose Meta <code>MetaValueType</code> Describes value type descriptors Type <code>MapStringValueType</code> Actual TypeDescriptor Constraint <code>StringValueConstraints</code> Adds constraint properties"},{"location":"core/meta-value-types-import-guide/#pattern-repeats-for-all-primitive-types","title":"\ud83d\udd01 Pattern Repeats for All Primitive Types","text":"<p>Here\u2019s the same pattern across other type kinds:</p> ValueType DescribedBy ExtendedBy Constraints Provided <code>MapStringValueType</code> <code>MetaValueType</code> <code>StringValueConstraints</code> <code>min_length</code>, <code>max_length</code>, etc. <code>PropertyNameValueType</code> <code>MetaValueType</code> <code>StringValueConstraints</code> Custom limits, <code>case_convention</code> <code>MapIntegerValueType</code> <code>MetaValueType</code> <code>IntegerValueConstraints</code> <code>min_value</code>, <code>max_value</code> <code>MapBytesValueType</code> <code>MetaValueType</code> <code>BytesValueConstraints</code> <code>length</code>, <code>encoding</code>, <code>format_hint</code> <code>MapEnumValueType</code> <code>MetaValueType</code> <code>EnumValueConstraints</code> <code>Variants</code> relationship <code>MapBooleanValueType</code> <code>MetaValueType</code> (none needed) (no constraints required)"},{"location":"core/meta-value-types-import-guide/#are-meta-types-holons-too","title":"\ud83e\udde9 Are Meta Types Holons Too?","text":"<p>Yes \u2014 and this is where the architectural recursion becomes elegant.</p> <p>Just as <code>MapStringValueType</code> is a holon and needs to be <code>DescribedBy</code>, so too does <code>MetaValueType</code>.</p> <p>Let\u2019s follow the thread:</p> <pre><code>MetaValueType         \u2014[DescribedBy]\u2192 MetaTypeDescriptor  \nMetaIntegerValueType  \u2014[DescribedBy]\u2192 MetaValueType\n</code></pre> <p>So: \ud83d\udd01 Meta types themselves are holons \ud83d\udd01 They need to be described \ud83d\udd01 They participate in the same system they define</p>"},{"location":"core/meta-value-types-import-guide/#recursion-meets-structure-metatypedescriptor-extends-metaholontype","title":"\ud83d\udd04 Recursion Meets Structure: MetaTypeDescriptor Extends MetaHolonType","text":"<p>To avoid repeating the structural obligations of all holons (like needing <code>DescribedBy</code> and <code>OwnedBy</code>) across every Meta type\u2026</p> <p>We simply declare:</p> <pre><code>MetaTypeDescriptor \u2014[Extends]\u2192 MetaHolonType\n</code></pre> <p>Now, every Meta type (like <code>MetaValueType</code>, <code>MetaPropertyType</code>, etc.) that is an instance of <code>MetaTypeDescriptor</code> inherits from <code>MetaHolonType</code>, which defines the baseline expectations for all holon types.</p> <p>\u2705 Every Meta type becomes both a type descriptor and a holon \u2705 DRY design: <code>MetaHolonType</code> captures shared structural rules \u2705 Recursive closure: the system defines itself in clean, layered cycles</p>"},{"location":"core/meta-value-types-import-guide/#summary-of-the-pattern","title":"\ud83e\udde0 Summary of the Pattern","text":"Concept Relationship Notes ValueType <code>DescribedBy \u2192 MetaValueType</code> Marks as a valid type holon ValueType <code>Extends \u2192 ValueConstraints</code> Adds constraints modularly MetaValueType <code>DescribedBy \u2192 MetaTypeDescriptor</code> Makes it a descriptor of type descriptors MetaValueType <code>Extends \u2192 MetaHolonType</code> Inherits holon-level expectations Constraints (e.g. StringValueConstraints) (no type) Purely compositional constraint layer"},{"location":"core/meta-value-types-import-guide/#bonus-how-you-might-use-this-in-validation-or-import","title":"\ud83e\uddf0 Bonus: How You Might Use This in Validation or Import","text":"<p>When validating a <code>PropertyType</code> that refers to a ValueType:</p> <ol> <li>Confirm the target is a holon</li> <li>Confirm it\u2019s <code>DescribedBy</code> <code>MetaValueType</code></li> <li>Confirm it satisfies the constraints from any <code>Extends</code> facets</li> </ol> <p>This lets you:</p> <ul> <li>Reuse constraints</li> <li>Compose constraint types</li> <li>Keep descriptors clean and minimal</li> <li>Keep validation DRY and generalizable</li> </ul> <p>================ OLDER ATTEMPTS FOLLOW</p>"},{"location":"core/meta-value-types-import-guide/#starting-point-types-as-holons_1","title":"\ud83e\uddec Starting Point: Types as Holons","text":"<p>In MAP, every type \u2014 including value types \u2014 is a holon.</p> <p>Because every type is a holon, it must:</p> <ul> <li>Be described by a <code>TypeDescriptor</code></li> <li>Be owned by a <code>HolonSpace</code></li> </ul>"},{"location":"core/meta-value-types-import-guide/#layer-1-descriptor-level-meta-types","title":"\ud83e\uddf1 Layer 1: Descriptor Level (Meta Types)","text":"<p>This is the type of types level \u2014 Meta types describe what type descriptors are.  </p> <p>For example:</p> <ul> <li><code>MetaValueType</code> is a <code>TypeDescriptor</code></li> <li>It specifies properties and relationships common to all ValueTypes<ul> <li>e.g., <code>type_name</code>, <code>ValueType</code> relationship from <code>PropertyType</code>, <code>type_kind</code>, etc.</li> </ul> </li> </ul> <p>So:</p> <pre><code>MapStringValueType \u2014[DescribedBy]\u2192 MetaValueType  \nPropertyNameValueType \u2014[DescribedBy]\u2192 MetaValueType\n</code></pre> <p>Now these holons are known to be TypeDescriptors and are expected to provide things like <code>type_name</code>, and be usable in <code>ValueType</code> relationships from <code>PropertyType</code>.</p> <p>But because every type is also a holon, the types themselves need to be <code>DescribedBy</code> a <code>TypeDescriptor</code> and <code>OwnedBy</code> a <code>HolonSpace</code>. So TypeDescriptor needs to <code>Extend</code> Me</p>"},{"location":"core/meta-value-types-import-guide/#layer-2-constraint-types-via-extends","title":"\ud83e\uddf1 Layer 2: Constraint Types via <code>Extends</code>","text":"<p>Some ValueTypes want to specify type-kind-specific constraints \u2014 but you don\u2019t want to bake those constraints into every ValueType. You want a modular, reusable structure.</p> <p>That\u2019s where <code>Extends</code> comes in.</p> <p>Let\u2019s take an example:</p> <pre><code>MapStringValueType \u2014[Extends]\u2192 StringValueConstraints  \nPropertyNameValueType \u2014[Extends]\u2192 StringValueConstraints\n</code></pre> <p>Here:</p> <ul> <li><code>MapStringValueType</code> defines the general-purpose string value type.</li> <li><code>PropertyNameValueType</code> is a specialized string type, e.g., requiring <code>snake_case</code>, specific min/max lengths, etc.</li> <li>Both share the constraint logic defined in <code>StringValueConstraints</code>.</li> </ul> <p>The key insight is that <code>StringValueConstraints</code> is not a type itself. It doesn\u2019t need a <code>type_name</code>, <code>DescribedBy</code>, etc. It simply adds constraint properties like:</p> <ul> <li><code>min_length</code></li> <li><code>max_length</code></li> <li><code>case_convention</code></li> <li><code>format_hint</code></li> </ul> <p>It's a constraint facet, not a descriptor.</p>"},{"location":"core/meta-value-types-import-guide/#parallel-pattern-for-other-type-kinds","title":"\ud83d\udd04 Parallel Pattern for Other Type Kinds","text":"<p>You\u2019d follow this same pattern for other primitive types:</p> ValueType Extends Constrains via\u2026 <code>MapIntegerValueType</code> <code>IntegerValueConstraints</code> <code>min_value</code>, <code>max_value</code> <code>MapBytesValueType</code> <code>BytesValueConstraints</code> <code>length</code>, <code>encoding</code> <code>MapBooleanValueType</code> (no constraints) (no extra facet needed) <code>MapEnumValueType</code> <code>EnumValueConstraints</code> <code>Variants</code> relationship"},{"location":"core/meta-value-types-import-guide/#layered-design-overview","title":"\ud83d\udcd0 Layered Design Overview","text":"<pre><code>          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502     MetaValueType          \u2502 \u25c4\u2500\u2500 Describes all ValueType descriptors\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502 DescribedBy\n                       \u25bc\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502   MapStringValueType       \u2502 \u25c4\u2500\u2500 A TypeDescriptor\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502 Extends\n                       \u25bc\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502   StringValueConstraints   \u2502 \u25c4\u2500\u2500 Holds constraint properties only\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>You can generalize this:</p> <ul> <li>Any <code>MetaType</code> describes a descriptor</li> <li>Any actual <code>TypeDescriptor</code> may <code>Extend</code> a constraint holon</li> <li>Constraint holons are not TypeDescriptors \u2014 they don\u2019t get keys, <code>DescribedBy</code>, or <code>OwnedBy</code></li> </ul>"},{"location":"core/meta-value-types-import-guide/#benefits-of-this-pattern","title":"\u2705 Benefits of This Pattern","text":"<ul> <li>Clarity: Descriptors describe types. Constraints constrain them.</li> <li>DRY: Reuse constraints across many types (e.g., <code>StringValueConstraints</code>)</li> <li>Composability: Add further <code>Extends</code> layers if needed, e.g., <code>StringWithRegexConstraints</code></li> <li>Separation of Concerns: Keep metadata (<code>type_name</code>, etc.) distinct from behaviorally meaningful constraints</li> </ul>"},{"location":"core/meta-value-types-import-guide/#optional-schema-organization","title":"\ud83d\udca1 Optional: Schema Organization","text":"<p>You may wrap the constraint holons (like <code>StringValueConstraints</code>) in their own schema:</p> <pre><code>{\n  \"key\": \"MAP Value Constraints Schema\",\n  \"type\": \"Schema\",\n  \"relationships\": [\n    {\n      \"name\": \"Components\",\n      \"target\": [\n        { \"$ref\": \"#StringValueConstraints\" },\n        { \"$ref\": \"#IntegerValueConstraints\" },\n        ...\n      ]\n    }\n  ]\n}\n</code></pre> <p>Would you like to sketch out the JSON structure for one of these examples (e.g., <code>PropertyNameValueType</code> extending <code>StringValueConstraints</code>) using this approach?</p>"},{"location":"core/meta-value-types-import-guide/#annotated-example-map-strings","title":"Annotated Example -- MAP Strings","text":"<p><code>MapStringValueType</code> is an instance of <code>MetaValueType</code>. Thus, it can be the target of a Property's <code>ValueType</code> relationship. It may often be the case that the <code>ValueType</code> for a property is simply <code>MapString</code>. But sometimes we want more specific types. For example, the <code>PropertyNameValueType</code> is specifically intended to be the type used for <code>property_names</code> in the MAP. As a value type, it is ALSO an instance of <code>MetaValueType</code> (i.e., its \"type\" is <code>MetaValueType</code>). Note that <code>MapString</code> and <code>PropertyNameValueType</code> both have <code>instance_type_kind</code> of <code>String</code>, so they would both be represented in Rust by the MapString type. But <code>PropertyNameValueType</code> might want to specify its own case_convention (snake_case), and length restrictions that differ from the more generic <code>MapStringValueType</code>.  And, other than sharing the same type kind, MapStringValueType and PropertyNameValueType have no direct relationship to each other.</p> <p>Different value type kinds require different kinds of constraints. For example, <code>Strings</code> have min and max length and perhaps a format type or template. Integers have min/max values. So the definition of each ValueType has a common facet (in its role as a TypeDescriptor) and a type-kind-specific facet (its constraints.</p> <p>We can use compositional inheritance to model this. Thus,</p> <p>(MetaValueType) &lt;- [Extends] - (MapValueConstraintsType) and (MapStringValueType) &lt;- [Extends] - (StringValueConstraints) and (PropertyNameValueType) &lt;- [Extends] - (StringValueConstraints)</p> <p>At first, I thought MapValueConstraintsType should perhaps be MetaValueConstraintsType -- but then I realized it is not describing another type. For example, StringValueConstraints is not (itself) a type definition. It specifies the constraints for the ValueType that it extends. Values for the type_name property (and all other TypeDescriptor properties) are set on the ValueType it extends. In other words, the PropertyNameValueType is the actual TypeDescriptor.</p>"},{"location":"core/meta-value-types-import-guide/#metavaluetype","title":"MetaValueType","text":"<ul> <li>Is the type that <code>Describes</code> <code>MapValueType</code>, so its <code>type</code> is <code>TypeDescriptor</code></li> </ul> <p>Each instance of <code>MapValueType</code> describes a single ValueType. It is a <code>TypeDescriptor</code> that provides values for the standard <code>TypeDescriptor</code> properties (e.g, <code>type_name</code>, <code>display_name_plural</code>, <code>instance_type_kind</code>, etc.).</p> <p>MetaValueType is an instance of TypeDescriptor that describes MapValueType MapValueType is an instance of MetaValueType (i.e., its \"type\" is \"MetaValueType\") -- SINGLETON? MapStringType is an instance of MapValueType (or MetaValueType)</p> <p>An XxxValueType consists of a TypeDescriptor that is ExtendedBy an XxxConstraintType The X StringConstraints Extends MapStringType</p> <p>As such it provides values for the <code>TypeDescriptor</code> <code>properties</code>:</p> <ul> <li>\"type_name\": \"MetaValueType\",</li> <li>\"type_name_plural\": \"MetaValueTypes\",</li> <li>\"display_name\": \"Meta Value Type\",</li> <li>\"display_name_plural\": \"Meta Value Types\",</li> <li>\"description\": \"Describes the types that can be used as the target of a <code>Property</code>'s <code>ValueType</code> relationship.\"</li> <li>\"instance_type_kind\": \"Holon\"</li> </ul> <p>All Meta types describe types and all type definitions are, themselves, Holons. So the instance_type_kind for all Meta types is \"Holon\"</p> <ul> <li>\"UsesKeyRule\": { \"$ref\": \"#TypeName.KeyRule\" }</li> <li>instance_type_kind tells you the storage type (i.e., the BaseType) of instances of the type being described</li> <li>MapValueType is the TypeDescriptor for all value types</li> <li>MetaStringConstraints Extends MetaValueType and</li> </ul> <pre><code> {\n              \"key\": \"MetaPropertyType\",\n              \"type\": \"#TypeDescriptor\",\n              \"properties\": {\n                \"type_name\": \"MetaPropertyType\",\n                \"type_name_plural\": \"MetaPropertyTypes\",\n                \"display_name\": \"Meta Property Type\",\n                \"display_name_plural\": \"Meta Property Types\",\n                \"description\": \"Describes the types of scalar properties that holons can possess.\"\n              },\n              \"relationships\": [\n                {\n                  \"name\": \"Extends\",\n                  \"target\": {\n                    \"$ref\": \"#MetaTypeDescriptor\"\n                  }\n                },\n                {\n                  \"name\": \"UsesKeyRule\",\n                  \"target\": {  $ref\": \"#TypeName.KeyRule\" }\n                },\n                {\n                  \"name\": \"InstanceRelationships\",\n                  \"target\": [\n                    {\n                      \"$ref\": \"#(PropertyType)-[ValueType]-&gt;(ValueType)\"\n                    },\n                    {\n                      \"$ref\": \"#(PropertyType)-[ComponentOf]-&gt;(Schema)\"\n                    },\n                    {\n                      \"$ref\": \"#(PropertyType)-[DescribedBy]-&gt;(TypeDescriptor)\"\n                    }\n                  ]\n                }\n              ]\n            },\n</code></pre> <pre><code> {\n              \"key\": \"MetaPropertyType\",\n              \"type\": \"#TypeDescriptor\",\n              \"properties\": {\n                \"type_name\": \"MetaPropertyType\",\n                \"type_name_plural\": \"MetaPropertyTypes\",\n                \"display_name\": \"Meta Property Type\",\n                \"display_name_plural\": \"Meta Property Types\",\n                \"description\": \"Describes the types of scalar properties that holons can possess.\"\n              },\n              \"relationships\": [\n                {\n                  \"name\": \"Extends\",\n                  \"target\": {\n                    \"$ref\": \"#MetaTypeDescriptor\"\n                  }\n                },\n                {\n                  \"name\": \"UsesKeyRule\",\n                  \"target\": {\n                    \"$ref\": \"#TypeName.KeyRule\"\n                  }\n                },\n                {\n                  \"name\": \"InstanceRelationships\",\n                  \"target\": [\n                    {\n                      \"$ref\": \"#(PropertyType)-[ValueType]-&gt;(ValueType)\"\n                    },\n                    {\n                      \"$ref\": \"#(PropertyType)-[ComponentOf]-&gt;(Schema)\"\n                    },\n                    {\n                      \"$ref\": \"#(PropertyType)-[DescribedBy]-&gt;(TypeDescriptor)\"\n                    }\n                  ]\n                }\n              ]\n            },\n</code></pre>"},{"location":"core/meta-value-types-import-guide/#mapvaluetype","title":"MapValueType","text":"<pre><code>{\n  \"key\": \"MapValueType\",\n  \"type\": \"#TypeDescriptor\"\n}\n</code></pre>"},{"location":"core/on-boarding/","title":"Agent, I-Space, and Computing Node Onboarding","text":"<p>This document describes the technical process by which a new user onboards into the Memetic Activation Platform (MAP), with emphasis on the relationship between I-Space, computing nodes, agents, and the identity/authority structures binding them together.</p>"},{"location":"core/on-boarding/#1-key-concepts","title":"1. Key Concepts","text":""},{"location":"core/on-boarding/#i-space","title":"I-Space","text":"<ul> <li>An I-Space is a user\u2019s personal agent-space within Planetary Space.</li> <li>It is a Holochain agent space (flattened inheritance: <code>I-Space \u2282 Holochain Space</code>).</li> <li>Conceptually represents the user\u2019s:<ul> <li>Personal computing cloud</li> <li>Personal data cloud</li> <li>Core identity</li> </ul> </li> <li>Acts as the parent membrane for all of the user\u2019s sub-agents (e.g. computing devices).</li> </ul>"},{"location":"core/on-boarding/#computing-node","title":"Computing Node","text":"<ul> <li>A computing node is a user\u2019s device (laptop, desktop, tablet, etc.) running the MAP software.</li> <li>Each computing node is instantiated as a Holochain agent within the user\u2019s I-Space.</li> <li>Provisioned with applications (\u201cthe Gift\u201d = Nine core apps).</li> <li>Executes MAP applications and participates in the user\u2019s personal services layer.</li> </ul>"},{"location":"core/on-boarding/#data-grove","title":"Data Grove","text":"<ul> <li>The user\u2019s personal data cloud, formed by the aggregation of application-specific DHTs.</li> <li>Conceptualized as a concentric layer surrounding core identity in the I-Space diagram.</li> <li>Data is distributed across the user\u2019s computing nodes.</li> </ul>"},{"location":"core/on-boarding/#core-identity","title":"Core Identity","text":"<ul> <li>The user\u2019s personal identity within Planetary Space.</li> <li>Materialized via a cryptographic keypair (or complement of keypairs) created at onboarding.</li> <li>Distributed across the user\u2019s computing nodes, but logically represented as a singular identity.</li> </ul>"},{"location":"core/on-boarding/#2-onboarding-flow","title":"2. Onboarding Flow","text":""},{"location":"core/on-boarding/#step-1-invitation-gift","title":"Step 1. Invitation &amp; Gift","text":"<ul> <li>User downloads MAP (free, open-source software).</li> <li>On first run, the MAP presents the user with an invitation to join Planetary Space.</li> <li>The \u201cgift\u201d is disclosed gradually:<ol> <li>Free installation.</li> <li>Presentation of invitation.</li> <li>Acceptance generates I-Space and identity.</li> </ol> </li> </ul>"},{"location":"core/on-boarding/#step-2-identity-creation","title":"Step 2. Identity Creation","text":"<ul> <li>Upon acceptance:<ul> <li>The MAP requests Holochain to generate:<ul> <li>A core identity keypair for the user.</li> <li>A sub-agent keypair for the initial computing node.</li> </ul> </li> </ul> </li> <li>Result: both user identity and computing node identity are established in Planetary Space.</li> </ul>"},{"location":"core/on-boarding/#step-3-sub-agent-relationship","title":"Step 3. Sub-Agent Relationship","text":"<ul> <li>The computing node is recorded as a sub-agent of the user\u2019s I-Space.</li> <li>A membership agreement is created:<ul> <li>Grants the user full stewardship/admin privileges over the computing node.</li> <li>Establishes mutual recognition (key exchange).</li> <li>Agreement is inherently mutual (signed by both parties).</li> </ul> </li> </ul>"},{"location":"core/on-boarding/#step-4-activation","title":"Step 4. Activation","text":"<ul> <li>The computing node is provisioned with the Nine core applications.</li> <li>Applications run inside computing nodes, not directly in the I-Space.</li> <li>The I-Space view displays:<ul> <li>Core Identity (center).</li> <li>Data Grove (personal cloud).</li> <li>Sub-agents (computing nodes) around the ring.</li> </ul> </li> </ul>"},{"location":"core/on-boarding/#3-temporal-sequence-protocol-vs-conceptual","title":"3. Temporal Sequence: Protocol vs. Conceptual","text":"<p>There is a subtle but important distinction between how onboarding must occur at the protocol level (Holochain mechanics) versus how it is best understood at the conceptual level (MAP narrative).</p>"},{"location":"core/on-boarding/#protocol-sequence-holochain-view","title":"Protocol Sequence (Holochain View)","text":"<ol> <li>Compute node identity is generated first.<ul> <li>A device cannot participate in a DHT without an agent keypair.</li> </ul> </li> <li>I-Space (personal identity) is generated.<ul> <li>A keypair is created for the human\u2019s core identity.</li> </ul> </li> <li>Agreement is recorded between the two.<ul> <li>Membership establishes the compute node as a sub-agent of the I-Space.</li> </ul> </li> </ol>"},{"location":"core/on-boarding/#conceptual-sequence-map-view","title":"Conceptual Sequence (MAP View)","text":"<ol> <li>I-Space exists first as the enclosing membrane.<ul> <li>Represents the person\u2019s personal cloud and identity.</li> </ul> </li> <li>Computing node is ingested into the I-Space.<ul> <li>The I-Space \u201cabsorbs\u201d the node into its membrane, making it a sub-agent.</li> </ul> </li> <li>Agreement is mutual but is understood as the I-Space granting stewardship authority to the person over the node.</li> </ol>"},{"location":"core/on-boarding/#reconciliation","title":"Reconciliation","text":"<ul> <li>Protocol necessity: Device keys come first (Holochain requirement).</li> <li>Conceptual truth: The I-Space envelops its computing nodes (MAP metaphor).</li> <li>Documentation implication: Both sequences are valid; developers must follow the protocol, storytellers should communicate the conceptual.</li> </ul>"},{"location":"core/on-boarding/#4-open-questions","title":"4. Open Questions","text":"<ol> <li> <p>Key Generation for Hardware</p> <ul> <li>How exactly are compute node identities derived?</li> <li>Is device hardware entropy/identifier hashed into the keypair?</li> <li>Best practice for bootstrapping Holochain agent keys to hardware?</li> </ul> </li> <li> <p>Sequential Dependencies</p> <ul> <li>Does Holochain strictly enforce \u201cnode-first then I-Space,\u201d or can the appearance be reversed through orchestration?</li> <li>What does this mean for cross-device identity joining?</li> </ul> </li> </ol>"},{"location":"core/on-boarding/#5-storytelling-alignment","title":"5. Storytelling Alignment","text":"<p>For non-technical onboarding presentations: - Start from the user experience:     - Download gift \u2192 Accept invitation \u2192 Receive I-Space. - Emphasize simplicity:     - \u201cYour personal cloud\u201d     - \u201cYour devices become part of it\u201d - Reveal computing nodes and applications only as necessary. - Avoid algebraic notation (letters like A, B, C) \u2014 use relatable examples (Laptop, Phone, Tablet).</p>"},{"location":"core/transaction-model/","title":"\ud83e\uddfe MAP Transaction Model Specification","text":"<p>This document proposes a design for a Transaction Model used in the Memetic Activation Platform (MAP), grounding it in MAP\u2019s architectural principles and comparing it to event sourcing, Holochain, and CRDT systems.</p>"},{"location":"core/transaction-model/#overview-what-is-a-transaction-in-map","title":"\ud83d\udd39 Overview: What Is a Transaction in MAP?","text":"<p>A Transaction in MAP is a semantically meaningful, multi-operation commit unit that:</p> <ul> <li>Encapsulates one or more staged holon or relationship updates.</li> <li>Records validation outcomes, operation logs, and possible compensating operations.</li> <li>Results in either a validated commit, an invalid provisional state, or a rollback.</li> </ul> <p>Transactions serve both as: - A logical unit of change (semantic granularity), - And a backbone for undo, validation, and resolution semantics.</p>"},{"location":"core/transaction-model/#structure-of-a-transaction-holon","title":"\ud83e\uddf1 Structure of a Transaction Holon","text":"<pre><code>{\n  \"type\": \"#TransactionType\",\n  \"properties\": {\n    \"transaction_id\": \"txn:2025-08-19T17:54Z:87af0\",\n    \"timestamp\": \"2025-08-19T17:54:33Z\",\n    \"initiated_by\": \"Agent:alice\",\n    \"final_state\": \"CommittedWithWarnings\"  // or \"Validated\", \"Failed\", \"RolledBack\"\n  },\n  \"relationships\": {\n    \"Updated\": [ \"$ref\": \"Holon:book:MAP\" ],\n    \"HasValidationResult\": [ \"$ref\": \"#validation-too-many-tags\" ],\n    \"HasOperationLog\": [ \"$ref\": \"#op-1\", \"$ref\": \"#op-2\" ],\n    \"Compensates\": [ \"$ref\": \"#Transaction:txn-original\" ]\n  }\n}\n</code></pre>"},{"location":"core/transaction-model/#key-properties","title":"Key Properties","text":"Property Description <code>transaction_id</code> Unique identifier for the transaction. <code>initiated_by</code> Agent or process that initiated the commit. <code>final_state</code> Enum: <code>Validated</code>, <code>CommittedWithWarnings</code>, <code>Failed</code>, <code>RolledBack</code>, etc. <code>timestamp</code> When the transaction was created."},{"location":"core/transaction-model/#key-relationships","title":"Key Relationships","text":"Relationship Target Purpose <code>Updated</code> Holon(s) All holons affected in the transaction. <code>HasValidationResult</code> ValidationResult Records rule checks applied post-commit. <code>HasOperationLog</code> OperationLog Stores user-facing or compensatory operation sequences. <code>Compensates</code> Transaction Links to the prior transaction being rolled back."},{"location":"core/transaction-model/#best-practices-integrated-into-the-transaction-model","title":"\ud83d\udcda Best Practices Integrated into the Transaction Model","text":""},{"location":"core/transaction-model/#event-sourcing-practices","title":"\u2705 Event Sourcing Practices","text":"Event Sourced Concept MAP Equivalent Event stream per aggregate <code>StagedHolon</code> per entry Append-only log <code>OperationLog</code> attached to Transaction Optimistic concurrency (OCC) OCC applied at commit time using version check Snapshot for materialized state Materialized <code>StagedHolon</code> represents final state Sagas for long transactions <code>Transaction</code> + <code>Compensates</code> + Agreement policies Read model projection Nursery maintains a transient, fully materialized view of all holons in the Transaction scope"},{"location":"core/transaction-model/#key-takeaway","title":"Key Takeaway","text":"<p>MAP treats the Transaction Holon as the bounded event stream unit, aggregating property/relationship changes into a single validation and commit phase. The Nursery functions as an ephemeral read model or projection layer, allowing efficient access to the current state during staged editing and commit processing \u2014 much like a projection in traditional event-sourced systems.</p>"},{"location":"core/transaction-model/#holochain-comparisons","title":"\ud83c\udf00 Holochain Comparisons","text":"Holochain Concept MAP Layer <code>create_entry</code>, <code>update_entry</code> ops Underlying backing store for Holons Action Hash graph Reflected in <code>SemanticVersion</code> and <code>Updated</code> links DHT validation callbacks Wrapped into MAP\u2019s third-pass commit validation Branching via multiple updates Tracked and resolved via <code>ValidationResult</code> + <code>ConflictsWith</code>"},{"location":"core/transaction-model/#key-takeaway_1","title":"Key Takeaway","text":"<p>MAP extends Holochain\u2019s \u201cvalidation-on-each-op\u201d model by layering transaction-level, type-aware, and agreement-aware validation atop the raw chain mechanics.</p>"},{"location":"core/transaction-model/#crdt-perspective","title":"\ud83d\udd01 CRDT Perspective","text":"CRDT Trait MAP Position Automatic conflict resolution Not automatic \u2014 requires rule- or agreement-based merge logic Merge-on-receipt Delayed, semantic resolution during validation or review Convergence guarantee Conditional \u2014 governed by AgreementScope and policies Operation deltas Represented via fine-grained <code>OperationLog</code> commands Composability Holon structure is the merge target, not the CRDT state itself"},{"location":"core/transaction-model/#key-takeaway_2","title":"Key Takeaway","text":"<p>MAP\u2019s Transaction Model prioritizes semantic correctness over blind convergence. It supports CRDT-style operational tracking but rejects automatic merging unless declared via policy.</p>"},{"location":"core/transaction-model/#strategic-benefits-of-this-model","title":"\ud83e\udde0 Strategic Benefits of This Model","text":"<ul> <li>Enables fine-grained UX undo without polluting the DHT.</li> <li>Supports event sourcing patterns while maintaining a clean, materialized model.</li> <li>Adds semantic structure on top of Holochain\u2019s low-level operation model.</li> <li>Leaves room for application- and agreement-scoped conflict resolution, aligning with MAP\u2019s governance-first design.</li> </ul>"},{"location":"core/transaction-model/#open-extensions-future","title":"\ud83d\udccc Open Extensions (Future)","text":"<ul> <li><code>ResolutionPolicy</code> holons linked to <code>AgreementScope</code> and <code>ApplicationScope</code></li> <li><code>MergeResolution</code> holons for explicit fork merging</li> <li>Automatic detection of unresolved forks and triggering of merge workflows</li> <li>Parallel Transaction Streams per AgreementSpace</li> </ul>"},{"location":"core/transaction-model/#comparison-to-event-sourced-systems-holochain-crdts-and-mvcc_","title":"Comparison to Event-Sourced Systems, Holochain, CRDTs, and MVCC_","text":""},{"location":"core/transaction-model/#the-map-transaction-model","title":"\ud83c\udf31 The MAP Transaction Model","text":"<p>In the Memetic Activation Platform (MAP), every set of proposed changes to holons is staged in a local Nursery before being committed. A Transaction holon represents this unit of change. It is created at commit time and holds:</p> <ul> <li>Relationships to a set of ValidationResult holons</li> <li>Links to all updated Holons (via those results)</li> <li>State transitions such as <code>Unvalidated</code> \u2192 <code>Validated</code> \u2192 <code>Committed</code> or <code>RolledBack</code></li> <li>Optional logging of fine-grained operations to support undo/redo and compensating transactions</li> </ul> <p>The MAP\u2019s layered design separates validation (ensuring semantic correctness and consistency) from persistence (recording changes in the source of truth). Validation is performed before commit using rules scoped by both application logic and shared agreements (e.g. cardinality checks, role consistency, semantic integrity, etc.).</p>"},{"location":"core/transaction-model/#nursery-as-a-read-model-projection-layer","title":"\ud83e\udeb5 Nursery as a Read Model (Projection Layer)","text":"<p>In Event Sourced systems, projections (also called read models) are derived views of the event stream, optimized for user interaction. The MAP Nursery serves this role during a transaction:</p> <ul> <li>It maintains a materialized view of holons after every staged change.</li> <li>Ergonomic client APIs (e.g. <code>with_property</code>, <code>add_relationship</code>) mutate this staged state.</li> <li>These lightweight operations can be logged as Commands, enabling undo/redo support.</li> <li>Only at commit time is the transaction finalized and written as an immutable update.</li> </ul>"},{"location":"core/transaction-model/#comparison-to-event-sourcing-systems","title":"\ud83d\udd01 Comparison to Event Sourcing Systems","text":"Aspect Event Sourcing MAP Transaction Model Core Persistence Model Append-only event log Append-only holon updates (via DHT) Aggregates Derived from replaying events Materialized holons in nursery projections Validation Done before/after event persistence Done in the nursery, before commit Transaction Representation Often lacks explicit transaction Explicit <code>Transaction</code> holon Undo/Redo By reversing events or snapshots Via logged staged operations in nursery Compensating Transactions Application-defined Tracked via new Transaction holons Concurrency Control Typically OCC or snapshot isolation MVCC + Agreement-Scoped Conflict Resolution"},{"location":"core/transaction-model/#mvcc-in-map-vs-other-concurrency-strategies","title":"\u2699\ufe0f MVCC in MAP vs Other Concurrency Strategies","text":""},{"location":"core/transaction-model/#map-uses-multi-version-concurrency-control-mvcc","title":"\u2705 MAP uses Multi-Version Concurrency Control (MVCC)","text":"<ul> <li>Each holon update produces a new immutable version</li> <li>Writers do not block each other \u2014 they create parallel branches</li> <li>Version history is preserved and traceable</li> <li>Conflict detection is deferred, and resolution is semantic (not structural)</li> </ul>"},{"location":"core/transaction-model/#not-optimistic-concurrency-control-occ","title":"\u274c Not Optimistic Concurrency Control (OCC)","text":"<ul> <li>OCC would reject commits if the read version was outdated</li> <li>MAP instead accepts the write, creating a new fork</li> <li>This branching behavior supports collaborative divergence before reconciliation</li> </ul>"},{"location":"core/transaction-model/#conflict-resolution-strategies-crdts-vs-holochain-vs-map","title":"\ud83e\udde0 Conflict Resolution Strategies: CRDTs vs Holochain vs MAP","text":"Feature CRDTs Holochain MAP Conflict-Free? Claims \"conflict-free\" via auto-merge Leaves resolution to the application Explicitly supports semantic conflicts Merge Strategy Structural (e.g. last-write-wins, ORSet) None by default Application + Agreement-Scoped Semantics Determinism Always converges No built-in convergence Resolution logic is pluggable per domain Lost Updates Possible? Yes (e.g. in LWW) Yes Yes \u2014 but tracked and resolvable Undo Support Limited Manual Fine-grained undo via operation log Update Representation Per-property, tombstones, deltas Entry-level action history Per-holon, with ergonomic staging granularity Versioning Model Conflict-resolution per data type Full action chain (via hashes) Holon-level branches tracked via hashes <p>\ud83d\udd0d Note: While CRDTs automatically resolve structural conflicts, they often do so at the cost of semantic predictability. MAP preserves all branches and delegates resolution to shared agreements and application logic.</p>"},{"location":"core/transaction-model/#agreement-scopes-and-application-scopes","title":"\ud83d\udcdc Agreement Scopes and Application Scopes","text":"<p>To support meaningful conflict resolution:</p> <ul> <li>Agreement Scope: Specifies the participants and rules (e.g. communities, working groups) that govern semantic resolution.</li> <li>Application Scope: Defines the data boundaries (e.g. all holons in a shared Space) to which resolution applies.</li> </ul> <p>Resolution logic is therefore anchored in both the social commitments and the data model \u2014 ensuring that divergent updates are reconciled in a trustworthy, context-aware way.</p>"},{"location":"core/transaction-model/#summary","title":"\ud83e\udde9 Summary","text":"<p>MAP\u2019s Transaction model offers:</p> <ul> <li>A clear separation of staging, validation, and commit phases</li> <li>Fine-grained operation tracking for undo/redo and compensation</li> <li>Explicit MVCC-style version branching with later reconciliation</li> <li>A hybrid model blending Event Sourcing, Holochain DHT consistency, and semantic conflict resolution that goes beyond CRDTs</li> </ul> <p>This design supports both a robust technical foundation and the social contracts required for trustworthy, collaborative data stewardship.</p>"},{"location":"core/trust-channel-design-spec/","title":"MAP Trust Channel \u2014 Developer Design Spec (Fully Expanded)","text":""},{"location":"core/trust-channel-design-spec/#0-purpose-scope","title":"0. Purpose &amp; Scope","text":"<p>The Trust Channel is the MAP core service that encapsulates, transports, and validates Dance Capsules whenever an interaction crosses a membrane boundary between Spaces. It enforces Agreement-governed security, privacy, and protocol consistency through layered envelopes that correspond to membrane validation gates.</p> <p>Trust Channels:</p> <ul> <li>Exist only in the Rust runtime; the TypeScript SDK never hosts a Trust Channel.</li> <li>Are always governed by an Agreement, which defines envelope sequencing, crypto and policy parameters.</li> <li>Dynamically select compatible ProtocolSuites through Protocol Negotiation during capsule formation.</li> <li>Trigger the transport and validation mechanism for all cross-Space Dances.</li> </ul> <p>The TypeScript\u2194Rust interface inside a single Tauri process is not a membrane boundary and therefore bypasses Trust Channel logic.</p>"},{"location":"core/trust-channel-design-spec/#1-deployment-architecture","title":"1. Deployment Architecture","text":""},{"location":"core/trust-channel-design-spec/#11-system-topology-overview","title":"1.1 System Topology Overview","text":"<p>Each Agent in MAP operates within an Agreement Space\u2014a space containing all (and only) those Agents that share at least one Agreement. Agents are depicted as spheres connected by a mycelial web of Trust Channels representing the live peer-to-peer fabric.</p> <ul> <li>Source Container: Rust runtime of the sending Agent (Space A).</li> <li>Destination Container: Rust runtime of the receiving Agent (Space B).</li> <li>Trust Channel: logical and cryptographic conduit linking both membranes.</li> <li>Transport Protocol: the routing mechanism defined by the Agreement (e.g., DHT gossip, relay, or direct peer link).</li> </ul> <p>When a DanceRequest leaves an Agent\u2019s pore, it travels through the Trust Channel across the mycelial web, wrapped in layers of envelopes that perform sequential validation. At the receiving pore, the Trust Channel unwraps these envelopes inward, validating routing, signature, encryption, authorization, and dispatch. A DanceResponse is then re-encapsulated with outbound envelopes in reverse order and sent back through the same path.</p>"},{"location":"core/trust-channel-design-spec/#12-trust-channel-cross-section","title":"1.2 Trust Channel Cross-Section","text":"<p>Each Trust Channel is visualized as a funnel through the agent\u2019s membrane. Envelopes are represented as gates, initially closed. As validation succeeds layer by layer, each gate opens and the remaining inner capsule drops through to the next gate until only the inner Dance remains. Outbound responses travel upward through the same funnel, having their envelopes reapplied and gates resealed.</p>"},{"location":"core/trust-channel-design-spec/#13-implementation-layers-and-protocol-adapters","title":"1.3 Implementation Layers and Protocol Adapters","text":"<p>Every membrane-crossing exchange follows the same structural flow:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Protocol Adapters (transport-specific)       \u2502\n\u2502  \u251c\u2500 Holochain extern adapter                  \u2502\n\u2502  \u251c\u2500 Direct Wire adapter (future)              \u2502\n\u2502  \u251c\u2500 Relay / HTTP adapter (future)             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502  (Capsule ingress / egress)\n                \u25bc\n         CapsuleDancer::dance_capsule()\n                \u2502\n                \u25bc\n           TrustChannel\n      (unwrap \u2192 validate \u2192 dispatch)\n                \u2502\n                \u25bc\n             Dancer\n          (executes the Dance)\n                \u2502\n                \u25bc\n           TrustChannel\n      (wrap \u2192 encrypt \u2192 sign)\n                \u2502\n                \u25bc\n         CapsuleDancer::dance_capsule()\n</code></pre> <p>Key Points</p> <ul> <li>The <code>#[hdk_extern] fn dance_capsule</code> in the Holochain build acts as the Holochain Protocol Adapter\u2014the membrane pore for that protocol.</li> <li>All protocol adapters, present and future, delegate to the same <code>CapsuleDancer::dance_capsule</code> function.</li> <li><code>CapsuleDancer</code> is protocol-agnostic; it receives inbound capsules and hands them to the <code>TrustChannel</code> for envelope handling and dispatch.</li> <li><code>TrustChannel</code> performs the actual wrap/unwrap sequence, policy enforcement, suite negotiation, and orchestration of requests and replies.</li> <li><code>Dancer</code> executes the validated <code>Dance</code> inside the local space after all Trust Channel gates have cleared.</li> </ul> <p>This layering produces a unified ingress/egress interface shared across all transports. It ensures that Trust Channel logic, envelope validation, and Agreement-based security are applied consistently\u2014no matter which protocol conveys the capsule.</p>"},{"location":"core/trust-channel-design-spec/#2-core-concepts","title":"2. Core Concepts","text":""},{"location":"core/trust-channel-design-spec/#20-narrative-overview","title":"2.0 Narrative Overview","text":"<p>The Trust Channel\u2019s terminology and type system are intentionally aligned with the language of Dances. Every core trait and struct name was chosen to reflect its role in the lifecycle of a Dance and to make Trust Channel code read semantically true to its purpose. This consistency ensures that both developers and auditors can infer each component\u2019s responsibility directly from its name.</p> Conceptual Role Rust Type Primary Verb Description Dance Initiator <code>trait DanceInitiator</code> initiate Begins a new Dance across a membrane. The caller works purely with Dances, not Capsules. Trust Channel <code>struct TrustChannel</code> convey Implements <code>DanceInitiator</code> and <code>CapsuleDancer</code>; orchestrates the wrapping, validation, and transport of Capsules. Capsule Dancer <code>trait CapsuleDancer</code> dance Protocol-agnostic ingress/egress interface invoked by all protocol adapters (Holochain, Wire, HTTP, etc.). Dancer <code>trait Dancer</code> dance Executes the validated <code>Dance</code> inside the local space after all Trust Channel gates have cleared."},{"location":"core/trust-channel-design-spec/#narrative-rule","title":"Narrative Rule","text":"<p>Initiators initiate dances; Trust Channels convey dances via capsules; Capsule Dancers dance capsules; and Dancers dance dances.</p> <p>This rule serves as the linguistic foundation of the Trust Channel\u2019s architecture. The following sections describe how Dances are encapsulated, validated, and conveyed through the membrane layers defined by their governing Agreements and ProtocolSuites.</p>"},{"location":"core/trust-channel-design-spec/#21-dance-capsule","title":"2.1 Dance Capsule","text":"<p>A Dance Capsule is a Russian doll\u2013like structure of nested Envelopes that surround a <code>Dance</code> (request or response). Each envelope performs one membrane function: routing, authentication, encryption, authorization, state transfer, dispatch, or filtering.</p> <p>Inbound validation sequence: <code>Transport \u2192 AuthN \u2192 Crypto \u2192 AuthZ \u2192 Dispatch \u2192 SessionState \u2192 Payload</code></p> <p>Outbound response sequence: <code>Payload \u2192 SessionState \u2192 Exfiltration \u2192 Crypto \u2192 AuthN \u2192 Transport</code></p> <p>For inbound capsules, each layer exposes progressively unwrapped content to the next validation phase until only the inner PayloadEnvelope remains, revealing the <code>Dance</code> to be executed. For outbound capsules, each layer successively rewraps the content, sealing the validated <code>DanceResponse</code> for return transport.</p> <p>The SessionStateEnvelope appears immediately inside the Dispatch/Exfiltration boundary. It carries transient holon state and nursery references needed for stateless or multi-step executions, ensuring that ephemeral context can safely cross the membrane without persistent storage.</p>"},{"location":"core/trust-channel-design-spec/#22-agreement-and-protocolsuite","title":"2.2 Agreement and ProtocolSuite","text":"<p>Each Trust Channel is governed by an Agreement, which defines the policies, cryptographic parameters, and procedural rules that bind all participants within its trust domain. An Agreement is not a design-time construct; it is a runtime artifact produced through the Promise Weave Protocol, in which participating agents exchange and mutually sign reciprocal promises. Those promises collectively determine the channel\u2019s trust semantics, including the ProtocolSuite to be used for all subsequent capsule exchanges.</p> <p>The resulting ProtocolSuite is pinned to the Agreement at the moment the weave completes. It defines the complete envelope composition and validation order for the channel, ensuring that all parties share a common, immutable understanding of how capsules are formed, validated, and conveyed. Once established, the suite cannot be altered dynamically \u2014 only the transport protocol that carries the capsules may vary at runtime.</p> <p>An Agreement specifies:</p> <ul> <li>Its governing ProtocolSuite (defining the envelope structure and allowable transport families for this trust domain).</li> <li>Mappings between Dances and the suite via <code>DancePolicyMap</code>.</li> <li>Cryptographic and policy relationships (<code>AuthZPolicy</code>, <code>CryptoPolicy</code>, <code>ExfiltrationPolicy</code>, <code>StepUpPolicy</code>).</li> </ul> <p>A ProtocolSuite holon defines:</p> <ul> <li>The ordered envelope sequences for inbound and outbound directions, including whether the SessionStateEnvelope is required or optional.</li> <li>The validator modules for each envelope kind.</li> <li>The cryptographic, authorization, and state-transfer policies applied at each layer.</li> <li>The set of transport protocols supported for runtime selection.</li> </ul> <p>Together, the Agreement and its pinned ProtocolSuite completely determine the membrane behavior for all capsule exchanges within that domain. Only the transport protocol remains subject to runtime negotiation.</p>"},{"location":"core/trust-channel-design-spec/#23-protocol-negotiation","title":"2.3 Protocol Negotiation","text":"<p>Protocol negotiation determines which transport protocol will be used for a specific capsule exchange under an established Agreement. All higher-level parameters \u2014 envelope ordering, policies, and validation gates \u2014 are pinned by the Agreement\u2019s ProtocolSuite and cannot vary at runtime.</p> <p>Negotiation occurs only when sender and receiver must select among the transport mechanisms enumerated in the Agreement. This selection allows peers to adapt to transient network conditions such as reachability, latency, or relay availability without altering the trust semantics of the exchange.</p> <p>Negotiation Steps</p> <ol> <li>Proposal \u2014 The sender selects a candidate transport from the ProtocolSuite\u2019s supported set and records it as <code>ProposesTransport</code> in the outer <code>TransportEnvelope</code>.</li> <li>Validation \u2014 The receiver confirms that the proposed transport is allowed under the Agreement and compatible with the pinned <code>ProtocolSuite</code>.</li> <li>Response \u2014 The receiver records its choice as <code>AcceptedTransport</code>, either confirming the proposal or selecting an alternative from the allowed set.</li> <li>Pinning \u2014 The capsule pins <code>PinnedAgreement \u2192 Agreement</code>, <code>PinnedSuite \u2192 ProtocolSuite</code>, and <code>NegotiatedTransport \u2192 TransportProtocol</code>.</li> <li>Verification \u2014 Upon receipt, validators confirm that the negotiated transport matches the Agreement\u2019s definitions and that all pinned parameters remain consistent.</li> </ol> <p>Example <pre><code>TransportEnvelope\n \u251c\u2500\u2500 ForAgreement \u2192 #agr:std\n \u251c\u2500\u2500 PinnedSuite \u2192 #suite:std-full\n \u251c\u2500\u2500 ProposesTransport \u2192 DHT\n \u2514\u2500\u2500 AcceptedTransport \u2192 Relay\n</code></pre></p> <p>Once transport selection is complete, the capsule exchange proceeds under the pinned <code>ProtocolSuite</code>. Envelope ordering, cryptographic policies, and validation rules remain invariant throughout the interaction, ensuring that every Trust Channel behaves consistently with the terms of its Agreement.</p>"},{"location":"core/trust-channel-design-spec/#24-session-state-envelope","title":"2.4 Session State Envelope","text":"<p>The SessionStateEnvelope enables stateful workflows to operate across otherwise stateless environments. It serializes transient holons and relationship references needed to resume an in-flight Dance while preventing data persistence outside the membrane.</p> <p>Conceptual Purpose - Provides transient continuity between asynchronous or multi-step Dances. - Avoids leaking ephemeral data into long-lived storage. - Ensures transient state passes through the same validation gates as other envelopes.</p> <p>Holon Type and Relationships <pre><code>HolonType: SessionStateEnvelope\nRelationships:\n  Wraps \u2192 PayloadEnvelope\n  CarriesState \u2192 [TransientHolonPool, NurseryRefs]\n</code></pre></p> <p>Key Data Fields - <code>state_hash</code>: integrity checksum of serialized transient data - <code>state_length</code>: size of the transient payload in bytes - <code>allowed_types</code>: whitelist of permitted transient holon types</p> <p>Processing Steps Build 1. Serialize the transient pool and nursery references. 2. Compute and record the state hash and metadata. 3. Attach to the inner <code>PayloadEnvelope</code>.</p> <p>Validate 1. Verify hash integrity and payload size. 2. Deserialize the transient pool into local memory. 3. Enforce the <code>allowed_types</code> whitelist.</p> <p>Expected Outcome Transient state is hydrated in the recipient\u2019s runtime context, enabling seamless continuation of execution without permanent storage.</p> <p>Current Implementation Status: The Session State Envelope is the only Trust Channel layer realized in the initial implementation (Issue #308). All other envelopes remain stubbed for future iterations once cross-Space communication is activated.</p>"},{"location":"core/trust-channel-design-spec/#24-roles-traits-and-naming-narrative","title":"2.4 Roles, Traits, and Naming Narrative","text":"<p>MAP adopts consistent nouns and verbs so that Trust Channel code reads like the story it represents. Each trait name and its primary verb mirror the narrative logic of a Dance.</p> Conceptual Role Rust Type Key Function(s) Primary Verb Operates On Description Dance Initiator <code>trait DanceInitiator</code> <code>async fn initiate_dance(&amp;self, context, request)</code> initiate <code>DanceRequest \u21a6 DanceResponse</code> Begins a new Dance across a membrane. The caller sees only Dances, not Capsules. Trust Channel <code>struct TrustChannel</code> (implements <code>DanceInitiator</code> and <code>CapsuleDancer</code>) <code>initiate_dance()</code> / <code>dance_capsule()</code> convey <code>Capsule</code> Governs envelope wrapping/unwrapping, validation, and transport orchestration. Capsule Dancer <code>trait CapsuleDancer</code> <code>fn dance_capsule(&amp;self, capsule)</code> dance <code>Capsule \u21a6 Capsule</code> Protocol-agnostic ingress/egress interface called by all adapters (Holochain, Wire, HTTP, etc.). Dancer <code>trait Dancer</code> <code>async fn dance(&amp;self, request)</code> dance inner <code>Dance</code> Executes the validated Dance inside the local space once all Trust Channel gates have cleared."},{"location":"core/trust-channel-design-spec/#narrative-rule_1","title":"Narrative Rule","text":"<p>Initiators initiate dances; Trust Channels convey dances via capsules; Capsule Dancers dance capsules; and Dancers dance dances.</p> <p>These naming conventions preserve conceptual clarity, separate transport concerns from trust logic, and ensure that function names describe their precise role in the Dance lifecycle.</p>"},{"location":"core/trust-channel-design-spec/#3-envelope-layer-reference-expanded","title":"3. Envelope Layer Reference (Expanded)","text":"<p>(Each layer acts as a gate in the membrane funnel.)</p>"},{"location":"core/trust-channel-design-spec/#31-transport-envelope","title":"3.1 Transport Envelope","text":"<p>Summary: The outermost envelope governing routing, Agreement pinning, and protocol negotiation.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose","title":"Conceptual Purpose","text":"<p>The TransportEnvelope establishes the routing and trust context for the capsule. It ensures that the message travels only between agents authorized by the governing Agreement and that both peers agree on the ProtocolSuite governing this exchange.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships","title":"Holon Type and Relationships","text":"<pre><code>HolonType: TransportEnvelope\nRelationships:\n  Wraps \u2192 AuthNEnvelope\n  ForAgreement \u2192 Agreement\n  ProposesSuite \u2192 ProtocolSuite?\n  AcceptedSuite \u2192 ProtocolSuite\n  SenderAgent \u2192 Agent\n  RecipientAgent \u2192 Agent\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields","title":"Key Data Fields","text":"<ul> <li><code>sender_id</code>: Agent identifier of initiator</li> <li><code>recipient_id</code>: target Agent identifier</li> <li><code>agreement_ref</code>: reference to Agreement ID and version hash</li> <li><code>transport_protocol</code>: protocol to be used (DHT, relay, direct)</li> <li><code>timestamp</code>: for replay detection</li> <li><code>routing_signature</code>: optional checksum or route proof</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps","title":"Processing Steps","text":"<p>Build: 1. Fetch Agreement metadata; confirm peer is an authorized participant. 2. Select candidate <code>ProtocolSuite</code> and record as <code>ProposesSuite</code>. 3. Compute and store routing metadata and Agreement hash. 4. Attach the next envelope as payload.</p> <p>Validate: 1. Verify Agreement hash matches local record. 2. Check recipient field corresponds to the local Agent. 3. Confirm <code>AcceptedSuite</code> belongs to Agreement\u2019s allowed suites. 4. Resolve routing path via Agreement transport settings.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome","title":"Expected Outcome","text":"<p>Validated routing context and pinned Agreement; the capsule is confirmed to have arrived at the correct membrane pore under the proper governance framework.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance","title":"Developer Guidance","text":"<p>Rust developers should implement this as the first validator in the inbound pipeline. TransportEnvelope validation failures typically indicate misrouting or incompatible Agreements.</p>"},{"location":"core/trust-channel-design-spec/#32-authentication-envelope-authn","title":"3.2 Authentication Envelope (AuthN)","text":"<p>Summary: Establishes the authenticity and integrity of the capsule.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_1","title":"Conceptual Purpose","text":"<p>The AuthNEnvelope confirms that the message was genuinely sent by an authorized participant and that its contents have not been modified since transmission.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_1","title":"Holon Type and Relationships","text":"<pre><code>HolonType: AuthNEnvelope\nRelationships:\n  Wraps \u2192 CryptoEnvelope\n  SignerAgent \u2192 Agent\n  UsesCryptoPolicy \u2192 CryptoPolicy\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_1","title":"Key Data Fields","text":"<ul> <li><code>signature_scheme</code>: algorithm identifier (e.g., Ed25519)</li> <li><code>signature</code>: base64 signature of inner envelope hash</li> <li><code>signer_public_key_ref</code>: pointer to sender\u2019s public key within Agreement</li> <li><code>signed_hash</code>: computed SHA-256 or BLAKE3 digest</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_1","title":"Processing Steps","text":"<p>Build: 1. Serialize the inner envelope and compute hash. 2. Sign the hash using the sender\u2019s private key via Lair. 3. Attach signature and metadata.</p> <p>Validate: 1. Retrieve sender\u2019s public key from Agreement. 2. Recompute hash of the inner envelope. 3. Verify signature using declared algorithm. 4. Log outcome to telemetry for risk analysis.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_1","title":"Expected Outcome","text":"<p>Message integrity and sender authenticity confirmed. If verification fails, the capsule is discarded.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_1","title":"Developer Guidance","text":"<p>Use the <code>ring</code> or <code>ed25519_dalek</code> crates for signing/verification; keys must always be accessed through Lair interfaces. Avoid holding private keys in process memory longer than necessary.</p>"},{"location":"core/trust-channel-design-spec/#33-cryptography-envelope-crypto","title":"3.3 Cryptography Envelope (Crypto)","text":"<p>Summary: Provides confidentiality by encrypting the inner payload.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_2","title":"Conceptual Purpose","text":"<p>The CryptoEnvelope ensures that only the intended recipient can read the inner payload. It also provides tamper protection and payload freshness via nonces.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_2","title":"Holon Type and Relationships","text":"<pre><code>HolonType: CryptoEnvelope\nRelationships:\n  Wraps \u2192 AuthZEnvelope\n  RecipientAgent \u2192 Agent\n  UsesCryptoPolicy \u2192 CryptoPolicy\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_2","title":"Key Data Fields","text":"<ul> <li><code>cipher_suite</code>: e.g., XChaCha20-Poly1305</li> <li><code>nonce</code>: unique per message</li> <li><code>encrypted_payload</code>: ciphertext of next envelope</li> <li><code>key_ref</code>: recipient public key or shared secret identifier</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_2","title":"Processing Steps","text":"<p>Build: 1. Serialize inner envelope. 2. Generate random nonce. 3. Encrypt payload with recipient\u2019s public key or derived shared secret. 4. Attach cipher suite metadata.</p> <p>Validate: 1. Fetch recipient private key from Lair. 2. Decrypt payload using declared cipher suite. 3. Verify authentication tag integrity. 4. Replace ciphertext with plaintext inner envelope.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_2","title":"Expected Outcome","text":"<p>Payload decrypted successfully; the next layer is now readable only by authorized recipient.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_2","title":"Developer Guidance","text":"<p>Follow the crypto policy declared in Agreement. Ensure nonce uniqueness per sender-recipient-session to prevent replay attacks.</p>"},{"location":"core/trust-channel-design-spec/#34-authorization-envelope-authz","title":"3.4 Authorization Envelope (AuthZ)","text":"<p>Summary: Enforces role- and scope-based permission checks.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_3","title":"Conceptual Purpose","text":"<p>The AuthZEnvelope ensures the request is permitted under the Agreement\u2019s role, scope, and timing rules. It acts as a programmable contract verifying that the sender\u2019s authority matches the Dance being requested.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_3","title":"Holon Type and Relationships","text":"<pre><code>HolonType: AuthZEnvelope\nRelationships:\n  Wraps \u2192 DispatchEnvelope\n  ForAgreement \u2192 Agreement\n  EvaluatedBy \u2192 AuthZPolicy\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_3","title":"Key Data Fields","text":"<ul> <li><code>role</code>: sender\u2019s role within Agreement</li> <li><code>scope</code>: access scope or resource domain</li> <li><code>policy_tag</code>: identifier for specific AuthZPolicy</li> <li><code>valid_from</code> / <code>valid_until</code>: temporal constraints</li> <li><code>policy_signature</code>: optional policy binding proof</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_3","title":"Processing Steps","text":"<p>Build: 1. Query Agreement for sender\u2019s role and applicable AuthZPolicy. 2. Embed policy tag and validity window. 3. Sign policy tag if required.</p> <p>Validate: 1. Fetch AuthZPolicy from Agreement. 2. Evaluate role-scope alignment against requested Dance. 3. Check time window validity. 4. Verify policy signature if provided.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_3","title":"Expected Outcome","text":"<p>Authorization confirmed. Capsule can proceed to dispatch. If denied, validation stops with <code>HolonError::UnauthorizedRole</code>.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_3","title":"Developer Guidance","text":"<p>The AuthZ layer is where governance logic is enforced. Ensure policies are declarative holons so they can evolve without code changes.</p>"},{"location":"core/trust-channel-design-spec/#35-dispatch-envelope","title":"3.5 Dispatch Envelope","text":"<p>Summary: Controls membrane handoff to local execution.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_4","title":"Conceptual Purpose","text":"<p>The DispatchEnvelope represents the moment a capsule transitions from inter-Space validation into intra-Space execution. It validates the target I-Space, ensures that the Dance type is known locally, and checks that any declared target matches an available handler.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_4","title":"Holon Type and Relationships","text":"<pre><code>HolonType: DispatchEnvelope\nRelationships:\n  Wraps \u2192 PayloadEnvelope\n  TargetSpace \u2192 Space\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_4","title":"Key Data Fields","text":"<ul> <li><code>target_space</code>: identifier of destination I-Space or subcontext</li> <li><code>execution_context</code>: optional environment variables</li> <li><code>dispatch_signature</code>: integrity hash of routing parameters</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_4","title":"Processing Steps","text":"<p>Build: 1. Determine target I-Space based on Agreement routing. 2. Compute dispatch hash. 3. Attach as header to envelope.</p> <p>Validate: 1. Confirm that <code>target_space</code> matches local identifier. 2. Check that Dance type exists and is callable. 3. Log dispatch acceptance event.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_4","title":"Expected Outcome","text":"<p>Local execution context prepared; control passed to Choreographer.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_4","title":"Developer Guidance","text":"<p>Implement DispatchEnvelope validation as the final gate before local code execution. Validation failures should never trigger automatic retries.</p>"},{"location":"core/trust-channel-design-spec/#36-payload-envelope","title":"3.6 Payload Envelope","text":"<p>Summary: Contains the actual DanceRequest or DanceResponse.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_5","title":"Conceptual Purpose","text":"<p>The PayloadEnvelope is the innermost layer, containing the semantic content of the interaction. At this point all membrane gates have been cleared.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_5","title":"Holon Type and Relationships","text":"<pre><code>HolonType: PayloadEnvelope\nRelationships:\n  HasPayloadDance \u2192 Dance\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_5","title":"Key Data Fields","text":"<ul> <li><code>payload_type</code>: Request or Response</li> <li><code>payload_model</code>: descriptor name</li> <li><code>payload_digest</code>: hash for integrity</li> <li><code>content_encoding</code>: optional compression scheme</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_5","title":"Processing Steps","text":"<p>Build: 1. Serialize Dance into canonical format. 2. Compute payload hash. 3. Embed descriptor metadata.</p> <p>Validate: 1. Verify hash matches payload content. 2. Deserialize Dance into model. 3. Pass to Choreographer.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_5","title":"Expected Outcome","text":"<p>Validated and deserialized Dance ready for execution.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_5","title":"Developer Guidance","text":"<p>This envelope rarely fails validation except for integrity mismatches. Any schema errors should be handled by the Choreographer.</p>"},{"location":"core/trust-channel-design-spec/#37-exfiltration-envelope-outbound","title":"3.7 Exfiltration Envelope (Outbound)","text":"<p>Summary: Filters outbound data per Agreement\u2019s ExfiltrationPolicy.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_6","title":"Conceptual Purpose","text":"<p>The ExfiltrationEnvelope ensures that responses leaving a Space comply with that Space\u2019s data sharing rules. It enforces outbound privacy and ensures that only agreed-upon data crosses the membrane.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_6","title":"Holon Type and Relationships","text":"<pre><code>HolonType: ExfiltrationEnvelope\nRelationships:\n  Wraps \u2192 CryptoEnvelope\n  AppliesPolicy \u2192 ExfiltrationPolicy\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_6","title":"Key Data Fields","text":"<ul> <li><code>policy_tag</code>: identifier of applied ExfiltrationPolicy</li> <li><code>allowed_fields</code>: whitelist of fields</li> <li><code>thresholds</code>: quantitative limits (e.g., max records)</li> <li><code>sanitization_map</code>: redaction rules</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_6","title":"Processing Steps","text":"<p>Build: 1. Retrieve ExfiltrationPolicy from Agreement. 2. Filter or redact prohibited fields. 3. Record policy tag and transformation metadata.</p> <p>Validate: 1. Confirm policy tag exists and matches Agreement. 2. Verify filtered payload complies with declared thresholds. 3. Hash sanitized payload for audit.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_6","title":"Expected Outcome","text":"<p>Outbound data sanitized, ready for encryption.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_6","title":"Developer Guidance","text":"<p>Developers must implement serialization filters at this layer. Avoid policy logic in business code; always reference ExfiltrationPolicy holons.</p>"},{"location":"core/trust-channel-design-spec/#38-unlock-envelope-optional","title":"3.8 Unlock Envelope (Optional)","text":"<p>Summary: Captures Second-Factor Session (SFS) verification for sensitive Dances.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_7","title":"Conceptual Purpose","text":"<p>The UnlockEnvelope adds human-level verification to the cryptographic stack. It confirms that the user controlling the device has recently authenticated through a configured second factor before performing sensitive or high-risk operations.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_7","title":"Holon Type and Relationships","text":"<pre><code>HolonType: UnlockEnvelope\nRelationships:\n  Wraps \u2192 NextEnvelope\n  VerifiedBy \u2192 StepUpPolicy\n  SessionBelongsTo \u2192 Agent\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_7","title":"Key Data Fields","text":"<ul> <li><code>session_id</code>: UUID of SFS</li> <li><code>verified_method</code>: biometric | PIN | hardware_key</li> <li><code>expires_at</code>: timestamp</li> <li><code>issued_at</code>: timestamp</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_7","title":"Processing Steps","text":"<p>Build: 1. Verify an active SFS exists for this Agent. 2. Record method and expiry. 3. Link to StepUpPolicy.</p> <p>Validate: 1. Fetch SFS from secure store. 2. Check TTL and idle timeout. 3. Confirm cryptographic binding to Agent ID.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_7","title":"Expected Outcome","text":"<p>Step-up authentication confirmed; the Dance may proceed.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_7","title":"Developer Guidance","text":"<p>UnlockEnvelope creation and validation should integrate with the device OS authentication APIs. Never store SFS secrets in application memory.</p>"},{"location":"core/trust-channel-design-spec/#39-sessionstate-envelope-optional","title":"3.9 SessionState Envelope (Optional)","text":"<p>Summary: Transports transient holon state for stateless executions.</p>"},{"location":"core/trust-channel-design-spec/#conceptual-purpose_8","title":"Conceptual Purpose","text":"<p>The SessionStateEnvelope allows stateful workflows to execute in stateless environments by serializing necessary transient holons and relationship references. It ensures the guest process has enough context to continue processing without permanent data leakage.</p>"},{"location":"core/trust-channel-design-spec/#holon-type-and-relationships_8","title":"Holon Type and Relationships","text":"<pre><code>HolonType: SessionStateEnvelope\nRelationships:\n  Wraps \u2192 PayloadEnvelope\n  CarriesState \u2192 [TransientHolonPool, NurseryRefs]\n</code></pre>"},{"location":"core/trust-channel-design-spec/#key-data-fields_8","title":"Key Data Fields","text":"<ul> <li><code>state_hash</code>: integrity checksum</li> <li><code>state_length</code>: size in bytes</li> <li><code>allowed_types</code>: whitelist of permitted transient types</li> </ul>"},{"location":"core/trust-channel-design-spec/#processing-steps_8","title":"Processing Steps","text":"<p>Build: 1. Serialize transient pool and nursery references. 2. Compute hash and record metadata. 3. Attach to next envelope.</p> <p>Validate: 1. Verify hash integrity. 2. Deserialize transient pool. 3. Enforce allowed_types filter.</p>"},{"location":"core/trust-channel-design-spec/#expected-outcome_8","title":"Expected Outcome","text":"<p>State hydrated in recipient\u2019s transient context; execution can proceed seamlessly.</p>"},{"location":"core/trust-channel-design-spec/#developer-guidance_8","title":"Developer Guidance","text":"<p>Keep transient pools small. This mechanism is not intended for bulk data transfer. Always validate deserialized objects before use.</p>"},{"location":"core/trust-channel-design-spec/#4-lifecycle-overview","title":"4. Lifecycle Overview","text":"<ol> <li>Outbound Request: Select suite, negotiate, build, transmit.</li> <li>Inbound Validation: Validate sequentially (Transport\u2192AuthN\u2192Crypto\u2192AuthZ\u2192Dispatch\u2192Payload).</li> <li>Response: Apply outbound envelopes in reverse order and send back.</li> </ol>"},{"location":"core/trust-channel-design-spec/#5-error-handling","title":"5. Error Handling","text":"Error Description <code>InvalidAgreementRef</code> Agreement hash mismatch. <code>ProtocolSuiteMismatch</code> Suite not permitted. <code>InvalidProtocolProposal</code> Proposed suite invalid. <code>SuiteDownshiftNotPermitted</code> Unauthorized fallback. <code>SignatureInvalid</code> AuthN failure. <code>DecryptionFailed</code> Crypto validation failed. <code>UnauthorizedRole</code> AuthZ check failed. <code>DispatchDenied</code> Target invalid. <code>ExfiltrationDenied</code> Policy violation. <code>RequiresSecondFactor</code> Missing SFS. <code>SessionStateUnavailable</code> Missing transient data."},{"location":"core/trust-channel-design-spec/#6-implementation-notes","title":"6. Implementation Notes","text":"<ul> <li>All envelopes and policies are holons declared in the Meta-Schema.</li> <li>Validators and builders are modular and referenced dynamically via descriptors.</li> <li>Use Lair for all key operations; private keys never exposed.</li> <li>Emit telemetry for every validation result to support audit and behavioral analysis.</li> <li>Agreements may define multiple suites per sensitivity tier for flexible negotiation.</li> </ul>"},{"location":"core/trust-channel-design-spec/#61-packaging-and-dependency-isolation","title":"6.1 Packaging and Dependency Isolation","text":"<p>Protocol-specific dependencies\u2014such as Holochain\u2019s <code>hdk</code>\u2014are confined to adapter crates. The Trust Channel and Capsule Dancer remain pure Rust libraries, enabling protocol pluggability and independent evolution.</p> <p>Recommended Crate Layout <pre><code>map_core/                \u2190 holons, agreements, policies\nmap_trust_channel/       \u2190 DanceInitiator, CapsuleDancer, TrustChannel\nmap_holochain_adapter/   \u2190 Holochain externs (depends on `hdk`)\nmap_wire_adapter/        \u2190 future direct P2P adapter\nmap_http_adapter/        \u2190 future relay / gateway adapter\n</code></pre></p> <p>Key Principles - Core and trust-channel crates contain no direct dependency on <code>hdk</code> or any host framework. - Each adapter crate provides its own membrane interface (e.g., <code>#[hdk_extern] fn dance_capsule</code>) and delegates to the same <code>CapsuleDancer</code> implementation. - This encapsulation enables testing and reuse of the Trust Channel in multiple environments and ensures that only the outermost adapter layer needs updating when a transport changes.</p>"},{"location":"core/trust-channel-design-spec/#7-summary","title":"7. Summary","text":"<p>The Trust Channel provides a layered, Agreement-driven security framework for all cross-Space communications. Each envelope serves a distinct purpose, from routing and authentication to encryption, authorization, dispatch, and outbound filtering. Protocol negotiation guarantees interoperability, while each validation gate enforces sovereignty and trust. This layered architecture transforms MAP\u2019s peer-to-peer network into a self-verifying, self-governing fabric for secure inter-Space collaboration.</p>"},{"location":"core/trust-channel-design-spec/#appendix-a-unified-ingress-egress-summary","title":"Appendix A \u2014 Unified Ingress / Egress Summary","text":"<p>Unified Capsule Flow</p> <pre><code>Protocol Adapter  \u2192  CapsuleDancer::dance_capsule()\n                         \u2193\n                     TrustChannel\n               (unwrap \u2192 validate \u2192 dispatch)\n                         \u2193\n                        Dancer\n               (executes the Dance logic)\n                         \u2193\n                     TrustChannel\n               (wrap \u2192 encrypt \u2192 sign)\n                         \u2193\n                CapsuleDancer::dance_capsule()\n                         \u2193\n                 Protocol Adapter (reply)\n</code></pre> <p>Benefits - Single ingress/egress interface: All protocols converge on <code>CapsuleDancer::dance_capsule</code>. - Security consistency: Every request and response passes through the same validation gates. - Isolation of dependencies: Framework bindings remain in adapter crates only. - Extensibility: New protocols can be added without altering Trust Channel logic. - Narrative clarity: Code reads naturally\u2014initiators initiate, dancers dance, and capsules are danced through the Trust Channel.</p>"},{"location":"core/wasm-crate-guidelines-v1/","title":"Workspace Strategy: Native, WASM, and Test Build Targets in the Holons Codebase","text":""},{"location":"core/wasm-crate-guidelines-v1/#note-this-doc-is-outdated","title":"NOTE: This doc is outdated","text":"<p>This document describes our initial attempt at build isolation. Issue #337 implements an improved strategy. </p>"},{"location":"core/wasm-crate-guidelines-v1/#summary","title":"Summary","text":"<p>The <code>map-holons</code> monorepo is structured around three distinct Cargo packages, each targeting a different runtime environment:</p> <ol> <li>\ud83e\uddec <code>wasm/</code> \u2014 WebAssembly (WASM) builds for Holochain zome execution</li> <li>\ud83d\udda5 <code>native/</code> \u2014 Native builds (e.g., Tauri clients, local services)</li> <li>\ud83e\uddea <code>test/</code> \u2014 Test runners and fixtures (e.g., <code>sweetests</code> integration suite)</li> </ol> <p>These packages are not unified into a single Cargo workspace build. Instead, each is responsible for declaring and managing its own dependency graph, allowing for clean separation of feature sets and build targets.</p> <p>We retain a root-level <code>Cargo.toml</code> workspace file, but only for:</p> <ul> <li>\u2705 IDE and tool awareness across packages (e.g., RustRover, <code>cargo metadata</code>)</li> <li>\u2705 A single-source-of-truth for dependency versions</li> <li>\u26a0\ufe0f Not used to build or manage features across packages</li> <li>\u26a0\ufe0f Never used with <code>cargo build --workspace</code></li> </ul> <p>Dependency versions from the root file are pushed to each leaf package using a Python script.</p> <p>This architecture solves longstanding issues with Cargo\u2019s unified feature resolution, and ensures builds remain clean, reproducible, and platform-safe across WASM and native targets.</p>"},{"location":"core/wasm-crate-guidelines-v1/#why-not-use-a-unified-workspace","title":"Why Not Use a Unified Workspace?","text":""},{"location":"core/wasm-crate-guidelines-v1/#the-core-problem-tokio-and-wasm-dont-mix","title":"The Core Problem: Tokio and WASM Don't Mix","text":"<p>Many crates in the Holochain ecosystem \u2014 including <code>hdk</code> and its dependencies \u2014 rely on Tokio, which in turn pulls in platform-specific dependencies like Mio, which do not compile to WASM (<code>wasm32-unknown-unknown</code>). Zome code, which runs inside a Holochain WebAssembly guest, must be WASM-safe and must not link against Tokio or its transitive dependencies.</p> <p>This leads to a critical conflict: we want our native code (which can use Tokio) and our zome code (which must not) to coexist and share some logic.</p>"},{"location":"core/wasm-crate-guidelines-v1/#the-hidden-killer-cargos-unified-feature-resolution","title":"The Hidden Killer: Cargo\u2019s Unified Feature Resolution","text":"<p>Cargo\u2019s feature resolution is global per build, meaning:</p> <p>If any crate in the build graph enables a feature on a dependency, that feature is enabled for all crates using that dependency \u2014 even if it breaks the target platform.</p> <p>This is not conditional on platform, and not scoped to the consuming crate.</p>"},{"location":"core/wasm-crate-guidelines-v1/#example","title":"Example:","text":"<ul> <li><code>holons-client</code> (native) depends on <code>hdk</code> with default features (includes Tokio).</li> <li><code>holons-guest</code> (WASM) wants to depend on <code>hdk</code> with <code>default-features = false</code>.</li> <li>Because these share a workspace, Cargo resolves <code>hdk</code> with all features enabled.</li> <li>Even when building only <code>holons-guest</code> for WASM, Tokio and Mio are pulled in \u2014 and the build fails.</li> </ul> <p>\u26a0\ufe0f Conditional compilation like <code>#[cfg(target_arch = \"wasm32\")]</code> does not prevent Cargo from including incompatible dependencies.</p>"},{"location":"core/wasm-crate-guidelines-v1/#conclusion-workspace-builds-are-inherently-unsafe-for-mixed-targets","title":"Conclusion: Workspace Builds Are Inherently Unsafe for Mixed Targets","text":"<p>No amount of feature-flag gymnastics, conditional <code>cfg</code>, or dependency wrangling can make a single Cargo workspace build safely for both native and WASM \u2014 not when using Holochain.</p>"},{"location":"core/wasm-crate-guidelines-v1/#the-solution-per-target-packages-metadata-only-workspace","title":"The Solution: Per-Target Packages + Metadata-Only Workspace","text":"<p>Instead of relying on a single Cargo workspace with conditional features, we use three top-level packages:</p> <ol> <li><code>workspaces/wasm/</code></li> <li><code>workspaces/native/</code></li> <li><code>workspaces/test/</code></li> </ol> <p>Each of these defines:</p> <ul> <li>Its own <code>Cargo.toml</code></li> <li>Its own <code>[dependencies]</code> and <code>[features]</code></li> <li>A dummy <code>lib.rs</code> if necessary to satisfy Cargo</li> </ul> <p>These packages reference shared internal crates via path dependencies, ensuring they only compile with the appropriate features enabled for their target.</p> <p>At the top level, we include a <code>Cargo.toml</code> workspace file, but it is:</p> <ul> <li>Never used for building</li> <li>Used only by IDEs and tooling</li> <li>Treated as a central list of shared dependency versions</li> </ul> <p>A small Python script propagates version values from the root file into the leaf packages. This ensures consistency without invoking Cargo\u2019s problematic workspace resolution behavior.</p>"},{"location":"core/wasm-crate-guidelines-v1/#what-we-explicitly-avoid","title":"\ud83d\udeab What We Explicitly Avoid","text":"<ul> <li>\u274c <code>cargo build --workspace</code></li> <li>\u274c <code>[workspace.dependencies]</code> used for feature propagation</li> <li>\u274c Workspace-level test or build orchestration</li> <li>\u274c Conditional features in shared crates intended for WASM</li> </ul>"},{"location":"core/wasm-crate-guidelines-v1/#repo-layout","title":"\ud83d\udd01 Repo Layout","text":"<pre><code>map-holons/\n\u251c\u2500\u2500 Cargo.toml               # \ud83e\udde0 Metadata-only workspace (for IDEs/tools)\n\u251c\u2500\u2500 workspaces/\n\u2502   \u251c\u2500\u2500 wasm/                # \ud83e\uddec WASM-targeted build package\n\u2502   \u2502   \u2514\u2500\u2500 Cargo.toml\n\u2502   \u251c\u2500\u2500 native/              # \ud83d\udda5\ufe0f Native-targeted build package\n\u2502   \u2502   \u2514\u2500\u2500 Cargo.toml\n\u2502   \u2514\u2500\u2500 test/                # \ud83e\uddea Test-only build package\n\u2502       \u2514\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 crates/                  # Shared crates used across 2+ targets\n\u2502   \u251c\u2500\u2500 holons-core/\n\u2502   \u251c\u2500\u2500 holons-guest/\n\u2502   \u251c\u2500\u2500 holons-client/\n\u2502   \u251c\u2500\u2500 holon-dance-builders/\n\u2502   \u251c\u2500\u2500 shared_validation/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 zomes/                   # Zome crates (WASM only)\n\u2502   \u251c\u2500\u2500 coordinator/holons/\n\u2502   \u2514\u2500\u2500 integrity/holons_integrity/\n\u251c\u2500\u2500 tests/                   # \ud83e\uddea Integration test crates (native)\n\u2502   \u2514\u2500\u2500 sweetests/\n\u2514\u2500\u2500 .dev/                    # Dev tooling configs (e.g., IDE_SETUP.md)\n</code></pre>"},{"location":"core/wasm-crate-guidelines-v1/#benefits-of-this-model","title":"Benefits of This Model","text":"<ul> <li>\u2705 Each build target has complete control over features and dependencies</li> <li>\u2705 No target contamination via workspace resolution</li> <li>\u2705 WASM builds stay clean \u2014 no Tokio, no native IO</li> <li>\u2705 Native clients and test harnesses can use full async/threading</li> <li>\u2705 IDEs still understand the full repo structure</li> <li>\u2705 Centralized version declarations without workspace-induced poison</li> </ul>"},{"location":"core/wasm-crate-guidelines-v1/#tldr","title":"TL;DR","text":"<p>This is not a multi-workspace monorepo. This is a multi-package build graph with one metadata-only workspace at the top for tooling only.</p> <p>Never build the root. Always build from one of:</p> <ul> <li><code>workspaces/wasm/</code></li> <li><code>workspaces/native/</code></li> <li><code>workspaces/test/</code></li> </ul> <p>These are the only valid entry points.</p>"},{"location":"core/wasm-crate-guidelines-v1/#workspace-definition","title":"Workspace Definition","text":""},{"location":"core/wasm-crate-guidelines-v1/#workspace-comparison-table","title":"\ud83e\udde9 Workspace Comparison Table","text":"Category / Crate <code>wasm/</code> \ud83e\uddec <code>native/</code> \ud83d\udda5\ufe0f <code>test/</code> \ud83e\uddea Target Platform <code>wasm32-unknown-unknown</code> Native (e.g. x86_64 Linux) Native Purpose Build zomes &amp; WASM-safe libs Build native clients &amp; tools Run async integration tests Runtime Container Holochain Conductor (WASM guest) Tauri shell or CLI binary Holochain Sweetest framework Tokio Support \ud83d\udeab Not allowed \u2705 Full support \u2705 Full support Threading \ud83d\udeab Not supported \u2705 Allowed \u2705 Required by test framework Zome Code Allowed \u2705 Yes \u274c No \u274c No Use of <code>hdk</code> \u2705 With <code>default-features = false</code> \u2705 Full features \u2705 Full features Can use <code>tokio::spawn</code> \u274c No \u2705 Yes \u2705 Yes Can use <code>.block_on()</code> \u274c No \u2705 Yes \u2705 Yes Build Target Compile-only Build &amp; run Test-only Executor Runtime Conductor-driven async Tokio Tokio Shared Crate Rules Must be WASM-safe May use full native deps May use full native deps"},{"location":"core/wasm-crate-guidelines-v1/#async-wasm-safety-guidelines","title":"Async &amp; WASM Safety Guidelines","text":"<p>For full details on Rust's WASM limitations vs. Holochain's additional constraints, see: - \ud83d\udcce Appendix A: General WASM Constraints - \ud83d\udcce Appendix B: Holochain Guest WASM Constraints</p> <p>In short, in our Holochain Guest WASM code (which includes <code>holons_core</code>):</p> <ul> <li>\u2705 <code>async fn</code> is allowed in trait definitions (for cross-platform abstraction)</li> <li>\u274c <code>async fn</code> is not allowed in implementations (trait impls or free functions)</li> <li>\u274c <code>.await</code> is not allowed anywhere</li> <li>\u274c Spawning tasks (<code>tokio::spawn</code>, <code>spawn_local</code>) or blocking (<code>block_on</code>, <code>thread::sleep</code>) is never allowed</li> </ul>"},{"location":"core/wasm-crate-guidelines-v1/#crate-allocation","title":"\ud83e\uddf1 Crate Allocation","text":"Crate Name <code>wasm/</code> \ud83e\uddec <code>native/</code> \ud83d\udda5\ufe0f <code>test/</code> \ud83e\uddea <code>holons</code> (zome) \u2705 \u274c \u274c <code>holons_integrity</code> (zome) \u2705 \u274c \u274c <code>holons-core</code> \u2705 \u2705 \u2705 <code>holons-guest</code> \u2705 \u274c \u274c <code>holons-guest-integrity</code> \u2705 \u274c \u274c <code>holons-client</code> \u274c \u2705 \u274c <code>holons-trust-channel</code> \u2705 \u2705 \u274c <code>holon-dance-builders</code> \u2705 \u2705 \u2705 <code>type_system/*</code> \u2705 \u2705 \u2705 <code>shared_validation</code> \u2705 \u2705 \u2705 <code>holons-tests</code> (sweetests) \u274c \u274c \u2705 <p>\u2705 = Included in workspace \u274c = Excluded from workspace \u26a0\ufe0f Zome crates (<code>holons</code>, <code>holons_integrity</code>, etc.) are only compiled to <code>.wasm</code> and loaded dynamically at runtime</p>"},{"location":"core/wasm-crate-guidelines-v1/#rationale-for-each-crate","title":"Rationale for Each Crate","text":"Crate Workspace(s) Notes <code>holons-core</code> Both Must remain WASM-safe; no Tokio or MIO dependencies <code>holons-guest</code> <code>wasm/</code> Zome logic; uses <code>hdk</code> with <code>default-features = false</code> to avoid Tokio <code>holons-client</code> <code>native/</code> Native Rust client; allowed to use Tokio, MIO, full Holochain stack <code>holons-tests</code> <code>native/</code> Test runners; may depend on Tokio and native-only crates <code>shared</code>/utils/etc Varies Must be evaluated for WASM safety if used in both workspaces"},{"location":"core/wasm-crate-guidelines-v1/#key-developer-practices","title":"Key Developer Practices","text":"<ul> <li>\u2705 Never run <code>cargo build --workspace</code> from repo root \u2014 always specify the correct workspace.</li> <li>\u2705 Verify WASM compatibility with:   <pre><code>npm run build:wasm\n</code></pre>   or   <pre><code>cargo check --manifest-path wasm/Cargo.toml --target wasm32-unknown-unknown\n</code></pre></li> <li>\u2705 Use <code>default-features = false</code> for <code>hdk</code> in all zome code. </li> <li>\u2705 Use <code>.dev/IDE_SETUP.md</code> to configure multi-workspace awareness in RustRover or VSCode.</li> </ul>"},{"location":"core/wasm-crate-guidelines-v1/#test-workspace-design","title":"Test Workspace Design","text":"<p>The <code>test/</code> workspace includes:</p> <ul> <li>\u2705 <code>sweetests</code>: async test harness using <code>holochain[sweettest]</code></li> <li>\u2705 Full Tokio runtime</li> <li>\u274c No WASM crates or zome logic \u2014 to avoid <code>hdk</code> cross-contamination</li> </ul>"},{"location":"core/wasm-crate-guidelines-v1/#conclusion","title":"Conclusion","text":"<p>This three-workspace structure ensures:</p> <ul> <li>\u2705 Clean separation of concerns</li> <li>\u2705 Reliable build behavior across WASM and native</li> <li>\u2705 Test crates no longer break zome crates</li> <li>\u2705 Tokio stays out of WASM, but can thrive in native/test code</li> </ul> <p>\ud83e\udde0 Cargo's unified feature resolution means \"just be careful\" isn't enough. This structure is the only reliable path to cross-target compatibility in a monorepo setting.</p> <p>Use this architecture as the default model for all MAP/Holons development going forward.</p>"},{"location":"core/wasm-crate-guidelines-v1/#caveats-developer-notes","title":"Caveats &amp; Developer Notes","text":"<ul> <li>Never build both workspaces together (e.g., don\u2019t <code>cargo build --workspace</code> from the repo root).</li> <li>Be mindful of feature usage in shared crates \u2014 even indirect dependencies can cause contamination.</li> <li>Use <code>default-features = false</code> on <code>hdk</code> in <code>holons-guest</code> to avoid pulling in Tokio.</li> <li>If adding a dependency to <code>holons-core</code>, always verify that it compiles to <code>wasm32-unknown-unknown</code>.</li> <li>Consider using <code>#[cfg(...)]</code> blocks in shared code to gate platform-specific functionality.</li> </ul>"},{"location":"core/wasm-crate-guidelines-v1/#conclusion_1","title":"Conclusion","text":"<p>This dual-workspace setup is a necessary architectural change driven by Cargo\u2019s unified feature resolution model \u2014 a subtle, global behavior that invalidates many otherwise reasonable dependency strategies when working across targets like native and WASM.</p> <p>Now that this is in place, we can:</p> <ul> <li>Reliably isolate incompatible dependencies</li> <li>Share common code across platforms (safely)</li> <li>Build cleanly for both native and WASM targets</li> <li>Avoid the tail-chasing and brittle patching that have plagued the project for the last year</li> </ul> <p>This architecture should now be considered the canonical structure for all MAP/Holons projects targeting both native and WASM runtimes.</p>"},{"location":"core/wasm-crate-guidelines-v1/#addendum-testing-strategy-and-workspace-allocation","title":"Addendum: Testing Strategy and Workspace Allocation","text":""},{"location":"core/wasm-crate-guidelines-v1/#overview","title":"Overview","text":"<p>Our test infrastructure, including all integration tests, fixtures, and test executors, now lives exclusively in the native workspace. This decision aligns with both the technical requirements of the <code>sweettest</code> framework and the architectural split we\u2019ve established between native and WASM targets.</p>"},{"location":"core/wasm-crate-guidelines-v1/#why-tests-must-run-in-the-native-workspace","title":"Why Tests Must Run in the Native Workspace","text":"<p>The <code>sweettest</code> testing framework\u2014used extensively in our Holochain integration tests\u2014relies on a multithreaded, asynchronous runtime provided by Tokio. This includes:</p> <ul> <li>Spawning multiple Holochain conductors concurrently</li> <li>Running asynchronous test cases across threads</li> <li>Managing native filesystem and networking resources</li> </ul> <p>Because WASM targets cannot spawn threads (and <code>wasm32-unknown-unknown</code> in particular lacks thread and socket support), any attempt to compile or execute the test framework in a WASM workspace is inherently incompatible.</p> <p>\u26a0\ufe0f Even though the test crates may not directly import Tokio, transitive dependencies from the Holochain HDK and testing harness will always bring it in.</p>"},{"location":"core/wasm-crate-guidelines-v1/#symptoms-of-the-old-setup","title":"Symptoms of the Old Setup","text":"<p>In the previous single-workspace model, our test crates were included alongside both native and wasm-targeted code. This led to:</p> <ul> <li>Intermittent build failures \u2014 depending on Cargo\u2019s feature resolution order</li> <li>Unpredictable success \u2014 some tests appeared to compile when Tokio features weren\u2019t yet unified into the dependency graph</li> <li>Spurious \u201cit used to work\u201d moments \u2014 caused by Cargo reusing cached build artifacts that hadn\u2019t yet been poisoned by Tokio-enabled dependencies</li> </ul> <p>Now that we understand unified feature resolution, it\u2019s clear why these partial fixes failed: once any crate in the workspace enabled Tokio (via the Holochain HDK defaults), every crate in that build graph inherited it, including those targeting WASM.</p>"},{"location":"core/wasm-crate-guidelines-v1/#the-correct-allocation","title":"The Correct Allocation","text":"Category Workspace Notes <code>holons-tests</code> native Runs Sweettest integration suites and async conductors Test fixtures native Depend on Tokio and local Holochain services Shared test helpers native May reference HDK with default features <code>wasm</code> tests (future) wasm Only if explicitly built for WASM using <code>wasm-bindgen-test</code>"},{"location":"core/wasm-crate-guidelines-v1/#summary_1","title":"Summary","text":"<p>All integration and system-level testing belongs in the native workspace. The WASM workspace remains strictly for buildable, deployable zomes and wasm-safe shared libraries. This separation not only eliminates the recurring test-related build conflicts we\u2019ve faced but also formalizes a clean boundary between the runtime environments our code targets.</p> <p>In short:</p> <p>\ud83e\udde9 The native workspace is for execution and testing. \ud83e\uddec The wasm workspace is for compilation and deployment.</p> <p>This division finally resolves the historical instability in our test builds and provides a clear, maintainable structure for all future development.</p> <p>--</p>"},{"location":"core/wasm-crate-guidelines-v1/#addendum-pitfalls-false-hopes-and-ensuring-wasm-safe-and-native-optimized-builds","title":"Addendum: Pitfalls, False Hopes, and Ensuring WASM-Safe and Native-Optimized Builds","text":""},{"location":"core/wasm-crate-guidelines-v1/#beware-ai-tools-will-often-recommend-these-as-certain-fixes","title":"\u26a0\ufe0f Beware! AI Tools will often recommend these as \"certain\" fixes","text":"<p>Over the course of developing this architecture, we\u2019ve tried nearly every reasonable approach to isolate WASM-incompatible code (e.g., Tokio, Mio, native-only crates) while still enabling a unified build experience. AI tools often profess \"perfect understanding\" of your situation and suggest one or more of these will \"absolutely\" fix your problem.</p> <p>They're wrong!</p> <p>Unfortunately, many of these attempts fail silently or inconsistently due to how Cargo handles unified feature resolution.</p> <p>Below is a breakdown of common strategies we explored \u2014 and why each one ultimately fails under unified feature resolution.</p>"},{"location":"core/wasm-crate-guidelines-v1/#conditional-compilation-with-cfgtarget_arch-wasm32","title":"\u274c Conditional Compilation with <code>#[cfg(target_arch = \"wasm32\")]</code>","text":"<p>Why it\u2019s tempting: You can write platform-specific code paths like:</p> <pre><code>#[cfg(target_arch = \"wasm32\")]\nfn spawn() { /* wasm-specific impl */ }\n\n#[cfg(not(target_arch = \"wasm32\"))]\nfn spawn() { tokio::spawn(...) }\n</code></pre> <p>Why it fails: Even if the Tokio-specific code path is never compiled on the wasm target, Cargo still resolves and compiles all dependencies globally.</p> <p>If Tokio is anywhere in the feature graph, it (and all its dependencies like Mio) will be pulled in \u2014 even if they're not used in the wasm build.</p> <p>\ud83d\udca5 The mere presence of the dependency poisons the build for wasm.</p>"},{"location":"core/wasm-crate-guidelines-v1/#feature-flags-to-turn-off-native-code","title":"\u274c Feature Flags to \u201cTurn Off\u201d Native Code","text":"<p>Why it\u2019s tempting: You can isolate native dependencies like so:</p> <pre><code>[features]\ndefault = [\"native\"]\nnative = [\"tokio\"]\n\n[dependencies]\ntokio = { version = \"...\", optional = true }\n</code></pre> <p>Then write code like:</p> <pre><code>#[cfg(feature = \"native\")]\nuse tokio::spawn;\n</code></pre> <p>Why it fails: Even if <code>holons-guest</code> disables the <code>native</code> feature, if any other crate in the workspace enables it, Cargo will resolve <code>tokio</code> into the global dependency graph \u2014 for every crate that depends on that shared crate.</p> <p>This happens regardless of the target, which means you can\u2019t have one crate built with <code>tokio</code> and another without it \u2014 if they both depend on the same shared crate (<code>holons-core</code>, for example).</p>"},{"location":"core/wasm-crate-guidelines-v1/#crate-type-tweaks-switching-from-rlib-to-cdylib-etc","title":"\u274c Crate-Type Tweaks: Switching from <code>rlib</code> to <code>cdylib</code>, etc.","text":"<p>Why it\u2019s tempting: You might try to influence linking or compilation behavior by changing crate types:</p> <pre><code>[lib]\ncrate-type = [\"cdylib\"]\n</code></pre> <p>Why it fails: This only affects how the final artifact is linked \u2014 not which dependencies Cargo resolves or compiles. Cargo still builds the full dependency graph before target-specific logic kicks in.</p>"},{"location":"core/wasm-crate-guidelines-v1/#using-cfgtest-to-contain-test-only-dependencies","title":"\u274c Using <code>#[cfg(test)]</code> to Contain Test-Only Dependencies","text":"<p>Why it\u2019s tempting: You may hope test dependencies are only compiled in test mode.</p> <p>Why it fails: If tests live in a crate that\u2019s part of the workspace (like `holons_test``), then any test-only dependencies are still resolved in the workspace feature graph.</p> <p>Also, if <code>cargo test</code> runs from the top level and includes wasm-targeted crates, they still inherit the unified dependency graph \u2014 potentially pulling in Tokio or test harnesses that are native-only.</p>"},{"location":"core/wasm-crate-guidelines-v1/#appendum-holochain-guest-wasm-constraints","title":"\ud83d\udcce Appendum: Holochain Guest WASM Constraints","text":"<p>Holochain Conductor executes zome code inside a strict, synchronously invoked WebAssembly guest. This sandboxed runtime has no async executor, no threads, and no way to suspend/resume futures. Execution must be deterministic, synchronous, and single-threaded.</p> <p>This makes Holochain WASM guests significantly more constrained than general <code>wasm32-unknown-unknown</code> environments.</p>"},{"location":"core/wasm-crate-guidelines-v1/#key-restrictions","title":"\u274c Key Restrictions","text":"Pattern Allowed in Holochain Guest? Notes <code>async fn</code> in free functions \u274c No Guest has no executor; async fns do not run <code>.await</code> anywhere \u274c No Cannot suspend/resume; future never polled <code>async fn</code> in trait definitions \u2705 Yes Allowed for cross-platform abstraction only <code>async fn</code> in trait implementations \u274c No Guest cannot poll the returned future <code>tokio::spawn</code>, threads, <code>block_on</code> \u274c No No threads, no background execution <code>spawn_local</code>, JS-style async \u274c No Not supported in Conductor environment <code>#[hdk_extern]</code> functions \u2705 Yes Must be <code>fn</code>, return <code>ExternResult&lt;T&gt;</code> synchronously HDK functions like <code>create_entry()</code> \u2705 Yes Appear async, but are made sync via host plumbing"},{"location":"core/wasm-crate-guidelines-v1/#why-this-matters","title":"\ud83e\udde0 Why This Matters","text":"<p>Rust allows writing <code>async fn</code> and <code>.await</code>, even for WASM targets \u2014 but Holochain does not execute guest code like a browser.</p> <p>The Conductor:</p> <ul> <li>Calls exported zome functions synchronously</li> <li>Does not embed an executor inside the guest</li> <li>Cannot poll or await a guest future</li> <li>Requires all logic to complete in a single call stack</li> </ul> <p>Thus, any <code>.await</code> or <code>async fn</code> inside guest code is effectively a no-op \u2014 or worse, will cause logic to silently fail at runtime.</p>"},{"location":"core/wasm-crate-guidelines-v1/#correct-structure-for-zome-functions","title":"\u2705 Correct Structure for Zome Functions","text":"<p>You must write all guest code as plain synchronous functions.</p> <pre><code>#[hdk_extern]\nfn my_zome_fn(input: MyData) -&gt; ExternResult&lt;HeaderHash&gt; {\n    create_entry(input) // \u2705 this is sync (HDK abstracts over async)\n}\n</code></pre> <p>Do not do this:</p> <pre><code>#[hdk_extern]\nasync fn bad_zome_fn(input: MyData) -&gt; ExternResult&lt;HeaderHash&gt; {\n    // \u274c async zome handlers are not supported\n    let result = create_entry(input).await; // \u274c no .await allowed\n    result\n}\n</code></pre> <p>Even helper functions cannot be async:</p> <pre><code>async fn helper() -&gt; ExternResult&lt;()&gt; {\n    // \u274c this .await will never be executed\n    let _ = get(some_hash).await?;\n    Ok(())\n}\n</code></pre>"},{"location":"core/wasm-crate-guidelines-v1/#trait-based-abstractions-with-caution","title":"\u2705 Trait-Based Abstractions (With Caution)","text":"<p>If you're building shared interfaces for use both in native and guest contexts, it's fine to use <code>async fn</code> in trait definitions, as long as:</p> <ul> <li>\u2705 Guest implementations are synchronous</li> <li>\u2705 Guest code does not call trait methods directly as async</li> <li>\u274c Do not <code>.await</code> anything in the implementation</li> </ul> <pre><code>// \u2705 Trait definition is allowed\npub trait MyAction {\n    fn do_work(&amp;self) -&gt; ExternResult&lt;()&gt;;\n}\n\n// \u2705 Guest impl must be sync\nimpl MyAction for MyType {\n    fn do_work(&amp;self) -&gt; ExternResult&lt;()&gt; {\n        // no async calls\n        Ok(())\n    }\n}\n</code></pre> <p>You can use <code>async fn</code> in trait definitions to support native contexts \u2014 just be careful not to call <code>.await</code> in guest implementations.</p>"},{"location":"core/wasm-crate-guidelines-v1/#summary-table","title":"\u2705 Summary Table","text":"Use Case Allowed? Strategy <code>async fn</code> in shared trait definition \u2705 OK for abstraction <code>async fn</code> in trait impl in guest \u274c Must use sync impl <code>.await</code> in any guest code \u274c Will fail or silently not run HDK functions (e.g. <code>get</code>, <code>create_entry</code>) \u2705 Synchronous interface in guest Background work or task spawning \u274c Not possible in guest Running async logic \u2705 Only in host code (e.g., native client, test harness)"},{"location":"core/wasm-crate-guidelines-v1/#refactoring-tip","title":"\ud83d\udee0 Refactoring Tip","text":"<p>If you need to write shared logic that includes async operations:</p> <ul> <li>\u2705 Implement as <code>async fn</code> in shared crate</li> <li>\u2705 In native workspace: use <code>.await</code> normally</li> <li>\u274c In guest: wrap or stub it out, or move the logic into host orchestration</li> </ul> <p>Use <code>cfg</code> or trait-based boundaries if needed to isolate guest vs. host implementations.</p>"},{"location":"core/wasm-crate-guidelines-v1/#final-note","title":"Final Note","text":"<p>Holochain's guest model is not just a subset of WASM \u2014 it's a specialized, deterministic, sync-only execution environment orchestrated by the host. Many \"normal\" Rust async patterns will compile but break in guest context.</p> <p>Treat zome logic as purely synchronous, and handle all async orchestration outside the guest, in the Conductor or in native/test code.</p>"},{"location":"core/wasm-crate-guidelines-v2/","title":"\ud83e\uddec MAP / Holons WASM Build Guidelines","text":""},{"location":"core/wasm-crate-guidelines-v2/#overview","title":"Overview","text":"<p>This document describes the conventions and constraints for building WebAssembly (WASM) targets in the MAP Holons codebase \u2014 specifically the guest-side Holochain hApp.</p> <p>In this architecture: - The <code>happ/</code> workspace builds the Holochain zomes (guest-side logic). - The <code>host/</code> workspace builds the native Tauri runtime and clients. - The <code>crates/</code> directory holds shared code that must remain WASM-safe. - The <code>tests/</code> workspace runs native integration tests using Sweettest.</p> <p>The goal is a hybrid monorepo that maintains strict build isolation between WASM and native targets while keeping shared code ergonomic and consistent.</p>"},{"location":"core/wasm-crate-guidelines-v2/#wasm-workspace-purpose","title":"\ud83e\uddf1 WASM Workspace Purpose","text":"<p>The <code>happ/</code> workspace (formerly <code>wasm/</code>) produces the guest-side build artifacts: - <code>.wasm</code> binaries for each zome - <code>dna.yaml</code> and <code>happ.yaml</code> definitions (in <code>workdir/</code>) - Optional Holochain-specific metadata (integrity, coordinator zomes)</p> <p>These builds target the Holochain conductor runtime and must conform to Holochain Guest WASM constraints (see below).</p>"},{"location":"core/wasm-crate-guidelines-v2/#directory-structure","title":"\ud83d\udcc2 Directory Structure","text":"<pre><code>map-holons/\n\u251c\u2500\u2500 Cargo.toml                  # Unified workspace metadata (for tooling only)\n\u251c\u2500\u2500 crates/                     # Shared dual-target crates (WASM-safe)\n\u2502   \u251c\u2500\u2500 base_types/\n\u2502   \u251c\u2500\u2500 core_types/\n\u2502   \u251c\u2500\u2500 holons_core/\n\u2502   \u251c\u2500\u2500 holons_prelude/\n\u2502   \u251c\u2500\u2500 holon_dance_builders/\n\u2502   \u251c\u2500\u2500 shared_validation/\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 happ/                       # \ud83e\uddec Guest-side hApp (Holochain zomes)\n\u2502   \u251c\u2500\u2500 Cargo.toml              # WASM build target configuration\n\u2502   \u251c\u2500\u2500 crates/\n\u2502   \u2502   \u2514\u2500\u2500 holons_guest/       # Guest zome logic\n\u2502   \u251c\u2500\u2500 zomes/\n\u2502   \u2502   \u251c\u2500\u2500 coordinator/holons/\n\u2502   \u2502   \u2514\u2500\u2500 integrity/holons_integrity/\n\u2502   \u2514\u2500\u2500 workdir/\n\u2502       \u251c\u2500\u2500 dna.yaml\n\u2502       \u251c\u2500\u2500 happ.yaml\n\u2502       \u2514\u2500\u2500 web-happ.yaml\n\u2502\n\u251c\u2500\u2500 host/                       # \ud83d\udda5\ufe0f Host-side runtime (clients + adapters)\n\u2502   \u251c\u2500\u2500 tauri-app/              # Rust client orchestrator (Tauri command handlers)\n\u2502   \u251c\u2500\u2500 crates/                 # Client + adapter crates\n\u2502   \u2514\u2500\u2500 ui/                     # Frontend code (TypeScript)\n\u2502\n\u2514\u2500\u2500 tests/                      # \ud83e\uddea Integration &amp; sweetests suite\n\u2514\u2500\u2500 sweetests/\n</code></pre>"},{"location":"core/wasm-crate-guidelines-v2/#building-the-happ","title":"\u2699\ufe0f Building the hApp","text":"<p>From the repo root or <code>happ/</code> directory:</p> <p>cargo build --manifest-path happ/Cargo.toml --target wasm32-unknown-unknown --release</p> <p>This produces <code>.wasm</code> binaries for each zome inside: happ/target/wasm32-unknown-unknown/release/</p> <p>Use <code>hc dna pack</code> and <code>hc app pack</code> to package your zomes into DNA/hApp bundles defined in <code>workdir/</code>.</p>"},{"location":"core/wasm-crate-guidelines-v2/#shared-crate-rules-for-wasm-safety","title":"\u2705 Shared Crate Rules for WASM Safety","text":"<p>Crates under <code>crates/</code> may be used by both the host and happ workspaces, but they must satisfy WASM safety rules.</p> Rule Description Example No Tokio / async executors WASM cannot spawn or block threads \u274c <code>tokio::spawn()</code> No native I/O No filesystem, sockets, or native concurrency \u274c <code>std::fs::File</code>, <code>std::net</code> No <code>std::thread</code> No threading in guest WASM \u274c <code>thread::spawn()</code> No <code>block_on</code> Holochain guest has no async runtime \u274c <code>futures::executor::block_on()</code> Pure sync functions only Guest must be deterministic and single-threaded \u2705 normal <code>fn</code> <code>async fn</code> allowed only in traits Enables abstraction across host + guest \u2705 trait <code>async fn</code> definitions only <code>hdk</code> must be built with <code>default-features = false</code> Avoid Tokio contamination \u2705 <code>[dependencies] hdk = { version = \"0.5\", default-features = false }</code>"},{"location":"core/wasm-crate-guidelines-v2/#common-pitfalls","title":"\ud83d\udeab Common Pitfalls","text":"Pattern Why It Fails <code>tokio::spawn</code> or <code>spawn_local</code> WASM guest has no scheduler or threads <code>.await</code> in guest code No async executor; the future never polls Using HDK with default features Pulls Tokio and Mio (breaks WASM build) Writing to filesystem No file access inside guest sandbox Spawning background tasks Non-deterministic; forbidden by Holochain runtime"},{"location":"core/wasm-crate-guidelines-v2/#integration-with-host-workspace","title":"\ud83e\udde9 Integration with Host Workspace","text":"<p>Although the <code>happ</code> and <code>host</code> workspaces are isolated for build safety, they interoperate at runtime.</p>"},{"location":"core/wasm-crate-guidelines-v2/#flow","title":"Flow:","text":"<ol> <li>The <code>host</code> workspace builds and runs the Tauri application.</li> <li>It launches a Holochain Conductor that loads <code>.dna</code> and <code>.wasm</code> artifacts from <code>happ/workdir/</code>.</li> <li>Guest zomes (compiled to <code>.wasm</code>) execute within the conductor sandbox.</li> <li>Communication occurs via the Conductor API, using Rust client adapters and <code>TrustChannel</code> orchestration.</li> </ol>"},{"location":"core/wasm-crate-guidelines-v2/#important","title":"Important:","text":"<ul> <li>The <code>host</code> never compiles the guest zomes.</li> <li>The <code>happ</code> never links to native crates or Tokio.</li> <li>They interact only via the conductor and well-defined serialization boundaries.</li> </ul>"},{"location":"core/wasm-crate-guidelines-v2/#build-isolation-summary","title":"\ud83d\udd12 Build Isolation Summary","text":"Target Workspace Features Build Command Guest (WASM) <code>happ/</code> <code>default-features = false</code> <code>cargo build --target wasm32-unknown-unknown</code> Host (Native) <code>host/</code> full features allowed <code>cargo build --manifest-path host/Cargo.toml</code> Tests <code>tests/</code> full features allowed <code>cargo test --manifest-path tests/Cargo.toml</code> <p>The root <code>Cargo.toml</code> is metadata-only and never built directly.</p>"},{"location":"core/wasm-crate-guidelines-v2/#quick-reference-guest-vs-host-rules","title":"\ud83e\udde0 Quick Reference \u2014 Guest vs Host Rules","text":"Capability Guest (WASM) Host (Native) Async I/O \u274c No \u2705 Yes Threads \u274c No \u2705 Yes Filesystem Access \u274c No \u2705 Yes Network Access \u274c No \u2705 Yes <code>tokio::spawn()</code> \u274c No \u2705 Yes <code>block_on()</code> \u274c No \u2705 Yes <code>async fn</code> (traits) \u2705 Allowed \u2705 Allowed <code>async fn</code> (impls) \u274c No \u2705 Yes HDK Use \u2705 With <code>default-features = false</code> \u2705 With full features"},{"location":"core/wasm-crate-guidelines-v2/#developer-workflow","title":"\ud83e\udde9 Developer Workflow","text":"<ol> <li> <p>Build and pack the guest WASM zomes:</p> <ul> <li><code>npm run build:happ</code> or <code>cargo build --manifest-path happ/Cargo.toml --target wasm32-unknown-unknown</code></li> <li><code>hc app pack happ/workdir</code></li> </ul> </li> <li> <p>Build and run the host:</p> <ul> <li><code>npm run tauri:dev</code> or <code>cargo tauri dev --manifest-path host/tauri-app/Cargo.toml</code></li> </ul> </li> <li> <p>The host automatically loads the <code>happ/workdir/happ.yaml</code> bundle and initializes the conductor.</p> </li> <li> <p>Integration tests (under <code>tests/</code>) run against this conductor instance using Sweettest.</p> </li> </ol>"},{"location":"core/wasm-crate-guidelines-v2/#key-design-principle","title":"\ud83e\udde9 Key Design Principle","text":"<p>The <code>happ/</code> workspace is strictly deterministic, synchronous, and platform-agnostic. The <code>host/</code> workspace provides all asynchronous orchestration, networking, and persistence.</p>"},{"location":"core/wasm-crate-guidelines-v2/#summary","title":"\u2705 Summary","text":"<ul> <li>The <code>happ/</code> workspace compiles the Holochain guest WASM (zomes)</li> <li>The <code>host/</code> workspace provides runtime orchestration and UI integration</li> <li>Shared crates must be WASM-safe</li> <li>No async runtime or Tokio in guest code</li> <li>The root workspace file is metadata-only</li> <li>Each workspace maintains its own build isolation and Cargo.lock</li> </ul> <p>This structure guarantees: - Safe, reproducible builds across WASM and native targets - Deterministic guest logic - Flexible, async-capable host orchestration - Seamless integration within a single monorepo</p> <p>\ud83e\udde0 Remember:</p> <p>The hApp executes inside the Holochain conductor sandbox, not in a browser or async runtime. Every zome function must complete synchronously and deterministically.</p>"},{"location":"core/wasm-crate-guidelines-v2/#appendix-a-why-this-layout-works","title":"Appendix A \u2014 Why This Layout Works","text":"<p>Cargo resolves dependency features globally. If a WASM-safe crate and a Tokio-enabled crate live in the same build graph, Cargo unifies their features \u2014 breaking the WASM build. By separating <code>happ/</code> (guest) and <code>host/</code> (native) physically, we prevent that contamination while keeping shared crates reusable.</p>"},{"location":"core/wasm-crate-guidelines-v2/#appendix-b-holochain-guest-execution-rules","title":"Appendix B \u2014 Holochain Guest Execution Rules","text":"<p>Holochain executes guest WASM synchronously:</p> Pattern Allowed? Notes <code>async fn</code> in free functions \u274c Guest runtime has no executor <code>.await</code> usage \u274c Futures never polled <code>async fn</code> in traits \u2705 For abstraction only HDK externs (<code>#[hdk_extern]</code>) \u2705 Must be synchronous Background tasks (<code>tokio::spawn</code>) \u274c Not supported Multi-threading \u274c Deterministic, single-threaded only <p>The Conductor handles async orchestration. The guest is pure logic.</p>"},{"location":"core/wasm-crate-guidelines-v2/#conclusion","title":"Conclusion","text":"<p>This host\u2013hApp hybrid workspace structure is the canonical model for all Holons and MAP projects. It combines: - Clean separation between host and guest build targets - Centralized dependency management - Reliable cross-platform builds - IDE-friendly unified workspace metadata</p> <p>\ud83e\uddec hApp = guest logic (inside conductor) \ud83e\uddd1\u200d\ud83d\udcbb Host = conductor + client orchestration layer</p> <p>Together, they form a robust architecture that\u2019s WASM-safe, native-optimized, and test-ready.</p>"},{"location":"core/wasm-crate-guidelines-v2/#appendix-c-workdir-and-bundle-layout","title":"Appendix C \u2014 Workdir and Bundle Layout","text":"<p>The <code>workdir/</code> directory acts as the bridge between Rust builds and Holochain runtime artifacts, serving as the staging area for packaging, configuration, and testing.</p>"},{"location":"core/wasm-crate-guidelines-v2/#default-layout-holons-single-happ-repo","title":"\ud83d\udcc1 Default Layout (Holons \u2014 Single hApp Repo)","text":"<p>In the Holons codebase, the <code>workdir/</code> resides at the repository root, not inside <code>happ/</code>. This makes it globally accessible to host, guest, and test environments alike.</p> <pre><code>map-holons/\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 crates/\n\u251c\u2500\u2500 happ/\n\u2502   \u251c\u2500\u2500 zomes/\n\u2502   \u251c\u2500\u2500 crates/\n\u2502   \u2514\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 host/\n\u2502   \u251c\u2500\u2500 crates/\n\u2502   \u2514\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 tests/\n\u2502   \u2514\u2500\u2500 sweetests/\n\u2502\n\u251c\u2500\u2500 workdir/                     # \ud83e\udde9 Holochain hApp packaging + runtime state\n\u2502   \u251c\u2500\u2500 dna.yaml                 # DNA manifest (declares zomes and wasm paths)\n\u2502   \u251c\u2500\u2500 happ.yaml                # hApp manifest (declares DNAs and roles)\n\u2502   \u251c\u2500\u2500 bundles/                 # Built .dna and .happ bundles (hc pack outputs)\n\u2502   \u2502   \u251c\u2500\u2500 holons.dna\n\u2502   \u2502   \u2514\u2500\u2500 holons.happ\n\u2502   \u251c\u2500\u2500 conductor-config.yaml    # (Optional) used for local conductor/sweettest\n\u2502   \u251c\u2500\u2500 storage/                 # (Optional) persisted Holochain DHT data\n\u2502   \u2514\u2500\u2500 temp/                    # (Optional) transient conductor state or logs\n</code></pre>"},{"location":"core/wasm-crate-guidelines-v2/#purpose-and-responsibilities","title":"\ud83e\uddf1 Purpose and Responsibilities","text":"File / Folder Purpose <code>dna.yaml</code> Defines which zomes (and which <code>.wasm</code> builds) are included in the DNA. <code>happ.yaml</code> Defines which DNAs make up the hApp and their roles. <code>bundles/</code> Output directory for packaged <code>.dna</code> and <code>.happ</code> bundles. <code>conductor-config.yaml</code> (reserved) Reserved for future use. Will eventually define local conductor runtime configuration (environment path, networking, and installed apps) once the merged Conductora runtime is stabilized. Not currently required or used. <code>storage/</code> Persistent DHT data for long-running test conductors or local development. <code>temp/</code> Temporary working directory for transient conductors and ephemeral runs. <p>\u26a0\ufe0f Note: The <code>conductor-config.yaml</code> entry is intentionally not yet part of the active Holons toolchain. All conductor initialization is currently handled programmatically through the runtime (e.g., <code>TauriConductorConfig</code>) or the test harness. This placeholder simply reserves the filename and location so that when configuration-file-based launches are reintroduced later, no structural changes to <code>workdir/</code> will be required.</p>"},{"location":"core/wasm-crate-guidelines-v2/#build-and-packaging-flow","title":"\ud83e\udde9 Build and Packaging Flow","text":"<ol> <li> <p>Build the zomes (hApp WASM): <pre><code>cargo build --manifest-path happ/Cargo.toml --target wasm32-unknown-unknown --release\n</code></pre></p> </li> <li> <p>Package DNA: <pre><code>hc dna pack workdir/\n</code></pre></p> </li> <li> <p>Package hApp: <pre><code>hc app pack workdir/\n</code></pre></p> </li> <li> <p>Result: <pre><code>workdir/bundles/holons.dna\nworkdir/bundles/holons.happ\n</code></pre></p> </li> </ol>"},{"location":"core/wasm-crate-guidelines-v2/#usage-in-tests-and-runtime","title":"\u2699\ufe0f Usage in Tests and Runtime","text":"<p>Both the <code>host/</code> conductor and the <code>tests/sweetests/</code> harness load hApps directly from the <code>workdir/</code>.</p> <p>Example \u2014 in Sweetest or conductor launch code: ```rust let happ_path = PathBuf::from(\"workdir/bundles/holons.happ\"); let conductor = Conductor::builder()  .with_happ(happ_path)  .spawn()  .await?;</p>"},{"location":"mapp-dev/extensibility-model/","title":"MAP Extensibility Model","text":""},{"location":"mapp-dev/extensibility-model/#introduction","title":"Introduction","text":"<p>In the Memetic Activation Platform (MAP), we embrace a fundamentally different approach to extensibility than traditional software systems. Instead of a rigid set of predefined types and relationships, the MAP offers a flexible and open-ended ontology where all entities are represented as holons. This document explains how this extensibility model works and why it matters for developers adopting the MAP.</p>"},{"location":"mapp-dev/extensibility-model/#the-problem-with-fixed-ontologies","title":"The Problem with Fixed Ontologies","text":"<p>Most traditional software systems operate with a fixed schema. Each release defines a set of types, relationships, and behaviors that are controlled by the application provider.</p> <p></p> <p>Over time, as these providers add more functionality, they introduce more and more predefined types\u2014sometimes ballooning into thousands of tightly coupled objects. While this might provide a broad feature set, it also leads to vendor lock-in due to high-switching costs. And no matter how large it gets, you are still limited by the app provider's imagination and release cadence. Got a need to manage different types of data? Novel behavior? A superior visual experience? Good luck! File your enhancement request and then... wait. </p>"},{"location":"mapp-dev/extensibility-model/#emergent-complexity-and-the-need-for-open-ended-ontology","title":"Emergent Complexity and the Need for Open-Ended Ontology","text":"<p>In contrast, the MAP is built on the idea that emergent complexity demands an open-ended ontology. </p> <p></p> <p>By treating everything as a holon\u2014a self-describing, active entity with properties, relationships, and behaviors (dances)\u2014we allow developers to extend the platform in ways that we, as the platform creators, could never fully predict.</p> <p>This means that instead of waiting for a central authority to add a new type, developers can create their own types and relationships as needed. They can share these extensions in a commons, fostering a rich ecosystem of visualizers, application behaviors, and more.</p>"},{"location":"mapp-dev/extensibility-model/#how-extensibility-works","title":"How Extensibility Works","text":"<p>The design goal is to: - Provide strong guarantees about structural compatibility. - Enable application-level innovation without duplicating or rewriting core definitions. - Preserve semantic integrity by constraining what \u201cextension\u201d means.</p> <p>The MAP\u2019s extensibility model is guided by clear, predictable rules that keep extensions simple, DRY (Don\u2019t Repeat Yourself), and interoperable:</p> <ol> <li> <p>Single Inheritance Only    Each new type can extend exactly one other type. There is no multiple inheritance. You inherit all properties, relationships, and dances from that single parent type.</p> </li> <li> <p>Additive, Not Subtractive    When you extend a type, you adopt all of its existing behaviors wholesale. You can add new behaviors, but you do not remove or override inherited ones. This keeps inheritance additive and predictable.</p> </li> <li> <p>Flattened Type Descriptors    The system flattens all inherited properties, relationships, and dances into a single type descriptor for the child type. You only specify what\u2019s unique about your new type; all common behavior is defined once and inherited automatically.</p> </li> <li> <p>Alternative for Variations    If you need a different set of behaviors, you start from a different parent type or reintroduce only the behaviors you want via composition. You avoid erasing or modifying inherited features directly.</p> </li> <li> <p>Extending Across Type Kinds    Extensibility is not limited to holon types. You can extend value types, property types, relationship types, and dance types. This allows you to evolve the ontology across all type kinds.</p> </li> <li> <p>Community and Self-Defined Extensions    You can extend not just core types, but also types defined by yourself or other MAP adopters. This makes the ecosystem a living, collaborative space where new types can evolve organically.</p> </li> <li>Leaf-Only Instantiation    Only the final (leaf) type in an Extends chain can be instantiated. All properties, relationships, and dances from parent types are flattened into the leaf type\u2019s descriptor, ensuring there is a single, complete definition for every instance. Intermediate types serve only as templates for shared structure and behavior, never as instantiable entities.</li> <li>Single Implementation per Dance    Every dance type defined anywhere in an Extends chain can have only one implementation within that chain. Implementations are bound to the type level that defines the dance type and may reference only properties and relationships defined at that level or above. You cannot \"override\" the implementation of a dance defined higher in the extends chain. Thus, if you do not want a dance (or property or relationship) of a type, do not extend that type.</li> </ol>"},{"location":"mapp-dev/extensibility-model/#core-types-as-your-starting-point","title":"Core Types as Your Starting Point","text":"<p>Although the MAP represents everything as a holon, you don\u2019t have to start from a blank slate. The platform ships with a rich foundation of Core Types \u2014 fully-defined, concrete holon types like <code>Meme</code>, <code>Agent</code>, <code>Service</code>, <code>VitalCapital</code>, <code>MemeGroup</code>, and <code>Memeplex</code>. These types already encapsulate key MAP semantics and relationships, giving you a solid base to extend from.</p> <p>When you extend a core type: - You inherit its properties, relationships, and dances. - You avoid re-defining the foundational semantics that MAP tools and visualizers expect. - You stay aligned with the larger ecosystem, improving interoperability with other mapps.</p> <p>Use of these core types is entirely optional. If your domain requires something fundamentally different, you can extend directly from <code>Holon</code> (the most general concrete type) or even create your own abstract type to serve as a base.</p> <p>A common mental model looks like this:</p> <pre><code>       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502       Meta Types         \u2502  (abstract obligations: structure of types)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502    Abstract Types        \u2502  (conceptual categories, no instances)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502     Core Types Layer     \u2502  (instantiable MAP-provided bases: Meme, Agent...)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502  Extension Types Layer   \u2502  (your domain-specific types)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>A powerful feature: You can extend not only core types, but also types defined by other MAP developers. This means the ontology can evolve in ever richer, more specialized ways \u2014 collaboratively and incrementally \u2014 without requiring changes to the core. The result is a living ecosystem of interoperable types, each building on the work of others.</p> <p>Pro tip for mapp developers: If you find yourself removing or avoiding core behaviors from a parent type, it may be better to pick a different starting point \u2014 either another core type, a type from another developer, or <code>Holon</code> itself \u2014 so you keep your inheritance clean and predictable.</p>"},{"location":"mapp-dev/extensibility-model/#an-example","title":"An Example","text":"<p>Let's look at an example to see how these rules work in action.</p>"},{"location":"mapp-dev/extensibility-model/#1-leaf-only-instances","title":"1. Leaf-Only Instances","text":"<p>If you have <code>A</code> Extends <code>B</code> Extends <code>Meme</code>, only A can have instances. - Properties and relationships from all levels are flattened into <code>A</code>\u2019s descriptor. - Your instance is \u201can A\u201d with one set of properties and relationships to populate. - Intermediate types (<code>B</code>, <code>Meme</code>) serve as templates for shared structure and behavior, but are never instantiated directly.</p>"},{"location":"mapp-dev/extensibility-model/#2-separate-the-contract-from-the-implementation","title":"2. Separate the Contract from the Implementation","text":"<p>Every dance has two aspects: - DanceDescriptor (contract): Name, arguments, result type, semantics, and required/optional status. - DanceImplementation (code): The executable logic, bound to the type that defines it.</p> <p>MAP preserves the contract vs. implementation distinction without introducing a separate \u201cinterface\u201d construct. Obligations are explicit in the type descriptor; the code is provided at the defining type.</p>"},{"location":"mapp-dev/extensibility-model/#3-where-implementations-may-live","title":"3. Where Implementations May Live","text":"<p>A DanceImplementation can be declared in: - The MAP Core Type you extended (e.g., <code>Meme</code>) - An intermediate type in the chain (<code>B</code>) - Your own leaf type (<code>A</code>)</p> <p>Instances always dispatch to the single implementation allowed for that descriptor in the chain.</p>"},{"location":"mapp-dev/extensibility-model/#4-rules-that-avoid-overrides","title":"4. Rules that Avoid Overrides","text":"<p>To keep things predictable, DRY, and override-free:</p> <ol> <li>Only the leaf instantiates \u2014 No instances of intermediate types.</li> <li>Unique dance identity across the chain \u2014 No two types in the chain may declare the same DanceDescriptor ID.</li> <li>Single implementation per dance per chain \u2014 At most one implementation for a given descriptor in the chain.</li> <li>If required and none found \u2192 validation fails.</li> <li>If optional and none found \u2192 allowed.</li> <li>If more than one found \u2192 validation fails.</li> <li>Bound to defining type \u2014 Implementations may only reference properties and relationships defined at their own level or above.</li> <li>Different behavior without overrides \u2014 If you need different logic, define a new (possibly versioned) DanceDescriptor or choose a different parent type.</li> </ol>"},{"location":"mapp-dev/extensibility-model/#5-effective-set-computation-loadvalidation-time","title":"5. Effective Set Computation (Load/Validation Time)","text":"<p>At load or validation time, MAP precomputes the EffectiveDanceSet for your leaf type:</p> <pre><code>EffectiveDanceSet(A):\n  let chain = [Meme, B, A]  // ancestor \u2192 leaf\n  let seen = {}\n  for each type T in chain:\n    for each DanceImplementation impl in T:\n      let id = impl.descriptor_id\n      if id in seen: error \"multiple implementations in chain\"\n      seen[id] = impl\n\n  // Ensure all required descriptors in chain have an implementation\n  for each required descriptor d in chain:\n      if d.id not in seen: error \"required dance missing\"\n\n  return seen\n</code></pre> <p>This means your mapp instances dispatch directly to the right implementation with no runtime search and no ambiguity.</p>"},{"location":"mapp-dev/extensibility-model/#benefits-for-developers","title":"Benefits for Developers","text":"<ul> <li>Clarity: No tangled multiple-inheritance chains or runtime delegation puzzles.</li> <li>Predictability: The full definition of a type is always visible in its flattened descriptor.</li> <li>Reusability: Shared behavior is defined once and reliably inherited.</li> <li>Interoperability: Extensions preserve all inherited relationships and obligations, ensuring they work seamlessly with existing MAP tooling.</li> </ul>"},{"location":"mapp-dev/extensibility-model/#comparison-to-traditional-inheritance-models","title":"Comparison to Traditional Inheritance Models","text":"<p>The MAP\u2019s model differs from common inheritance patterns found in mainstream programming languages:</p> <ul> <li>Classical OOP Inheritance (Java, C++)   These languages often allow single or multiple inheritance. Multiple inheritance can lead to the diamond problem, where it\u2019s unclear which inherited method should be used. The MAP avoids this entirely by allowing only single inheritance and flattening all inherited elements into one unified type descriptor.</li> <li> <p>Interfaces and Mixins (Java Interfaces, Ruby Modules)</p> </li> <li> <p>In languages like Java, interfaces separate the contract (what behaviors a type must provide) from the implementation (how those behaviors are carried out), to avoid the pitfalls of tying the two together in rigid inheritance chains. Mixins add reusable behavior across otherwise unrelated types.   In the MAP, this separation is preserved but modeled explicitly through the type system: a holon\u2019s type descriptor declares its obligations (its contract) via inherited properties, relationships, and required dances, while the actual implementation of those dances can be provided or overridden in the specific type or its runtime context. This makes contracts explicit without introducing a separate interface construct, and still allows behaviors to be composed or reused across types.</p> </li> <li> <p>Delegation and Composition (Go Interfaces, \u201ccomposition over inheritance\u201d)   Composition-based designs assemble objects from multiple components, often requiring explicit delegation. The MAP achieves similar modularity by letting you start from the most relevant parent type and additively extend it, while maintaining a single, flattened descriptor. You get the clarity of composition without the overhead of managing multiple internal objects.</p> </li> </ul> <p>By combining inheritance\u2019s clarity with composition\u2019s modularity, the MAP ensures that extensions are both powerful and easy to reason about.</p>"},{"location":"mapp-dev/extensibility-model/#conclusion","title":"Conclusion","text":"<p>By combining a stable foundation of core concrete types with a disciplined, flattened, single-inheritance model, the MAP gives developers a robust but simple way to extend the platform. You inherit everything you need from your parent type, add only what\u2019s unique, and know that your type will integrate cleanly into the larger ecosystem. This balance of openness and structure is what allows the MAP to evolve in step with the diverse needs of its community.  </p>"},{"location":"mapp-dev/holon-data-loader-guide/","title":"MAP Holon Data Loader: JSON Import Format \u2013 Comprehensive Authoring Guide","text":"<p>This guide provides developers with a complete and authoritative reference for constructing valid JSON import files for the MAP Holon Data Loader. It reflects current conventions for authoring schema definitions, base/core types, and domain-specific instances in a self-describing, holonic data model.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#overview","title":"\u2728 Overview","text":"<p>The MAP Holon Data Loader allows for the declarative import of holons and their relationships into a (single) MAP Holon Space. The import format is intentionally minimal, self-describing, and designed for bootstrapping both type descriptors and real data without relying on runtime logic.</p> <p>All holons \u2014 including types, schemas, and instances \u2014 are defined uniformly. Their type, structure, and descriptors are all expressible using the same format.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#foundational-concepts","title":"\ud83d\udcda Foundational Concepts","text":"<p>MAP import files are composed of holons \u2014 self-contained objects representing types, data, or components. This section introduces key concepts that underpin the entire format.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#holons-and-types","title":"Holons and Types","text":"<p>Every holon has a <code>type</code> that points to a type descriptor (e.g., <code>BookType</code>, <code>PropertyType</code>). The type is used to determine:</p> <ul> <li>What properties are allowed</li> <li>What relationships can be included</li> <li>How validation is applied</li> </ul> <p>The <code>type</code> field acts as both a signal and a shortcut. It removes the need to include an explicit <code>DescribedBy</code> relationship.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#keyed-vs-keyless-holon-types","title":"Keyed vs. Keyless Holon Types","text":"<p>Every holon in MAP is an instance of a HolonType, and that HolonType determines whether instances are keyed or keyless.</p> <ul> <li>Keyed Holon Types require that each instance includes a stable <code>key</code>, derived from one or more of its properties using a <code>UsesKeyRule</code>. Holons of these types:</li> <li>Must include a <code>key</code> field in the JSON import</li> <li>May be referenced elsewhere using <code>$ref</code></li> <li> <p>May be the target of declared relationships</p> </li> <li> <p>Keyless Holon Types do not permit their instances to include a key. Holons of these types:</p> </li> <li>Must be embedded inline wherever they are used</li> <li>May not be referenced via <code>$ref</code> (not even by <code>id:</code>)</li> <li>May not be the target of any declared relationship</li> <li>Must act as the source of at least one relationship to a keyed holon (to remain anchored in the graph)</li> </ul> <p>This distinction is structural and enforced during staging. The loader will reject any violation of these rules \u2014 including attempts to reference or directly target a keyless holon.</p> <p>\ud83d\udd0d Whether a holon is keyed is not an authoring choice \u2014 it is defined by the HolonType it instantiates.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key-derivation-rules","title":"\ud83d\udd22 Key Derivation Rules","text":"<p>Every keyed holon must declare a <code>UsesKeyRule</code>, pointing to a <code>FormatKeyRule</code> with:</p> <ul> <li><code>format</code>: A string template (e.g., <code>\"$0\"</code>, <code>\"($0)-[$1]-&gt;($2)\"</code>)</li> <li><code>property_names</code>: List of property or inferred names used to fill the format</li> </ul> <p>The authored <code>key</code> must match the result of evaluating the format rule.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#foundational-rule-for-all-types","title":"\ud83e\uddf1 Foundational Rule for All Types","text":"<p>Every MAP type descriptor (e.g., <code>BookType</code>, <code>PropertyType</code>, <code>MetaHolonType</code>) must:</p> <ul> <li>\u2705 Be DescribedBy the <code>MetaHolonType</code> \u2014 this defines the meta-structure of the type descriptor itself</li> <li>\u2705 Extend the foundational <code>MetaTypeDescriptor</code> \u2014 inheriting shared fields like <code>type_name</code>, <code>description</code>, etc.</li> </ul> <p>This rule applies uniformly to all types in MAP, including both core types (like <code>PropertyType</code>, <code>SchemaType</code>) and meta-types (like <code>MetaHolonType</code>, <code>MetaSchemaType</code>). It ensures:</p> <ul> <li>\ud83d\udd04 Reflexivity \u2014 Types are holons too</li> <li>\ud83d\udd0d Introspection \u2014 Schema tools can explore and validate all descriptors using a shared structure</li> <li>\ud83e\uddf1 Composability \u2014 Specialized descriptors build on common foundations</li> </ul> <p>\ud83e\udde0 Even <code>MetaHolonType</code> itself is DescribedBy the <code>MetaHolonType</code> and Extends <code>MetaTypeDescriptor</code>.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#holontype-requirements","title":"\ud83d\udd10 HolonType Requirements","text":"<p>In addition to the foundational rule above, all HolonTypes must:</p> <ul> <li>\u2705 Declare a <code>UsesKeyRule</code> \u2014 either a formatting rule (e.g., <code>TypeName.KeyRule</code>) or <code>None.KeyRule</code></li> </ul> <p>This ensures that the distinction between keyed and keyless types is structurally enforced and discoverable via introspection.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#best-practices","title":"\ud83d\udcda Best Practices","text":"<ul> <li>\u2705 Include <code>UsesKeyRule</code> for every HolonType descriptor</li> <li>\u2705 Use consistent naming across <code>type_name</code>, <code>display_name</code>, and <code>key</code></li> <li>\u2705 Use inline embedding for keyless holons or unique instances</li> <li>\u2705 Use <code>$ref</code> for reusable, keyed holons</li> <li>\u274c Do not author <code>DescribedBy</code> or <code>OwnedBy</code> \u2014 these are handled automatically</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#referencing-other-holons-ref-and-inline-embedding","title":"Referencing Other Holons: <code>$ref</code> and Inline Embedding","text":"<p>In MAP\u2019s JSON import format, holons frequently refer to other holons \u2014 whether to define relationships, specify constraints, compose schemas, or extend descriptors. These references can be expressed in one of two interchangeable forms:</p> <ol> <li><code>$ref</code> strings \u2014 Concise pointers to other keyed holons</li> <li>Inline embedded holons \u2014 Full holon objects defined in place</li> </ol> <p>Both forms are valid anywhere a holon is expected, and the Holon Data Loader treats them equivalently when staging, validating, and committing.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#motivation-reference-scenarios-map-must-support","title":"\ud83e\udde0 Motivation: Reference Scenarios MAP Must Support","text":"Scenario Example Staged vs. Saved Refer to holons defined in the same file or already saved in the space Local vs. External Link to holons from another HolonSpace (e.g., shared schemas) Keyed vs. Keyless <code>$ref</code> keyed holons; embed keyless ones Reusable vs. One-Off Reuse types and entities via <code>$ref</code>; define constraints inline"},{"location":"mapp-dev/holon-data-loader-guide/#ref-semantics","title":"\ud83e\udded <code>$ref</code> Semantics","text":"<p><code>$ref</code> is a string-based shorthand for referencing previously defined, saved, or external keyed holons. It can be used anywhere a holon is expected and the type can be inferred from context.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#supported-ref-formats","title":"Supported <code>$ref</code> Formats","text":"<code>$ref</code> Format Meaning Example <code>\"#key\"</code> Reference to a keyed holon by key only <code>\"#future-primal\"</code> <code>\"id:&lt;HolonId&gt;\"</code> Reference by ActionHash (HolonId) <code>\"id:uhCAkYmv...\"</code> <code>\"@Proxy:key\"</code> External holon via proxy name + key <code>\"@Library:Books\"</code> <code>\"ext:&lt;Proxy&gt;:&lt;Id&gt;\"</code> External holon via proxy ID + local ID <code>\"ext:uhProxy:uhId\"</code> <p>\ud83d\udd0d The holon\u2019s type is inferred from context. If the key does not match a holon of the expected type, validation will fail.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#inline-embedded-holons","title":"\ud83d\udce6 Inline Embedded Holons","text":"<p>Use inline embedding to define a holon directly in context. This is required for:</p> <ul> <li>Keyless holons</li> <li>One-off structures, like constraints or descriptors</li> <li>Situations where local scoping improves clarity</li> </ul> <p>Caveat: Each inline Holon is importing a new Holon, be careful to avoid unwanted duplication</p>"},{"location":"mapp-dev/holon-data-loader-guide/#reference-examples","title":"\u2705 Reference Examples","text":"<p>TBD</p>"},{"location":"mapp-dev/holon-data-loader-guide/#invalid-reference-cases","title":"\ud83d\udeab Invalid Reference Cases","text":"<ul> <li>\u274c <code>$ref</code> to a keyless holon (must be embedded)</li> <li>\u274c <code>id:</code> reference to a keyless holon \u2014 even though syntactically allowed, keyless holons must never be the target of a declared relationship</li> <li>\u274c References outside expected type context</li> <li>\u274c Mixing <code>$ref</code> and <code>type</code> in a single object</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#summary","title":"\u2705 Summary","text":"Reference Form Best For Requires Key Reusable? <code>$ref</code> Reuse of shared or saved holons \u2705 Yes \u2705 Yes Inline One-off or keyless components \u274c No \u274c No"},{"location":"mapp-dev/holon-data-loader-guide/#file-structure","title":"\ud83d\udcc1 File Structure","text":"<p>Each JSON import file consists of two top-level keys:</p> <pre><code>{\n  \"meta\": { ... },\n  \"holons\": [ ... ]\n}\n</code></pre> <ul> <li><code>meta</code>: Metadata describing the file</li> <li><code>holons</code>: List of holon definitions to be imported</li> </ul> <p>Each entry in the <code>holons</code> array is a self-contained JSON object representing a single holon.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#holon-definition","title":"\ud83d\udd39 Holon Definition","text":"<p>Each holon is a JSON object with four primary fields:</p> <ul> <li><code>type</code>: The descriptor for this holon (replaces <code>DescribedBy</code>)</li> <li><code>key</code>: Required only for keyed holons</li> <li><code>properties</code>: A map of named scalar property values</li> <li><code>relationships</code>: A list of outbound relationships to other holons</li> </ul> <p>See the Foundational Concepts section above for background on types, keys, references, and embedding.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#type","title":"\ud83e\udde9 <code>type</code>","text":"<p>The <code>type</code> field identifies the HolonType (or other descriptor type) that describes this holon. It replaces the need to author a <code>DescribedBy</code> relationship.</p> <ul> <li>Format: a <code>#Key</code> reference to a known type descriptor</li> <li>Required for all holons</li> </ul> <p>Example:</p> <pre><code>\"type\": \"#BookType\"\n</code></pre> <p>This implies: - The holon is described by a <code>BookType</code> - All properties and relationships must conform to the rules defined by that type</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key","title":"\ud83e\udde9 <code>key</code>","text":"<p>The <code>key</code> is a unique identifier for keyed holons. It is:</p> <ul> <li>Required for holons of keyed Holon Types</li> <li>Not allowed for holons of keyless Holon Types</li> <li>Used as the reference target for <code>$ref</code> within the same or other import files</li> </ul> <p>Keys are derived based on the holon\u2019s HolonType, which includes a <code>UsesKeyRule</code> relationship pointing to a <code>FormatKeyRule</code>. This rule specifies how to construct the key from the holon\u2019s property values \u2014 and sometimes values on related holons.</p> <p>\ud83d\udd04 Because the key can be deterministically derived from the holon\u2019s structure, including it is technically redundant. However, the <code>key</code> field is explicitly included in the JSON import for: - Improved readability - <code>$ref</code> compatibility - Validation of key correctness at staging time</p>"},{"location":"mapp-dev/holon-data-loader-guide/#important","title":"\u26a0\ufe0f Important","text":"<p>If any property value involved in key derivation changes, the <code>key</code> field and any <code>$ref</code>'s to it must also be updated to match the new derived value. The loader will recompute the key using the declared <code>FormatKeyRule</code> and compare it to the authored key \u2014 raising a validation error if they do not match.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key-derivation-rules_1","title":"\ud83d\udd22 Key Derivation Rules","text":"<p>Every keyed holon must declare a <code>UsesKeyRule</code> relationship pointing to a <code>FormatKeyRule</code> \u2014 a holon that defines how the key should be constructed.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#formatkeyrule-structure","title":"FormatKeyRule Structure","text":"<p>A <code>FormatKeyRule</code> has two fields:</p> <ul> <li><code>format</code>: A string template (e.g., <code>\"$0\"</code>, <code>\"($0)-[$1]-&gt;($2)\"</code>)</li> <li><code>property_names</code>: An ordered list of names (strings) that supply the values for the placeholders</li> </ul> <p>Example:</p> <pre><code>{\n  \"type\": \"#FormatKeyRule\",\n  \"properties\": {\n    \"format\": \"$0\",\n    \"property_names\": [\"type_name\"]\n  }\n}\n</code></pre>"},{"location":"mapp-dev/holon-data-loader-guide/#common-patterns","title":"\u2705 Common Patterns","text":"<p>Single-property key (e.g., <code>MapStringValueType</code>): <pre><code>{\n  \"format\": \"$0\",\n  \"property_names\": [\"type_name\"]\n}\n</code></pre></p> <p>**Relationship Type Keys ** (inspired by OpenCypher notation): <pre><code>{\n  \"format\": \"($0)-[$1]-&gt;($2)\",\n  \"property_names\": [\"source_type\", \"type_name\", \"target_type\"]\n}\n</code></pre></p>"},{"location":"mapp-dev/holon-data-loader-guide/#declaring-useskeyrule","title":"\u270d\ufe0f Declaring UsesKeyRule","text":"<p>Inline:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": {\n    \"type\": \"#FormatKeyRule\",\n    \"properties\": {\n      \"format\": \"$0\",\n      \"property_names\": [\"type_name\"]\n    }\n  }\n}\n</code></pre> <p>By reference:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": { \"$ref\": \"FormatKeyRule:BookType.KeyRule\" }\n}\n</code></pre> <p>The loader validates all authored <code>key</code> values by recomputing them using the declared key rule and comparing the result.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#properties","title":"\ud83e\udde9 <code>properties</code>","text":"<p>The <code>properties</code> field contains a map of property name to scalar value, like so:</p> <pre><code>\"properties\": {\n  \"type_name\": \"BookType\",\n  \"enabled\": true,\n  \"max_length\": 255\n}\n</code></pre> <p>Each value must be one of the supported MAP scalar types: - <code>string</code> (e.g., <code>\"BookType\"</code>) - <code>number</code> (e.g., <code>42</code>, <code>3.14</code>) - <code>boolean</code> (e.g., <code>true</code>, <code>false</code>) - or an array of scalars (for multi-valued properties)</p> <p>Property types are enforced by the <code>PropertyType</code> descriptor referenced in the holon\u2019s <code>type</code>. The loader will convert each value into its appropriate <code>BaseValue</code> variant based on the declared value type \u2014 not based on any in-band <code>\"type\"</code> or <code>\"value\"</code> tags.</p> <p>\ud83d\udd12 Property values must be scalars. You cannot use structured objects (like <code>{ \"type\": ..., \"value\": ... }</code>) inside the <code>properties</code> field. Those are only valid in embedded holons or type definitions.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#relationships","title":"\ud83e\udde9 <code>relationships</code>","text":"<p>In MAP, every relationship pair is modeled as two named, uni-directional relationships:</p> <ul> <li>A declared relationship (e.g., <code>(Person)-[HasAddress]-&gt;(Address)</code>)</li> <li>Its corresponding inverse relationship (e.g., <code>(Address)-[AddressOf]-&gt;(Person)</code>)</li> </ul> <p>Strictly speaking, only declared relationships are allowed to be directly populated in the system\u2019s internal storage model. Inverse relationships are automatically derived based on this. However, the JSON import format allows you to populate either direction for convenience.</p> <p>If a JSON import populates an inverse relationship, the Holon Data Loader will:</p> <ol> <li>Look up its <code>InverseOf</code> link to find the declared relationship type.</li> <li>Internally redirect the population to that declared relationship.</li> <li>Leave the inverse direction empty (it will be auto-derived later).</li> </ol> <p>This supports a more natural and readable JSON layout in many scenarios.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#authoring-guidelines","title":"\u26a0\ufe0f Authoring Guidelines","text":"<ul> <li> <p>\u2705 Only populate one direction of a relationship pair.   Do not populate both <code>HasAddress</code> and <code>AddressOf</code>.</p> </li> <li> <p>\u26a0\ufe0f If the relationship involves a keyless holon type:</p> </li> <li>The declared relationship must be defined on the keyed holon type.</li> <li>You must embed the keyless holon inline, using the inverse direction.</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#example-embedding-a-keyless-holon","title":"\u2705 Example: Embedding a Keyless Holon","text":"<p>Let\u2019s say <code>PersonType</code> declares the relationship <code>HasAddress \u2192 AddressType</code>, and <code>AddressType</code> is keyless. We want to attach an address to a person:</p> <pre><code>{\n  \"type\": \"#PersonType\",\n  \"key\": \"charles-eisenstein\",\n  \"properties\": {\n    \"name\": \"Charles Eisenstein\"\n  },\n  \"relationships\": [\n    {\n      \"name\": \"AddressOf\",  \n        \"type\": \"#AddressType\",\n        \"properties\": {\n          \"city\": \"Keene\",\n          \"state\": \"New Hampshire\"\n        }\n      }\n  ]\n}\n</code></pre>"},{"location":"mapp-dev/holon-data-loader-guide/#explanation","title":"\ud83e\udde0 Explanation","text":"<ul> <li><code>AddressType</code> is keyless \u2192 it must not be the target of a declared relationship.</li> <li><code>PersonType</code> declares <code>HasAddress \u2192 AddressType</code></li> <li>JSON authors embed the keyless <code>Address</code> and populate its inverse relationship, <code>AddressOf \u2192 Person</code></li> <li>The loader internally flips it and populates <code>HasAddress(charles-eisenstein \u2192 [Address])</code></li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#declared-vs-inverse-relationships","title":"\ud83d\udd01 Declared vs. Inverse Relationships","text":"<p>When importing instance holons, each outbound <code>relationship</code> must ultimately correspond to a declared relationship \u2014 that is, a relationship defined as outbound from the holon\u2019s type.</p> <p>However, the MAP import format allows you to use either direction of a relationship pair when authoring instance data:</p> <ul> <li>A declared relationship, such as:   <pre><code>(Book)-[AUTHORED_BY]-&gt;(Person)\n</code></pre></li> <li>Its corresponding inverse relationship, such as:   <pre><code>(Person)-[AuthorOf]-&gt;(Book)\n</code></pre></li> </ul> <p>These two together form a relationship pair, where one is marked as the <code>InverseOf</code> the other in its relationship type definition.</p> <p>\ud83d\udd04 Even though only declared relationships are persisted, the loader will redirect inverse relationship usage to the appropriate declared relationship and populate it accordingly.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#authoring-either-direction","title":"\u2705 Authoring Either Direction","text":"<p>In your JSON import file, you may use either side:</p> <pre><code>{\n  \"name\": \"AUTHORED_BY\",\n  \"target\": { \"$ref\": \"person-789\" }\n}\n</code></pre> <p>or:</p> <pre><code>{\n  \"name\": \"AuthorOf\",\n  \"target\": { \"$ref\": \"book-123\" }\n}\n</code></pre> <p>Either form will result in the declared <code>AUTHORED_BY</code> relationship being populated.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#authoring-guidelines_1","title":"\u26a0\ufe0f Authoring Guidelines","text":"<ul> <li> <p>\u2705 Only populate one direction of a relationship pair.   Do not populate both <code>AUTHORED_BY</code> and <code>AuthorOf</code> \u2014 choose one or the other.</p> </li> <li> <p>\u26a0\ufe0f If one end of the relationship is a keyless holon (e.g., an inline annotation or constraint):</p> </li> <li>The keyless holon\u2019s type must declare the relationship.</li> <li>You must populate the inverse direction using an embedded target, not a <code>$ref</code>.</li> </ul> <p>\ud83e\udde0 Internally, only declared relationships are directly populated. The system automatically backfills the corresponding inverse relationships.</p> <p>A separate section provides guidance on defining declared and inverse relationship types, and how the <code>InverseOf</code> and <code>Inverse</code> links connect them.</p> <p>In MAP, every relationship pair is modeled as two named, uni-directional relationships:</p> <ul> <li>A declared relationship (e.g., <code>(Book)-[AuthoredBy]-&gt;(Person)</code>)</li> <li>Its corresponding inverse relationship (e.g., <code>(Person)-[AuthorOf]-&gt;(Book)</code>)</li> </ul> <p>Strictly speaking, only declared relationships are allowed to be directly populated in the system\u2019s internal storage model. Inverse relationships are automatically derived based on this. However, the JSON import format allows you to populate either direction for convenience.</p> <p>If a JSON import populates an inverse relationship, the Holon Data Loader will:</p> <ol> <li>Look up its <code>InverseOf</code> link to find the declared relationship type.</li> <li>Internally redirect the population to that declared relationship.</li> <li>Leave the inverse direction empty (it will be auto-derived later).</li> </ol> <p>This supports a more natural and readable JSON layout in many scenarios.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#example-using-inverse-in-json","title":"\u2705 Example: Using Inverse in JSON","text":"<p>You may populate the <code>Extends</code> relationship directly:</p> <pre><code>{\n  \"name\": \"Extends\",\n  \"target\": { \"$ref\": \"MetaTypeDescriptor\" }\n}\n</code></pre> <p>Or, equivalently, populate the inverse <code>ExtendedBy</code>:</p> <pre><code>{\n  \"name\": \"ExtendedBy\",\n  \"target\": {\n    \"type\": \"#MetaHolonType\",\n    \"properties\": {\n      \"type_name\": \"MetaHolonType\"\n    }\n  }\n}\n</code></pre> <p>Both will result in the same internal relationship being established \u2014 on the declared <code>Extends</code> direction.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#authoring-rules-and-caveats","title":"\u26a0\ufe0f Authoring Rules and Caveats","text":"<p>To ensure consistency and correctness, observe the following:</p> <ul> <li>\u2705 Only one direction of a relationship pair should be populated in your JSON file.</li> <li>\u2705 If you choose to use the inverse relationship in your JSON, ensure the inverse type includes an <code>InverseOf</code> link to its declared counterpart.</li> <li>\u26a0\ufe0f If either source or target holon type in the relationship is keyless:</li> <li>That keyless type must declare the relationship (i.e., be the source of the declared direction).</li> <li>The inverse direction must be populated inline, via embedded holons \u2014 since keyless holons cannot be referenced.</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#relationship-pairing-inverseof-and-inverse","title":"\ud83d\udd04 Relationship Pairing: <code>InverseOf</code> and <code>Inverse</code>","text":"<p>Each inverse relationship must include an <code>InverseOf</code> link to its declared counterpart:</p> <pre><code>{\n  \"name\": \"InverseOf\",\n  \"target\": { \"$ref\": \"#(RelationshipType)-[Extends]-&gt;(RelationshipType)\" }\n}\n</code></pre> <p>Once this is present, the system automatically adds the reverse link using <code>Inverse</code>:</p> <pre><code>{\n  \"name\": \"Inverse\",\n  \"target\": { \"$ref\": \"#(RelationshipType)-[ExtendedBy]-&gt;(RelationshipType)\" }\n}\n</code></pre> <p>You do not need to author <code>Inverse</code> links directly.</p> <p>==== OLDER STUFF</p> <p>The <code>relationships</code> field is a list of outbound links from the holon to other holons.</p> <p>Each entry must contain: - <code>name</code>: the name of the relationship - <code>target</code>: a single holon, a <code>$ref</code>, or an array of either</p> <p>You may use either of the following forms:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": { \"$ref\": \"FormatKeyRule:Book.KeyRule\" }\n}\n</code></pre> <p>or</p> <pre><code>{\n  \"name\": \"Components\",\n  \"target\": [\n    { \"$ref\": \"BookType\" },\n    { \"$ref\": \"PersonType\" }\n  ]\n}\n</code></pre> <p>\u2705 The loader automatically normalizes all <code>target</code> values to arrays. Even single references are treated as 1-element arrays internally.</p> <p>\u26a0\ufe0f Cardinality constraints are enforced using the type descriptor associated with the relationship name. For example, relationships like <code>DescribedBy</code> or <code>ComponentOf</code> often have <code>max_cardinality = 1</code>.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#embedded-schema-structure","title":"\ud83d\udcc2 Embedded Schema Structure","text":"<p>Schemas may embed their components directly via inverse relationships:</p> <pre><code>{\n  \"type\": \"#MapSchemaType\",\n  \"key\": \"MAP Core Schema\",\n  \"relationships\": [\n    {\n      \"name\": \"Components\",\n      \"target\": [ { \"holon\" }, { \"holon\" } ]\n    }\n  ]\n}\n</code></pre> <p>These will be rewritten by the loader into <code>ComponentOf</code> declarations from each child.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#defining-the-relationships-for-a-type","title":"Defining the Relationships for a Type:","text":""},{"location":"mapp-dev/holon-data-loader-guide/#declaring-vs-instantiating-relationships","title":"\ud83d\udd04 Declaring vs. Instantiating Relationships","text":"<p>In the MAP import format, it is essential to distinguish between two conceptually distinct usages of relationships:</p>"},{"location":"mapp-dev/holon-data-loader-guide/#1-declaring-allowed-relationships-for-a-type","title":"1. Declaring Allowed Relationships for a Type","text":"<p>When defining a type descriptor, we use the <code>InstanceRelationships</code> relationship to declare what kinds of relationships instances of this type may include. The targets of <code>InstanceRelationships</code> must be relationship types.</p> <p>Example:</p> <pre><code>{\n  \"name\": \"InstanceRelationships\",\n  \"target\": [\n    { \"$ref\": \"#(TypeDescriptor)-[ComponentOf]-&gt;(Schema)\" }\n  ]\n}\n</code></pre> <p>This states that instances of this type (e.g., <code>TypeDescriptor</code>) may include a <code>ComponentOf</code> relationship, and identifies the structural pattern expected for that relationship. The details of that relationship type (cardinality constraints, whether it is definitional, etc.) are defined in the referenced RelationshipType descriptor.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#2-instantiating-a-specific-relationship-for-a-holon","title":"2. Instantiating a Specific Relationship for a Holon","text":"<p>When authoring a specific holon, such as a type descriptor or instance, the <code>relationships</code> field is used to instantiate actual relationship instances. These entries must include:</p> <ul> <li>A <code>name</code>: the name of the relationship</li> <li>A <code>target</code>: the holon being linked to (typically via <code>$ref</code>)</li> </ul> <p>\u2705 Correct:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": { \"$ref\": \"#TypeName.KeyRule\" }\n}\n</code></pre> <p>\u274c Incorrect:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": {\n    \"type\": \"#Format.KeyRuleType\",\n    \"key\": \"TypeName.KeyRule\",\n    ...\n  }\n}\n</code></pre> <p>The incorrect version attempts to define the target inline \u2014 which may duplicate shared definitions and blur the separation of concerns between relationship declarations and relationship instances.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key-takeaway","title":"\ud83e\udded Key Takeaway","text":"<p>When declaring which relationships a type supports, point to relationship types. When instantiating a relationship in a holon, point to a target holon \u2014 typically via <code>$ref</code>.</p> <p>Following this rule ensures structural clarity, enables reuse, and keeps the MAP type system modular and DRY.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key-derivation-rules_2","title":"\ud83d\udd22 Key Derivation Rules","text":"<p>Every keyed holon must declare a <code>UsesKeyRule</code>, pointing to a <code>FormatKeyRule</code> with:</p> <ul> <li><code>format</code>: A string template (e.g., <code>\"$0\"</code>, <code>\"($0)-[$1]-&gt;($2)\"</code>)</li> <li><code>property_names</code>: List of property or inferred names used to fill the format</li> </ul> <p>The authored <code>key</code> must match the result of evaluating the format rule.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#best-practices_1","title":"\ud83d\udcda Best Practices","text":"<ul> <li>\u2705 Include <code>UsesKeyRule</code> for every keyed type descriptor</li> <li>\u2705 Use consistent naming across <code>type_name</code>, <code>display_name</code>, and <code>key</code></li> <li>\u2705 Use inline embedding for keyless holons or unique instances</li> <li>\u2705 Use <code>$ref</code> for reusable, keyed holons</li> <li>\u274c Do not author <code>DescribedBy</code> or <code>OwnedBy</code> \u2014 these are handled automatically</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#validation","title":"\ud83d\udd0e Validation","text":"Rule ID Title Description Severity json-schema Syntactic validation via JSON Schema The file must conform to the MAP JSON import format schema. error foundational-rule Foundational Rule for All Type Descriptors Every Type Descriptor must be <code>DescribedBy</code> <code>TypeDescriptor</code> and <code>Extend</code> (at most) exactly 1 Abstract Type. error unresolved-refs Unresolved References All $ref values must resolve to a keyed holon defined in the same or explicitly provided files. error only-declared-properties Only Declared Properties May Be Populated Holons must not specify properties not listed in InstanceProperties of their type. error only-declared-relationships Only Valid Relationships May Be Authored The import file may only author relationships that are either: (1) explicitly listed in the holon\u2019s type descriptor via InstanceRelationships, or (2) valid inverse relationships, which are resolved via InverseRelationshipType definitions that point back to a DeclaredRelationshipType where the holon\u2019s type is the TargetType. The system applies updates through the canonical declared direction. error <p>Files should be validated against:</p> <ol> <li><code>bootstrap-import.schema.json</code> \u2014 ensures structural correctness</li> <li>Schema-specific definitions \u2014 derived from the loaded Meta-Schema or Core Schema</li> </ol> <p>Holons are further validated at runtime by MAP\u2019s shared validators.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#ready-to-import","title":"\ud83c\udf89 Ready to Import","text":"<p>Once authored and validated, the file can be submitted to the Holon Data Loader.</p> <ul> <li>All <code>key</code> and <code>$ref</code> references will be resolved</li> <li>Relationships will be rewritten as needed</li> <li>Keyless holons will be embedded</li> <li>All imported holons will be linked to the HolonSpace via <code>OwnedBy</code></li> </ul> <p>For support, contact the MAP stewarding team or refer to the developer documentation.</p>"},{"location":"mapp-dev/holon-loader-man-page/","title":"HOLON-LOADER(1) \u2014 Manual Page","text":""},{"location":"mapp-dev/holon-loader-man-page/#name","title":"NAME","text":"<p>holon-loader \u2014 JSON Holon Loader for MAP / Conductora environments</p>"},{"location":"mapp-dev/holon-loader-man-page/#synopsis","title":"SYNOPSIS","text":"<p>holon-loader  [options]"},{"location":"mapp-dev/holon-loader-man-page/#description","title":"DESCRIPTION","text":"<p><code>holon-loader</code> parses, validates, resolves, and commits JSON Holons into a target HolonSpace using an embedded Conductora runtime.</p> <p>Input paths may be JSON files or directories. Directories are scanned recursively for <code>*.json</code>. Processing order is deterministic (lexicographic).</p> <p>Validation schema: The loader uses a built-in, fixed JSON Schema that matches the parser. Callers do not supply schema files.</p>"},{"location":"mapp-dev/holon-loader-man-page/#commands","title":"COMMANDS","text":"<p>load : Parse, validate, resolve, and commit holons into the target HolonSpace. Supports dry-run.</p> <p>validate : Parse and validate holons without committing. Produces a validation report.</p> <p>version : Print version and build information, including the loader\u2019s schema version.</p>"},{"location":"mapp-dev/holon-loader-man-page/#options","title":"OPTIONS","text":""},{"location":"mapp-dev/holon-loader-man-page/#general","title":"General","text":"<p><code>-v</code> : Increase verbosity. Repeatable (e.g. <code>-vvv</code>). Each additional <code>-v</code> raises the log level, capped at the maximum (debug).</p> <p><code>-q</code> : Quiet mode; only errors are printed. Overrides any <code>-v</code> flags.</p> <p><code>--format</code> text|json : Output format for results and reports. - <code>text</code> \u2014 human-readable summaries (default). - <code>json</code> \u2014 machine-readable structured output (for scripting and integration). Affects only output; inputs are always JSON files.</p>"},{"location":"mapp-dev/holon-loader-man-page/#target-holonspace","title":"Target HolonSpace","text":"<p>One of the following must be provided:</p> <p><code>--space-id</code> hash : Exact HolonSpace ID (ActionHash).</p> <p><code>--space-key</code> Type:Key : Resolve HolonSpace by type and key (e.g., <code>Space:PlanetProject.Core</code>).</p> <p><code>--create-space</code> name : Create a new HolonSpace with the given name if it does not exist.</p> <p><code>--space-config</code> path : Path to space.json describing the space to create. Current schema: <code>{ \"name\": \"&lt;string&gt;\", \"description\": \"&lt;string&gt;\" }</code>.</p> <p>Resolution precedence: 1. <code>--space-id</code> 2. <code>--space-key</code> 3. <code>--create-space</code> (with optional <code>--space-config</code>)    Else \u2192 error: \u201cNo HolonSpace specified.\u201d</p>"},{"location":"mapp-dev/holon-loader-man-page/#loader-behavior","title":"Loader Behavior","text":"<p><code>-n</code>, <code>--dry-run</code> : Do everything except commit.</p> <p><code>--deny-externals</code> : Forbid references to external spaces (default).</p> <p><code>--allow-externals</code> : Allow references to external spaces via proxy map.</p> <p><code>--proxy-map</code> path : Proxy map file used when <code>--allow-externals</code> is enabled.</p> <p><code>--fail-fast</code> : Abort on first validation error.</p> <p><code>--max-errors</code> n : Maximum number of errors to collect before aborting (default: 50).</p>"},{"location":"mapp-dev/holon-loader-man-page/#inputs","title":"INPUTS","text":"<ul> <li>One or more file or directory paths.</li> <li>Files: processed if they end with <code>.json</code>.</li> <li>Directories: scanned recursively for <code>*.json</code>.</li> <li>Non-JSON files are ignored.</li> <li>Mixed paths allowed; final list is the deterministic union.</li> </ul>"},{"location":"mapp-dev/holon-loader-man-page/#files","title":"FILES","text":"<p>*.json : Holon import files. Each file must contain one or more Holon definitions in the MAP JSON import format.</p> <p>space.json : Optional configuration file for <code>--space-config</code> when creating a HolonSpace. Currently supports only: - <code>name</code> (string) - <code>description</code> (string)</p> <p>(No external schema files are used; validation relies on the loader\u2019s fixed internal schema.)</p>"},{"location":"mapp-dev/holon-loader-man-page/#examples","title":"EXAMPLES","text":"<p>Validate all JSON files under <code>./imports</code>:</p> <pre><code>holon-loader validate ./imports --space-id id:uhCk123\u2026\n</code></pre> <p>Load with dry-run and verbose output:</p> <pre><code>holon-loader load ./set -n -vv \\\n  --space-key Space:PlanetProject.Core\n</code></pre> <p>Create a new space and load into it (space.json with name/description):</p> <pre><code>holon-loader load ./data \\\n  --create-space Catalist.Sandbox \\\n  --space-config ./space.json\n</code></pre> <p>Emit machine-readable JSON:</p> <pre><code>holon-loader validate ./imports --format json --space-id id:uhCk123\u2026\n</code></pre>"},{"location":"mapp-dev/holon-loader-man-page/#exit-status","title":"EXIT STATUS","text":"<p><code>0</code> \u2014 success <code>1</code> \u2014 validation error <code>2</code> \u2014 reference resolution error <code>3</code> \u2014 commit error <code>4</code> \u2014 configuration or environment error</p>"},{"location":"mapp-dev/holon-loader-man-page/#see-also","title":"SEE ALSO","text":"<p>holochain(1), hc(1), MAP documentation.</p>"},{"location":"mapp-dev/holon-loader-man-page/#notes","title":"NOTES","text":"<ul> <li>Input order is stable and deterministic.</li> <li>HolonSpace currently supports only <code>name</code> and <code>description</code>.</li> <li>When future HolonSpace policy is introduced, it will take precedence over CLI flags.</li> </ul>"},{"location":"mapp-dev/map-api/","title":"MAP API","text":"<p>This section describes the interface surface of the MAP from a client perspective.</p>"},{"location":"mapp-dev/map-security-model/","title":"MAP Security Model \u2014 Technical Specification (Modern Structure)","text":"<p>Version: 1.0 Status: Draft Audience: MAP Core Developers, Security Architects, Holochain Integration Engineers Last Updated: October 2025</p>"},{"location":"mapp-dev/map-security-model/#1-overview","title":"1. Overview","text":""},{"location":"mapp-dev/map-security-model/#11-purpose","title":"1.1 Purpose","text":"<p>This document specifies the security architecture and operational controls of the Memetic Activation Platform (MAP). It defines the trust foundations, threat mitigations, and adaptive enforcement mechanisms that ensure data sovereignty, agent integrity, and membrane-level trust across the platform.</p>"},{"location":"mapp-dev/map-security-model/#12-scope","title":"1.2 Scope","text":"<p>The specification applies to all MAP runtimes (client, host, and interspace) and covers: - Identity and key management - Authentication, authorization, and accountability - Membrane security and Trust Channels - Adaptive risk and behavioral enforcement - Space lensing and contextual visibility - Governance and data exfiltration controls - Operational resilience and resource protection</p>"},{"location":"mapp-dev/map-security-model/#13-guiding-principles","title":"1.3 Guiding Principles","text":"<ul> <li>Sovereignty by Design: Each Agent owns its identity, keys, and data.</li> <li>Defense in Depth: Security enforced at device, membrane, and agreement layers.</li> <li>Contextual Enforcement: Risk, sensitivity, and lens determine protection level.</li> <li>Zero Central Trust: No MAP component requires global or third-party trust.</li> <li>Transparency and Traceability: Every security decision is auditable and policy-driven.</li> </ul>"},{"location":"mapp-dev/map-security-model/#2-system-architecture","title":"2. System Architecture","text":""},{"location":"mapp-dev/map-security-model/#21-core-security-domains","title":"2.1 Core Security Domains","text":"Domain Description Enforcement Mechanism Agent Identity Cryptographically unique entities (one per device). Holochain keypairs managed by Lair keystore. Space Membranes Sovereign boundaries governing holon data and execution. Trust Channels and Agreement policies. Agreements Policy layer defining roles, protocols, and data rights. AuthZPolicy, CryptoPolicy, StepUpPolicy. Trust Channels Secure communication conduits between Spaces. Multi-envelope capsule architecture. Risk Layer Adaptive defense system analyzing behavioral and contextual data. RiskPolicy + StepUpPolicy enforcement. Lens Layer Contextual visibility management within Spaces. ActiveSpace + AsSelfEnvelope."},{"location":"mapp-dev/map-security-model/#22-layered-architecture-diagram","title":"2.2 Layered Architecture Diagram","text":"<pre><code>Device Layer  \u2192  Agent Layer  \u2192  Space Membrane Layer  \u2192  Agreement Layer\n      \u2195                  \u2195                        \u2195                       \u2195\nLocal Authentication   Key Custody          Trust Channel Validation   Policy &amp; Risk Control\n</code></pre>"},{"location":"mapp-dev/map-security-model/#3-identity-and-key-management","title":"3. Identity and Key Management","text":""},{"location":"mapp-dev/map-security-model/#31-agent-keys","title":"3.1 Agent Keys","text":"<p>Each device acts as an Agent with a unique cryptographic keypair: - Keys are stored in Lair Keystore (Holochain secure enclave). - Public keys are registered with relevant Agreements. - Keys never leave the device; signing and decryption happen in-process only.</p>"},{"location":"mapp-dev/map-security-model/#32-key-lifecycle","title":"3.2 Key Lifecycle","text":"Phase Action Enforcement Creation Device generates new keypair via Lair. Requires local OS unlock. Association Key registered to user\u2019s I-Space. Cryptographically signed claim. Revocation Compromised keys revoked by user or I-Space admin. Propagated via DHT gossip. Rotation New keypair replaces revoked key. Updates signed linkage chain."},{"location":"mapp-dev/map-security-model/#33-optional-key-splitting","title":"3.3 Optional Key Splitting","text":"<p>For critical data, MAP supports XOR or threshold-based key partitioning. Each fragment is stored across separate devices or vaults, requiring quorum reconstruction.</p>"},{"location":"mapp-dev/map-security-model/#4-authentication-and-authorization","title":"4. Authentication and Authorization","text":""},{"location":"mapp-dev/map-security-model/#41-authentication-sources","title":"4.1 Authentication Sources","text":"<ul> <li>Device Trust: Biometric/PIN unlocks the operating system.</li> <li>Agent Trust: Lair keystore confirms agent keypair control.</li> <li>Space Trust: Agreement-based verification within the Space membrane.</li> <li>Step-Up Trust: Secondary verification for sensitive Dances (SFS session).</li> </ul>"},{"location":"mapp-dev/map-security-model/#42-authorization-model","title":"4.2 Authorization Model","text":"<p>Authorization follows a role \u2192 scope \u2192 policy chain: 1. The active Agreement defines permissible roles. 2. Roles map to AuthZPolicy objects specifying allowed Dances and data scopes. 3. The Space membrane enforces these via the Trust Channel\u2019s AuthZEnvelope.</p>"},{"location":"mapp-dev/map-security-model/#43-permission-types","title":"4.3 Permission Types","text":"Permission Type Description Example Enforcement Read Retrieve data within allowed visibility scope. Lens filtering via ExfiltrationPolicy. Write Modify or propose changes to Space data. AuthZEnvelope validation. Execute Trigger a Dance or system action. DispatchEnvelope routing. Exfiltrate Send data beyond membrane. Outbound ExfiltrationEnvelope."},{"location":"mapp-dev/map-security-model/#5-trust-channels-and-membrane-security","title":"5. Trust Channels and Membrane Security","text":""},{"location":"mapp-dev/map-security-model/#51-purpose","title":"5.1 Purpose","text":"<p>Trust Channels provide the secure envelope architecture that protects all cross-Space Dances. Each message is encapsulated in a Dance Capsule comprising sequential validation layers: <code>Transport \u2192 AuthN \u2192 Crypto \u2192 AuthZ \u2192 Dispatch \u2192 Payload (\u2192 Exfiltration)</code></p>"},{"location":"mapp-dev/map-security-model/#52-enforcement-objectives","title":"5.2 Enforcement Objectives","text":"<ul> <li>Guarantee message authenticity and origin.</li> <li>Prevent unauthorized decryption or replay.</li> <li>Enforce Agreement policies cryptographically.</li> <li>Maintain auditability of all exchanges.</li> </ul>"},{"location":"mapp-dev/map-security-model/#53-key-functions","title":"5.3 Key Functions","text":"Envelope Function Validation Output Transport Routing, Agreement pinning, protocol negotiation. Confirmed target membrane. AuthN Verify sender\u2019s signature. Proven identity and integrity. Crypto Decrypt payload. Confidentiality enforced. AuthZ Check sender\u2019s role and permissions. Scoped authorization granted. Dispatch Deliver payload to local I-Space. Safe local execution. Exfiltration Filter outbound data. Controlled data exposure."},{"location":"mapp-dev/map-security-model/#54-protocol-negotiation","title":"5.4 Protocol Negotiation","text":"<p>When Spaces exchange data, they negotiate which ProtocolSuite to use: 1. Sender proposes a suite from the Agreement\u2019s <code>DancePolicyMap</code>. 2. Receiver validates or downshifts to a compatible suite. 3. The final choice is pinned in the capsule (<code>NegotiatedSuite</code>). 4. Both sides verify suite compatibility and envelope sequence integrity.</p>"},{"location":"mapp-dev/map-security-model/#6-risk-enforcement-framework","title":"6. Risk Enforcement Framework","text":""},{"location":"mapp-dev/map-security-model/#61-overview","title":"6.1 Overview","text":"<p>The Risk Enforcement Framework introduces adaptive, behavior-driven protection. It monitors usage patterns and dynamically enforces step-up authentication or throttling when contextual risk increases.</p>"},{"location":"mapp-dev/map-security-model/#62-core-components","title":"6.2 Core Components","text":"<p>RiskPolicy Holon <pre><code>RiskPolicy\n \u251c\u2500\u2500 ConsumesTelemetry \u2192 [RiskEventType...]\n \u251c\u2500\u2500 UsesStepUpPolicy \u2192 StepUpPolicy\n \u2514\u2500\u2500 MapsSensitivityToThresholds \u2192 [SensitivityThresholdMap...]\n</code></pre></p> <p>StepUpPolicy - Defines acceptable second-factor methods (biometric, PIN, hardware key). - Establishes TTL, idle timeout, and re-verification frequency.</p>"},{"location":"mapp-dev/map-security-model/#63-sensitivity-and-scoring","title":"6.3 Sensitivity and Scoring","text":"<p>Each DanceDescriptor defines a sensitivity tier: | Tier | Description | Typical Enforcement | |------|--------------|---------------------| | None | Low risk | No step-up required | | Elevated | Confidential | Require active SFS | | Critical | Governance or high value | Always require step-up |</p> <p>A Risk Engine aggregates telemetry (e.g., failed auth, anomalies, location shifts) into a dynamic risk score. If score \u2265 threshold or sensitivity = Critical \u2192 the capsule builder inserts an <code>UnlockEnvelope</code>.</p>"},{"location":"mapp-dev/map-security-model/#64-behavioral-monitoring","title":"6.4 Behavioral Monitoring","text":"<p>The Risk Engine collects and evaluates: - Frequency and velocity of actions. - Deviations from normal temporal patterns. - Device or network changes. - Recent revocations or policy breaches.</p> <p>Triggered responses: - Insert <code>UnlockEnvelope</code> before next Dance. - Suspend session or throttle request rate. - Emit <code>RiskPolicyViolation</code> for audit and governance action.</p>"},{"location":"mapp-dev/map-security-model/#65-developer-integration","title":"6.5 Developer Integration","text":"<ul> <li>Step-up enforcement occurs client-side (Tauri layer).</li> <li>Applications must query risk state and prompt user for confirmation if required.</li> <li>Telemetry events should be submitted for ongoing learning.</li> </ul>"},{"location":"mapp-dev/map-security-model/#7-space-lens-and-access-semantics","title":"7. Space Lens and Access Semantics","text":""},{"location":"mapp-dev/map-security-model/#71-concept","title":"7.1 Concept","text":"<p>MAP introduces Space lenses to define the contextual visibility of data. At any time, an Agent operates within one ActiveSpace that determines which holons they can see, modify, or invoke.</p>"},{"location":"mapp-dev/map-security-model/#72-activespace","title":"7.2 ActiveSpace","text":"<ul> <li>A single Space context is active per user session.</li> <li>Switching ActiveSpace updates the active Agreement set and available Trust Channels.</li> <li>Cached views and permissions are lens-bound\u2014switching lenses resets them.</li> </ul>"},{"location":"mapp-dev/map-security-model/#73-lens-filtering","title":"7.3 Lens Filtering","text":"<ul> <li>The membrane automatically filters holon visibility.</li> <li>External holons are visible only through Agreement-approved projections.</li> <li>ExfiltrationPolicy determines which properties or relationships can be seen.</li> <li>Filtered results are cached per proxy for low-latency reuse.</li> </ul>"},{"location":"mapp-dev/map-security-model/#74-acting-as-vs-accessing-through","title":"7.4 Acting As vs. Accessing Through","text":"Mode Description Trust Source Acting As Changing ActiveSpace, adopting that Space\u2019s governance role. New Space\u2019s Agreement. Accessing Through Remaining in I-Space but querying remote data. Cross-Space Agreement and outbound proxy."},{"location":"mapp-dev/map-security-model/#75-asselfenvelope","title":"7.5 AsSelfEnvelope","text":"<p>For scenarios where an agent temporarily acts as themselves while within another Space: <pre><code>AsSelfEnvelope\n \u251c\u2500\u2500 SubjectAgent \u2192 Agent\n \u251c\u2500\u2500 AuthenticatedIn \u2192 SourceSpace\n \u2514\u2500\u2500 VerifiedBy \u2192 Agreement\n</code></pre> This explicitly asserts the user\u2019s I-Space identity. Validation ensures only permitted personal data is accessible and filters are applied per Agreement.</p>"},{"location":"mapp-dev/map-security-model/#76-ux-and-developer-considerations","title":"7.6 UX and Developer Considerations","text":"<ul> <li>Interfaces must clearly show the current lens.</li> <li>Switching lenses must re-evaluate role, Agreement, and risk context.</li> <li>Caches should isolate per ActiveSpace to avoid privilege bleed-through.</li> </ul>"},{"location":"mapp-dev/map-security-model/#8-data-protection-and-exfiltration","title":"8. Data Protection and Exfiltration","text":""},{"location":"mapp-dev/map-security-model/#81-exfiltrationpolicy","title":"8.1 ExfiltrationPolicy","text":"<p>Controls outbound data leaving a Space: - Whitelists permitted fields and relationships. - Defines quantitative thresholds (record count, payload size). - Redacts or aggregates sensitive attributes.</p>"},{"location":"mapp-dev/map-security-model/#82-enforcement","title":"8.2 Enforcement","text":"<p>Implemented via the ExfiltrationEnvelope in the Trust Channel. Validated before encryption to ensure no sensitive data leaves the membrane.</p>"},{"location":"mapp-dev/map-security-model/#83-audit-and-provenance","title":"8.3 Audit and Provenance","text":"<p>All exfiltrations are logged as signed <code>ExfiltrationEvents</code>, storing: - Policy tag used - Payload digest - Destination Space and Agreement - Timestamp and responsible Agent ID</p>"},{"location":"mapp-dev/map-security-model/#9-operational-security-and-resilience","title":"9. Operational Security and Resilience","text":""},{"location":"mapp-dev/map-security-model/#91-immutable-state-model","title":"9.1 Immutable State Model","text":"<p>All persisted holons are immutable; updates create new versions. This eliminates state tampering and ensures full provenance.</p>"},{"location":"mapp-dev/map-security-model/#92-sustainer-role","title":"9.2 Sustainer Role","text":"<p>The Sustainer monitors device and Space resources (memory, compute, bandwidth). When thresholds approach limits, it can: - Prune caches. - Slow gossip replication. - Temporarily halt new inbound capsules.</p> <p>This makes resource sustainability a security function preventing denial-of-service conditions.</p>"},{"location":"mapp-dev/map-security-model/#93-audit-logging-and-observability","title":"9.3 Audit Logging and Observability","text":"<ul> <li>Every validation gate in the Trust Channel emits a signed audit event.</li> <li>Events are recorded in append-only DHT logs.</li> <li>Audit holons are queryable by Agreement participants for forensic review.</li> </ul>"},{"location":"mapp-dev/map-security-model/#10-threat-model","title":"10. Threat Model","text":"Threat Vector Primary Mitigation Secondary Mitigation Device Theft Lost or stolen device Revoke key, data encrypted at rest Step-up gating, key rotation Man-in-the-Middle Network interception Capsule encryption, signature validation Protocol negotiation ensuring suite compatibility Privilege Escalation Role misuse AuthZPolicy, lens filtering Step-up enforcement Data Leakage Improper exfiltration ExfiltrationPolicy &amp; Envelope Space lens boundaries Replay Attack Capsule reuse Nonces, timestamps, hash chains Agreement nonce validation Behavioral Compromise Account hijacking or automation Risk Engine monitoring Dynamic throttling Resource Exhaustion Memory/compute flood Sustainer thresholds Load shedding"},{"location":"mapp-dev/map-security-model/#11-compliance-and-auditability","title":"11. Compliance and Auditability","text":""},{"location":"mapp-dev/map-security-model/#111-policy-provenance","title":"11.1 Policy Provenance","text":"<p>All policies (AuthZ, Crypto, Exfiltration, Risk) are holons\u2014self-describing, versioned, and signed. This ensures every enforcement event can be traced back to a verifiable descriptor.</p>"},{"location":"mapp-dev/map-security-model/#112-audit-trails","title":"11.2 Audit Trails","text":"<ul> <li>Trust Channel emits ValidationEvents with timestamps, suite IDs, and results.</li> <li>Audit holons are queryable per Agreement.</li> <li>For privacy, sensitive payloads are hashed before storage.</li> </ul>"},{"location":"mapp-dev/map-security-model/#113-policy-amendments","title":"11.3 Policy Amendments","text":"<p>Changes to security policies require Agreement version increments. All previous versions remain immutable for historic verification.</p>"},{"location":"mapp-dev/map-security-model/#12-summary","title":"12. Summary","text":""},{"location":"mapp-dev/map-security-model/#121-key-properties","title":"12.1 Key Properties","text":"Principle Outcome Sovereignty by Design Agents control their keys, data, and Agreements. Defense in Depth Device, membrane, and agreement layers reinforce each other. Adaptive Security Step-up and risk scoring adjust authentication dynamically. Contextual Visibility Space lenses define what is visible or actionable. Auditability Every envelope validation and policy decision is recorded. Resilience Sustainer maintains secure operation under load."},{"location":"mapp-dev/map-security-model/#122-conclusion","title":"12.2 Conclusion","text":"<p>The MAP Security Model is a self-governing, adaptive security architecture where sovereignty, trust, and resilience are not bolted on but emerge from the system\u2019s holonic structure. By merging Trust Channels, contextual lenses, and behavioral risk intelligence, MAP creates a living trust fabric\u2014a network where all participants interact securely, transparently, and autonomously.</p>"},{"location":"mapp-dev/rust-api-developers-guide/","title":"MAP Rust-API Developer Guide","text":"<p>The reference layer is the boundary between your application code and the underlying holon store and services. It provides:</p> <ul> <li>Uniform handles (\u201creferences\u201d) to holons, regardless of whether they are transient, staged, or cached/saved.</li> <li>A small, consistent read/write API that hides internal manager and phase differences.</li> <li>High-level operations for staging, committing, and deleting.</li> <li>A curated prelude for ergonomic imports and a stable public API.</li> </ul> <p>This guide explains the API surface and shows how to perform the most common tasks.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#1-prelude","title":"1. Prelude","text":"<p>To simplify imports, use the MAP prelude:</p> <pre><code>use holons_prelude::prelude::*;\n</code></pre> <p>This brings into scope:</p> <ul> <li>Core value and identifier types (<code>BaseValue</code>, <code>MapString</code>, <code>HolonId</code>)</li> <li>Reference traits and types (<code>HolonReference</code>, <code>ReadableHolon</code>, <code>WritableHolon</code>, <code>TransientReference</code>, <code>StagedReference</code>, <code>SmartReference</code>)</li> <li>Context traits (<code>HolonsContextBehavior</code>)</li> <li>Common operations (<code>stage_new_holon_api</code>, <code>commit_api</code>, etc.)</li> <li>Type-name helpers (<code>CorePropertyTypeName</code>, <code>CoreRelationshipTypeName</code>, <code>ToPropertyName</code>, <code>ToRelationshipName</code>)</li> <li>Dance protocol builders (<code>holon_dance_builders::*</code>)</li> <li>Query types (<code>Node</code>, <code>NodeCollection</code>, <code>QueryExpression</code>)</li> </ul> <p>Use <code>holons_prelude::prelude::v1::*</code> if you need to pin to a stable prelude version.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#2-context-your-execution-environment","title":"2. Context: your execution environment","text":"<p>Every holon operation in MAP runs within a context that implements the <code>HolonsContextBehavior</code> trait. This context is the execution environment for all read, write, and commit actions\u2014it provides access to the active workspace where your holons live.</p> <p>As a developer, you don\u2019t create or manage the context yourself. Your mApp receives it from the runtime whenever you perform operations that touch holons. You simply pass it along to each API call that needs it.</p> <p>Example \u2014 staging and committing a holon:</p> <pre><code>fn create_and_commit(\n    context: &amp;dyn HolonsContextBehavior,\n) -&gt; Result&lt;(), HolonError&gt; {\n    // Create a new transient holon of a given type\n    let transient = create_empty_transient_holon(context, MapString(\"ExampleType\".into()));\n    transient.with_property_value(context, P::Key, \"example-1\".into())?;\n\n    // Stage it for persistence\n    let staged = stage_new_holon_api(context, transient)?;\n\n    // Commit all staged changes\n    let response = commit_api(context)?;\n    println!(\"Committed {} holons.\", response.commits_attempted);\n\n    Ok(())\n}\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#key-points-for-developers","title":"Key points for developers","text":"<ul> <li> <p>The context is always the first parameter to any read or write call.   It carries all the state needed to resolve references, access relationships, and enforce permissions.</p> </li> <li> <p>You can think of it as your \u201csession\u201d or \u201cworkspace.\u201d   Everything that happens during a transaction\u2014reads, writes, staging, commits\u2014occurs within this context.</p> </li> <li> <p>The context automatically routes requests to the right implementation based on the holon\u2019s phase (transient, staged, or saved).   You never need to know which storage or cache layer is involved.</p> </li> <li> <p>Contexts are lightweight and short-lived.   They are passed around as immutable references (<code>&amp;dyn HolonsContextBehavior</code>), so you can safely use them in async or concurrent flows.</p> </li> </ul> <p>In short: the context is your gateway to the MAP. You use it everywhere, but you don\u2019t manage or configure it\u2014just pass it through to the reference-layer API.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#3-reference-kinds","title":"3. Reference Kinds","text":"<p><code>HolonReference</code> is the umbrella type that can represent any phase:</p> <ul> <li><code>TransientReference</code> \u2014 in-memory, mutable, not persisted.</li> <li><code>StagedReference</code> \u2014 managed and ready to commit.</li> <li><code>SmartReference</code> \u2014 read-only, backed by a saved holon in cache or storage.</li> </ul> <p>All three implement the <code>ReadableHolon</code> trait; transient and staged also implement <code>WritableHolon</code>.</p> Type Backing store Read Write Commit <code>TransientReference</code> In-memory \u2705 \u2705 \u274c (must stage) <code>StagedReference</code> Staging area \u2705 \u2705 \u2705 <code>SmartReference</code> Saved/cache \u2705 \u274c \u274c"},{"location":"mapp-dev/rust-api-developers-guide/#4-collections","title":"4. Collections","text":"<p>A <code>HolonCollection</code> represents an ordered set of holon references.  Collections are most commonly returned when traversing relationships\u2014especially many-to-many or one-to-many links between holons. For example, a <code>Project</code> holon might have a <code>HasTask</code> relationship that returns a <code>HolonCollection</code> of <code>Task</code> holons.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#example-reading-related-holons","title":"Example: Reading related holons","text":"<pre><code>let tasks = project_ref.related_holons(context, R::HasTask.as_relationship_name())?;\nfor task_ref in tasks.iter() {\n    let title = task_ref.property_value(context, &amp;P::Title)?;\n    println!(\"Task: {:?}\", title);\n}\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#key-capabilities","title":"Key capabilities","text":""},{"location":"mapp-dev/rust-api-developers-guide/#1-access-and-iteration","title":"1. Access and iteration","text":"<p><code>HolonCollection</code> behaves like a lightweight, reference-aware vector:</p> <pre><code>let count = tasks.len();\nlet first = tasks.first();\nlet by_index = tasks.get(2);\nlet all = tasks.to_vec(); // Clones references into a Vec&lt;HolonReference&gt;\n</code></pre> <p>You can iterate directly:</p> <pre><code>for holon_ref in &amp;tasks {\n    println!(\"{:?}\", holon_ref.key(context)?);\n}\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#2-membership-and-lookup","title":"2. Membership and lookup","text":"<pre><code>if tasks.contains(&amp;some_ref) {\n    println!(\"Already linked!\");\n}\n</code></pre> <p>If the collection is keyed (e.g., by <code>MapString</code>), you can look up by key:</p> <pre><code>if let Some(found) = tasks.get_by_key(&amp;MapString(\"task-42\".into())) {\n    println!(\"Found task 42: {:?}\", found.key(context)?);\n}\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#3-mutation-transient-and-staged-only","title":"3. Mutation (transient and staged only)","text":"<p>Collections tied to writable holons can be updated via the <code>HolonCollectionApi</code> trait. These operations automatically update both the in-memory collection and the relationship map on the parent holon.</p> <pre><code>// Add a new related holon\ntasks.add(context, HolonReference::Transient(new_task_ref))?;\n\n// Remove an existing related holon\ntasks.remove(context, HolonReference::Smart(old_task_ref))?;\n</code></pre> <p>Behind the scenes, this uses the same logic as calling: <pre><code>parent_ref.add_related_holons(context, R::HasTask.as_relationship_name(), vec![child_ref])?;\n</code></pre></p>"},{"location":"mapp-dev/rust-api-developers-guide/#4-access-control-and-phase-safety","title":"4. Access control and phase safety","text":"<ul> <li>Read-only collections (from <code>SmartReference</code>) cannot be mutated.</li> <li>Transient and staged collections support add/remove operations.</li> <li>Attempting to mutate a read-only collection returns <code>HolonError::NotAccessible</code>.</li> </ul>"},{"location":"mapp-dev/rust-api-developers-guide/#5-use-cases","title":"5. Use cases","text":"<ul> <li>Navigation: traverse relationships, fetch related holons, inspect their properties.</li> <li>Editing: attach or detach related holons while editing staged or transient instances.</li> <li>Synchronization: check if a relationship set has changed before committing.</li> </ul>"},{"location":"mapp-dev/rust-api-developers-guide/#summary","title":"Summary","text":"Operation Available on Description <code>iter()</code> All Iterate through member references <code>len()</code> / <code>is_empty()</code> All Get collection size <code>get(index)</code> / <code>get_by_key()</code> All Access by position or key <code>add()</code> / <code>remove()</code> Transient, Staged Modify collection membership <code>contains()</code> All Check membership <code>to_vec()</code> All Convert to owned vector <p>In short: HolonCollection gives you a simple, phase-safe way to traverse and manipulate sets of related holons, just like a Rust <code>Vec</code>, but with built-in access control and automatic relationship synchronization.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#5-read-api-all-reference-types","title":"5. Read API (all reference types)","text":"<p>Every <code>HolonReference</code> implements <code>ReadableHolon</code>. That means the same read calls work on <code>TransientReference</code>, <code>StagedReference</code>, and <code>SmartReference</code> alike. Reads are phase-safe and route through the active <code>HolonsContextBehavior</code>.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#core-calls","title":"Core calls","text":"<pre><code>let key_opt      = reference.key(context)?;                               // Option&lt;MapString&gt;\nlet vkey         = reference.versioned_key(context)?;                     // Versioned key (type+key+rev/epoch)\nlet title_opt    = reference.property_value(context, &amp;P::Title)?;         // Option&lt;PropertyValue&gt;\nlet children     = reference.related_holons(context, R::HasChild.as_relationship_name())?; // HolonCollection\n</code></pre> <p>Other useful calls: - <code>all_related_holons(context)</code> \u2013 returns a map of all relationship names \u2192 <code>HolonCollection</code> - <code>holon_id(context)</code> \u2013 low-level persistent identifier (when applicable) - <code>predecessor(context)</code> \u2013 previous version (if any) - <code>essential_content(context)</code> \u2013 minimal content needed to reconstruct the holon - <code>into_model(context)</code> \u2013 materialize a snapshot model (e.g., for serialization or UI presentation)</p>"},{"location":"mapp-dev/rust-api-developers-guide/#ergonomic-usage-patterns","title":"Ergonomic usage patterns","text":""},{"location":"mapp-dev/rust-api-developers-guide/#1-keys-and-versioned-keys","title":"1) Keys and versioned keys","text":"<p>Use <code>key()</code> where present (some holons may be keyless) and fall back gracefully:</p> <pre><code>let label = reference\n    .key(context)?\n    .map(|k| format!(\"key: {}\", k.0))\n    .unwrap_or_else(|| \"keyless\".to_string());\n\nlet vkey = reference.versioned_key(context)?; // Stable for logs, audit, and idempotency\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#2-properties-with-defaults","title":"2) Properties with defaults","text":"<p><code>property_value</code> returns <code>Option&lt;PropertyValue&gt;</code>. Provide sensible defaults at the edge:</p> <pre><code>let title = reference\n    .property_value(context, &amp;P::Title)?\n    .and_then(|v| v.as_string())                // Convert if your ValueType is String-like\n    .unwrap_or_else(|| \"Untitled\".to_string());\n</code></pre> <p>Tip: keep type conversion at the edge (e.g., UI layer). Treat raw <code>PropertyValue</code> as data until you must render or compute.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#3-navigating-relationships","title":"3) Navigating relationships","text":"<p>Use relationship constants for clarity and refactor safety:</p> <pre><code>let children = reference.related_holons(context, R::HasChild.as_relationship_name())?;\nfor child in children.iter() {\n    let ck = child.key(context)?;\n    let ct = child.property_value(context, &amp;P::Title)?.and_then(|v| v.as_string());\n    println!(\"child {:?} titled {:?}\", ck, ct);\n}\n</code></pre> <p>Fetch all relationships when you need to render a full card/graph:</p> <pre><code>let relmap = reference.all_related_holons(context)?;\nfor (rel_name, collection) in relmap.iter() {\n    println!(\"{}: {} linked holons\", rel_name, collection.len());\n}\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#4-lineage-aware-reads","title":"4) Lineage-aware reads","text":"<p>When building edit screens for saved holons:</p> <pre><code>if let Some(prev) = reference.predecessor(context)? {\n    println!(\"has predecessor with key {:?}\", prev.key(context)?);\n}\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#5-snapshotting-for-uipersistence","title":"5) Snapshotting for UI/persistence","text":"<p>Prefer <code>into_model</code> for immutable snapshots passed to views or serialization:</p> <pre><code>let model = reference.into_model(context)?;\n// pass `model` to your presentation layer or serializer\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#applicability-access-rules","title":"Applicability (access rules)","text":"<ul> <li>Read is allowed on all phases: Transient \u2705, Staged \u2705, Smart \u2705.</li> <li>Access control is automatically enforced; if a read is not permitted you\u2019ll get an error (see below).</li> <li>The same method set works across phases, so you can write one code path for all references.</li> </ul> <p>You never need to detect the phase to read. Call the method; the context routes it correctly.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#error-behavior-you-should-expect-here","title":"Error behavior you should expect here","text":"<p>All reads return <code>Result&lt;_, HolonError&gt;</code>. Common cases for this section:</p> <ul> <li><code>HolonError::NotAccessible</code> \u2014 read not permitted for the current state of this holon</li> <li><code>HolonError::InvalidHolonReference</code> \u2014 reference cannot be resolved (e.g., missing, malformed, or out-of-scope).</li> <li><code>HolonError::InvalidType</code> / <code>HolonError::UnexpectedValueType</code> \u2014 property exists but the value type doesn\u2019t match your expectation.</li> <li><code>HolonError::EmptyField</code> \u2014 property required by your logic is unset.</li> </ul> <p>The guide\u2019s Error Handling section enumerates all variants and recommended remedies. In read paths, prefer graceful fallbacks and edge validation (e.g., default titles, optional render elements).</p>"},{"location":"mapp-dev/rust-api-developers-guide/#practical-examples","title":"Practical examples","text":"<p>Read a title with a default and render children count <pre><code>fn render_card(\n    context: &amp;dyn HolonsContextBehavior,\n    item: &amp;HolonReference,\n) -&gt; Result&lt;(), HolonError&gt; {\n    let title = item.property_value(context, &amp;P::Title)?\n        .and_then(|v| v.as_string())\n        .unwrap_or_else(|| \"Untitled\".to_string());\n\n    let kids = item.related_holons(context, R::HasChild.as_relationship_name())?;\n    println!(\"{} ({} items)\", title, kids.len());\n    Ok(())\n}\n</code></pre></p> <p>Collect all related holons for a relationship-aware widget <pre><code>fn gather_relationships(\n    context: &amp;dyn HolonsContextBehavior,\n    item: &amp;HolonReference,\n) -&gt; Result&lt;Vec&lt;(RelationshipName, Vec&lt;HolonReference&gt;)&gt;, HolonError&gt; {\n    let mut out = Vec::new();\n    for (rel_name, coll) in item.all_related_holons(context)? {\n        out.push((rel_name.clone(), coll.to_vec()));\n    }\n    Ok(out)\n}\n</code></pre></p>"},{"location":"mapp-dev/rust-api-developers-guide/#summary-table","title":"Summary table","text":"Method Returns Notes <code>key(context)</code> <code>Result&lt;Option&lt;MapString&gt;, HolonError&gt;</code> Keyless holons return <code>None</code>. <code>versioned_key(context)</code> <code>Result&lt;VersionedKey, HolonError&gt;</code> Stable identifier for logs/audits. <code>property_value(context, &amp;P::X)</code> <code>Result&lt;Option&lt;PropertyValue&gt;, HolonError&gt;</code> Convert at the edge (<code>as_string()</code>, etc.). <code>related_holons(context, R::X)</code> <code>Result&lt;HolonCollection, HolonError&gt;</code> Ordered, phase-safe collection. <code>all_related_holons(context)</code> <code>Result&lt;BTreeMap&lt;RelationshipName, HolonCollection&gt;, HolonError&gt;</code> Full relationship map. <code>holon_id(context)</code> <code>Result&lt;HolonId, HolonError&gt;</code> May be unavailable for purely transient holons. <code>predecessor(context)</code> <code>Result&lt;Option&lt;HolonReference&gt;, HolonError&gt;</code> Present on versioned/saved lineages. <code>essential_content(context)</code> <code>Result&lt;EssentialHolonContent, HolonError&gt;</code> Minimal reconstruction payload. <code>into_model(context)</code> <code>Result&lt;HolonNodeModel, HolonError&gt;</code> Immutable snapshot for UI/serialization. <p>Takeaways - One trait, all phases: write once, read anywhere. - Treat properties as optional until rendered; fail soft at the edge. - Use relationship constants for clarity and stability.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#6-write-api-transientstaged-only","title":"6. Write API (transient/staged only)","text":"<p>Available via <code>WritableHolon</code>:</p> <pre><code>reference.with_property_value(context, P::Title, \"Hello\".into())?;\nreference.remove_property_value(context, P::Obsolete)?;\nreference.add_related_holons(context, R::HasChild.as_relationship_name(), vec![child_ref])?;\nreference.remove_related_holons(context, R::HasChild.as_relationship_name(), vec![child_ref])?;\nreference.with_descriptor(context, descriptor_ref)?;\nreference.with_predecessor(context, Some(prev_ref))?;\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#7-staging-and-commit","title":"7. Staging and Commit","text":"<p>High-level helpers in <code>holon_operations_api</code>:</p> <ul> <li>Stage a new holon <pre><code>let staged = stage_new_holon_api(context, transient)?;\n</code></pre></li> <li>Stage a new version of a saved holon   <pre><code>let staged = stage_new_version(context, smart_ref)?;\n</code></pre></li> <li>Commit all staged changes <pre><code>let commit_response = commit_api(context)?;\n</code></pre></li> </ul> <p><code>CommitResponse</code> includes: * <code>saved_holons</code> * <code>abandoned_holons</code> * <code>commits_attempted</code></p> <p><code>(saved + abandoned == attempted)</code> indicates completion.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#8-cloning-holons","title":"8. Cloning holons","text":"<p>MAP offers three public clone operations, depending on your intent.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#a-readableholonclone_holon-transientreference","title":"A. <code>ReadableHolon::clone_holon</code> \u2192 <code>TransientReference</code>","text":"<pre><code>fn clone_holon(\n    &amp;self,\n    context: &amp;dyn HolonsContextBehavior,\n) -&gt; Result&lt;TransientReference, HolonError&gt;\n</code></pre> <p>Any holon\u2014saved, staged, or transient\u2014can be cloned. The result is always a new transient holon, detached from lineage or staging metadata but preserving its property and relationship data.</p> <p>Use this for creating a scratch copy:</p> <pre><code>let transient_clone = any_reference.clone_holon(context)?;\ntransient_clone.with_property_value(context, P::Title, \"Draft copy\".into())?;\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#b-stage_new_version-stagedreference","title":"B. <code>stage_new_version</code> \u2192 <code>StagedReference</code>","text":"<pre><code>fn stage_new_version(\n    context: &amp;dyn HolonsContextBehavior,\n    current_version: SmartReference,\n) -&gt; Result&lt;StagedReference, HolonError&gt;\n</code></pre> <p>Creates a new staged holon as an update to an existing saved holon, retaining lineage through the <code>Predecessor</code> relationship.</p> <pre><code>let staged = stage_new_version(context, saved_ref)?;\nstaged.with_property_value(context, P::Status, \"Revised\".into())?;\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#c-stage_new_from_clone-stagedreference","title":"C. <code>stage_new_from_clone</code> \u2192 <code>StagedReference</code>","text":"<pre><code>fn stage_new_from_clone(\n    context: &amp;dyn HolonsContextBehavior,\n    original_holon: HolonReference,\n    new_key: MapString,\n) -&gt; Result&lt;StagedReference, HolonError&gt;\n</code></pre> <p>Creates a new staged holon from any existing one, without lineage. Ideal for templates or derivatives.</p> <pre><code>let staged_clone = stage_new_from_clone(context, original_ref, MapString(\"copy-123\".into()))?;\n</code></pre> Operation Input Output Lineage Typical use <code>clone_holon</code> Any <code>TransientReference</code> \u274c Scratch copy <code>stage_new_version</code> <code>SmartReference</code> <code>StagedReference</code> \u2705 Update existing <code>stage_new_from_clone</code> Any <code>StagedReference</code> \u274c Derive new holon"},{"location":"mapp-dev/rust-api-developers-guide/#9-typical-flows","title":"9. Typical Flows","text":""},{"location":"mapp-dev/rust-api-developers-guide/#create-stage-commit","title":"Create \u2192 stage \u2192 commit","text":"<pre><code>let t = create_empty_transient_holon(context, MapString(\"MyType\".into()));\nt.with_property_value(context, P::Key, \"example-1\".into())?;\nlet staged = stage_new_holon_api(context, t)?;\nlet resp = commit_api(context)?;\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#fetch-saved-holon-stage-new-version","title":"Fetch saved holon \u2192 stage new version","text":"<pre><code>let smart = HolonReference::from_id(saved_id);\nlet staged = stage_new_version(context, smart)?;\nstaged.with_property_value(context, P::Title, \"updated\".into())?;\nlet resp = commit_api(context)?;\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#derive-new-staged-holon-from-existing","title":"Derive new staged holon from existing","text":"<pre><code>let staged_clone = stage_new_from_clone(context, existing_ref, MapString(\"copy-2\".into()))?;\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#10-relationships","title":"10. Relationships","text":"<ul> <li> <p>Read:   Smart holons fetch from cache (with fetch-on-miss).   Staged and transient holons use local relationship maps.</p> </li> <li> <p>Write:   Only staged or transient references can modify relationships.   Use <code>add_related_holons</code>, <code>remove_related_holons</code>, or <code>with_descriptor</code>.</p> </li> </ul>"},{"location":"mapp-dev/rust-api-developers-guide/#11-query-layer","title":"11. Query Layer","text":"<p><code>Node</code>, <code>NodeCollection</code>, and <code>QueryExpression</code> express queries over holons.</p> <pre><code>let expr = QueryExpression::property_equals(P::Title, \"Hello\".into());\nlet nodes: NodeCollection = run_query(context, expr)?;\nfor node in nodes {\n    println!(\"Found: {:?}\", node.key(context)?);\n}\n</code></pre> <p>Note: The query API is evolving. Current support includes basic property and relationship predicates.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#12-dance-builders","title":"12. Dance Builders","text":"<p><code>holon_dance_builders::*</code> provides ergonomic constructors for standard Dances:</p> <pre><code>let request = build_commit_dance_request(staged_refs);\nlet response: DanceResponse = send_dance(context, request)?;\nif response.status_code == ResponseStatusCode::Ok {\n    println!(\"Commit succeeded!\");\n}\n</code></pre> <p>Builders are the preferred way to trigger standardized Dances that cross the membrane boundary.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#13-access-control","title":"13. Access Control","text":"<p>All reference operations are validated against an <code>AccessType</code>:</p> AccessType Transient Staged Smart Read \u2705 \u2705 \u2705 Write \u2705 \u2705 \u274c Clone \u2705 \u2705 \u2705 Commit \u274c \u2705 \u274c Abandon \u2705 \u2705 \u274c <p>Unauthorized actions raise <code>HolonError::NotAccessible</code>.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#14-error-handling","title":"14. Error Handling","text":"<p>All functions return <code>Result&lt;_, HolonError&gt;</code>. Common variants include:</p> <ul> <li><code>NotAccessible</code> \u2013 operation not permitted in this phase</li> <li><code>InvalidHolonReference</code> \u2013 bad or missing reference</li> <li><code>InvalidType</code>, <code>UnexpectedValueType</code>, <code>EmptyField</code> \u2013 schema or data errors</li> </ul> <p>Errors returned through Dances can also be mapped to <code>ResponseStatusCode</code>.</p>"},{"location":"mapp-dev/rust-api-developers-guide/#15-style-conventions","title":"15. Style &amp; Conventions","text":"<ul> <li>Use explicit suffixes (<code>*_reference</code>) for reference variables.</li> <li>When APIs expect <code>Vec&lt;HolonReference&gt;</code>, wrap explicitly:</li> </ul> <pre><code>HolonReference::Transient(transient_reference)\n</code></pre>"},{"location":"mapp-dev/rust-api-developers-guide/#16-where-to-look","title":"16. Where to Look","text":"<ul> <li>Prelude: <code>holons_prelude::prelude</code></li> <li>Context behavior: <code>reference_layer/context_behavior.rs</code></li> <li>Operations API: <code>reference_layer/holon_operations_api.rs</code></li> <li>Reference traits and types: <code>reference_layer/holon_reference.rs</code>, <code>readable_holon.rs</code>, <code>writable_holon.rs</code>, <code>staged_reference.rs</code>, <code>transient_reference.rs</code></li> <li>Access and state: <code>core_shared_objects/holon/state.rs</code></li> <li>Dance builders: <code>holon_dance_builders</code></li> <li>Query layer: <code>reference_layer/query_api.rs</code></li> </ul>"},{"location":"mapp-dev/rust-api-developers-guide/#17-evolving-areas","title":"17. Evolving Areas","text":"<ul> <li>Validation runs primarily at commit.</li> <li>Fluent chaining (<code>&amp;Self</code>) is being standardized in setters.</li> <li>The query API will expand to richer predicates.</li> <li>Additional Dances (Loader, Validation) will reuse the same reference layer interface.</li> </ul>"},{"location":"mapp-dev/tags_to_memes/","title":"\ud83e\udde0 From Tags to Memes: A Deep Reframing of Tagging in the Memetic Activation Platform (MAP)","text":""},{"location":"mapp-dev/tags_to_memes/#abstract","title":"Abstract","text":"<p>Tagging has long been used to annotate, organize, and discover content in digital environments. Most systems treat tags as flat strings \u2014 simple labels applied to objects \u2014 with minimal structure or semantic depth. The Memetic Activation Platform (MAP) introduces a new model that reimagines tagging as a memetic act, embedded in a rich and evolving semantic graph.</p> <p>In MAP, a tag is a Meme in role \u2014 an object-based conceptual unit participating in a <code>CLASSIFIES</code> relationship. Tags are not a special type, but an expression of memetic function. This shift enables tags to evolve from lightweight associations into richly connected nodes of meaning \u2014 or, in some cases, be reinterpreted as references to non-memetic Holons such as books, people, or organizations.</p> <p>This document situates MAP\u2019s approach within the broader landscape of tagging systems \u2014 from folksonomies and controlled vocabularies to semantic web ontologies \u2014 and highlights how it advances the state of the art.</p>"},{"location":"mapp-dev/tags_to_memes/#1-introduction","title":"1. Introduction","text":"<p>In platforms from Flickr to Twitter to Notion, tagging plays a key role in organizing content. Yet most implementations suffer from common limitations:</p> <ul> <li>Tags are strings, not concepts.</li> <li>No distinction between roles (e.g., topic vs. person vs. action).</li> <li>Little to no governance or semantic disambiguation.</li> <li>Limited pathways for tag evolution or refinement.</li> </ul> <p>MAP addresses these issues by grounding tags in its core memetic ontology. Every tag is a Meme \u2014 a semantic entity \u2014 and tagging is a type of relationship that can be upgraded, refined, or superseded over time.</p>"},{"location":"mapp-dev/tags_to_memes/#2-key-principle-tagging-is-a-role-not-a-type","title":"2. Key Principle: Tagging Is a Role, Not a Type","text":"<p>In MAP:</p> <ul> <li>Any Meme can act as a tag by participating in a <code>CLASSIFIES \u2192 Holon</code> relationship.</li> <li>There is no special \u201cTag\u201d type \u2014 tagging is a function of relationship semantics.</li> </ul> <p>This means:</p> <ul> <li>Tags retain the full expressive power of Memes.</li> <li>The same Meme can classify many Holons, appear in MemeGroups, or evolve into a richly defined concept.</li> </ul> <p>\u201c#capitalism\u201d isn\u2019t a just label \u2014 it\u2019s a Meme that classifies many Holons, relates to other Memes, and can carry definitions, translations, and curated context.</p>"},{"location":"mapp-dev/tags_to_memes/#3-two-evolutionary-paths-for-tags","title":"3. Two Evolutionary Paths for Tags","text":"<p>MAP uniquely recognizes that tags do not all evolve in the same way. Two primary evolutionary pathways exist:</p>"},{"location":"mapp-dev/tags_to_memes/#a-referent-disambiguation","title":"A. Referent Disambiguation","text":"<p>Some tags are initially applied to a Holon as a rough association \u2014 but later turn out to refer to a non-memetic entity.</p> <p>Example:</p> <p><code>#emerging-world</code> is used as a tag, but we later discover it refers to a Book called Emerging World. The proper model is to create a <code>Holon(Book)</code> and connect Roger Briggs to it via <code>AUTHOR_OF</code>.</p> <p>The original tag is now either:</p> <ul> <li>Superseded (no longer needed), or</li> <li>Retained for thematic linkage (e.g., <code>#emerging-world</code> still classifies the Book or Author loosely)</li> </ul> <p>This flow highlights MAP\u2019s ability to distinguish:</p> <ul> <li>Concepts (Memes) from</li> <li>Artifacts, Agents, or Works (Vital Capital, Projects, etc.)</li> </ul>"},{"location":"mapp-dev/tags_to_memes/#b-semantic-deepening","title":"B. Semantic Deepening","text":"<p>Other tags are Memes from the start \u2014 and grow in semantic richness over time.</p> <p>Example:</p> <p><code>#capitalism</code> starts as a tag. It then gains:</p> <ul> <li>A <code>DEFINED_BY</code> link</li> <li>Related Memes (e.g., <code>#socialism</code>, <code>#market-economy</code>)</li> <li>Multilingual equivalents</li> <li>Inclusion in curated groups (e.g., \"Economic Ideologies\")</li> </ul> <p>The tag doesn\u2019t refer to something else \u2014 it is the thing, and it matures into a high-gravity node in the memetic graph.</p>"},{"location":"mapp-dev/tags_to_memes/#4-comparison-with-existing-tagging-paradigms","title":"4. Comparison with Existing Tagging Paradigms","text":"Paradigm Characteristics MAP Distinctions Folksonomy (Web 2.0) Tags are freeform strings; no semantics; bottom-up MAP supports folksonomic tagging but uses object-based Memes and typed relationships Controlled Vocabularies Curated taxonomies; predefined terms; rigid MAP allows emergent structure, but supports curation and governance over time Semantic Web Tags as URIs; typed relationships; machine-readable MAP aligns with RDF-style models but prioritizes human-centered conceptual meaning Discourse-based models Tags reflect user sensemaking; meaning is emergent MAP embraces this, while providing infrastructure for long-term semantic enrichment"},{"location":"mapp-dev/tags_to_memes/#5-implementation-highlights","title":"5. Implementation Highlights","text":""},{"location":"mapp-dev/tags_to_memes/#51-tags-as-first-class-objects","title":"5.1 Tags as First-Class Objects","text":"<ul> <li>Every tag is a <code>Meme</code>, with a unique identifier and optional metadata.</li> <li>Memes can be defined, related, grouped, translated, and governed.</li> </ul>"},{"location":"mapp-dev/tags_to_memes/#52-tag-application-as-an-event","title":"5.2 Tag Application as an Event","text":"<p>Tagging can be represented as a <code>TagApplication</code> or <code>TagAssertion</code>, which may include:</p> <ul> <li>Who applied it</li> <li>When and where</li> <li>Why or in what context</li> <li>Whether it was later superseded by a stronger relationship</li> </ul>"},{"location":"mapp-dev/tags_to_memes/#53-multi-layered-meaning","title":"5.3 Multi-layered Meaning","text":"<p>A single Meme can:</p> <ul> <li>Function as a tag (<code>CLASSIFIES</code>)</li> <li>Be defined (<code>DEFINED_BY</code>)</li> <li>Be related (<code>RELATED_TO</code>, <code>CONTRASTS_WITH</code>)</li> <li>Exist in curated <code>MemeGroups</code> or <code>TagSets</code></li> <li>Be governed in <code>StewardedMemePools</code></li> </ul>"},{"location":"mapp-dev/tags_to_memes/#54-ui-and-ux-opportunities","title":"5.4 UI and UX Opportunities","text":"<ul> <li>Show semantic weight of tags (e.g., enriched vs. raw)</li> <li>Suggest upgrades (\u201cWould you like to mark this person as author of that book?\u201d)</li> <li>Offer tag disambiguation when multiple referents are likely</li> </ul>"},{"location":"mapp-dev/tags_to_memes/#6-why-this-matters","title":"6. Why This Matters","text":"<p>MAP\u2019s approach addresses long-standing challenges in tagging systems:</p> Challenge MAP's Answer Tags lack meaning Tags are Memes: semantically enrichable objects Tags are misapplied Disambiguation allows for correction and clarification Tags can't evolve Tags can deepen into structured, governed knowledge units Tagging is chaotic/brittle MAP supports emergent order and structured refinement <p>This model enables semantic infrastructure that can grow organically, integrating the best of folksonomy, controlled vocabularies, and ontology-based knowledge systems.</p>"},{"location":"mapp-dev/tags_to_memes/#7-conclusion","title":"7. Conclusion","text":"<p>MAP reframes tagging as a memetic function, not a flat annotation. By treating tags as Memes-in-role and allowing them to evolve \u2014 either toward deeper meaning or clearer referents \u2014 MAP bridges the gap between human conceptual creativity and formal semantic integrity.</p> <p>It doesn't just let people tag things \u2014 it lets meaning itself grow.</p>"},{"location":"mapp-dev/tags_to_memes/#8-future-directions","title":"8. Future Directions","text":"<ul> <li>Development of <code>TagApplication</code> schema</li> <li>Semantic weight scoring models</li> <li>UI/UX patterns for tag promotion and disambiguation</li> <li>Stewardship workflows for meme governance</li> <li>Alignment with broader memetic knowledge commons initiatives</li> </ul>"},{"location":"mapp-dev/trust-channel/","title":"\ud83e\ude70 We-Space Trust Channels in Action","text":""},{"location":"mapp-dev/trust-channel/#how-map-enforces-sovereignty-privacy-and-agreement-integrity","title":"How MAP Enforces Sovereignty, Privacy, and Agreement Integrity","text":"<p>This document uses the life-cycle of a DanceRequest to illustrate a deeper story: how the We-Space application layer and Trust Channel services in MAP protect data sovereignty and enforce agreements in a fully decentralized architecture.</p>"},{"location":"mapp-dev/trust-channel/#why-this-matters","title":"\ud83c\udfaf Why This Matters","text":"<p>The primary goals of the We-Space and its Trust Channels are:</p> <ol> <li> <p>Sovereignty and Privacy Without Central Servers    MAP Agents never need to trust a central authority with their data. All routing, validation, and exchange happens peer-to-peer, with no central custody of private information.</p> </li> <li> <p>Infrastructure-Level Security and Governance Enforcement    Authentication, authorization, cryptographic security, and privacy enforcement are built into MAP\u2019s infrastructure layer. This means application developers:</p> </li> <li>Don\u2019t have to implement security protocols themselves</li> <li>Can rely on consistent adherence to the signed promises in Agreements</li> <li>Work with validated, decrypted, role-checked requests \u2014 already safe to act upon</li> </ol> <p>By handling these steps before a request reaches an application\u2019s logic, the MAP ensures consistency, trust, and interoperability across the entire ecosystem.</p>"},{"location":"mapp-dev/trust-channel/#inbound-flow-envelopes-and-membrane-functions","title":"\ud83d\udce5 Inbound Flow: Envelopes and Membrane Functions","text":"<p>Every inbound DanceRequest travels through the We-Space membrane in a layered sequence of envelopes. Each envelope contains the information needed for the membrane function at that stage. The envelopes do not \u201cdo\u201d the work themselves \u2014 the Trust Channel functions act on the envelope\u2019s contents.</p>"},{"location":"mapp-dev/trust-channel/#1-transport-envelope-routing-function","title":"1. Transport Envelope \u2192 Routing Function","text":"<p>Envelope contains:</p> <ul> <li><code>agreement_id</code> \u2014 identifies governing Agreement</li> <li><code>sender_id</code> \u2014 request originator</li> <li><code>recipient_id</code> \u2014 intended receiver</li> <li><code>message_type = DanceRequest</code></li> </ul> <p>Function performed: </p> <p>The We-Space messaging infrastructure reads this metadata to select the allowed protocol (per Agreement) and route the message to the recipient\u2019s membrane \u2014 without exposing any payload contents.</p>"},{"location":"mapp-dev/trust-channel/#2-authentication-envelope-identity-verification-function","title":"2. Authentication Envelope \u2192 Identity Verification Function","text":"<p>Envelope contains:</p> <ul> <li>Cryptographic signature over the hash of the encrypted payload</li> </ul> <p>Function performed:</p> <p>The Trust Channel fetches the sender\u2019s public key from the Agreement and verifies: - The signature matches the payload hash - The sender is an authorized Agreement participant</p> <p>This step proves authenticity before any decryption occurs.</p>"},{"location":"mapp-dev/trust-channel/#3-encryption-envelope-confidentiality-function","title":"3. Encryption Envelope \u2192 Confidentiality Function","text":"<p>Envelope contains: - Payload encrypted with the recipient\u2019s public key</p> <p>Function performed:</p> <p>The recipient\u2019s membrane decrypts the payload with its private key.  This ensures that even though transport and routing may cross multiple peers, only the final recipient can read the request.</p>"},{"location":"mapp-dev/trust-channel/#4-authorization-envelope-permission-check-function","title":"4. Authorization Envelope \u2192 Permission Check Function","text":"<p>Envelope contains: - Full <code>DanceRequest</code> - Target <code>Dance</code> - Agent roles - Parameters, thresholds, and timing</p> <p>Function performed: Agreement rules are applied to ensure: - The requester\u2019s role is permitted to invoke this Dance - The role pairing is valid under the Agreement - All scope and timing conditions are met</p>"},{"location":"mapp-dev/trust-channel/#5-execution-context-dispatch-function","title":"5. Execution Context \u2192 Dispatch Function","text":"<p>Function performed: Once validated, the We-Space hands the request to the recipient\u2019s I-Space. Here, the MAP Choreographer invokes the Dance. If part of a DanceFlow, subsequent steps are dispatched automatically.</p>"},{"location":"mapp-dev/trust-channel/#outbound-flow-layering-the-response","title":"\ud83d\udce4 Outbound Flow: Layering the Response","text":"<p>Outbound processing mirrors inbound, ensuring the response leaves the membrane as securely and intentionally as the request entered.</p>"},{"location":"mapp-dev/trust-channel/#1-payload-creation-function","title":"1. Payload \u2192 Creation Function","text":"<p>The application logic in the I-Space generates the raw <code>DanceResponse</code>.</p>"},{"location":"mapp-dev/trust-channel/#2-exfiltration-envelope-outbound-authorization-function","title":"2. Exfiltration Envelope \u2192 Outbound Authorization Function","text":"<p>Function performed: Filters response content against Agreement terms, type-level access policies, and trust thresholds before anything leaves the membrane.</p>"},{"location":"mapp-dev/trust-channel/#3-encryption-envelope-confidentiality-function_1","title":"3. Encryption Envelope \u2192 Confidentiality Function","text":"<p>Response is encrypted with the requester\u2019s public key so only they can read it.</p>"},{"location":"mapp-dev/trust-channel/#4-authentication-envelope-integrity-verification-function","title":"4. Authentication Envelope \u2192 Integrity Verification Function","text":"<p>Encrypted response is signed with the responder\u2019s private key to prove origin and integrity.</p>"},{"location":"mapp-dev/trust-channel/#5-transport-envelope-routing-function","title":"5. Transport Envelope \u2192 Routing Function","text":"<p>Routing metadata is wrapped around the response and the Trust Channel selects the allowed protocol for delivery.</p>"},{"location":"mapp-dev/trust-channel/#why-this-is-a-big-deal-for-developers","title":"\ud83e\udde0 Why This is a Big Deal for Developers","text":"<p>Because the We-Space application services and Trust Channel stack do all of this before a request reaches app logic, developers can: - Assume incoming requests are authentic, authorized, and within scope - Skip building custom cryptographic or trust enforcement layers - Focus entirely on the business logic of the Dance itself</p> <p>At the same time, the MAP ensures uniform adherence to Agreements, so every response is also vetted, encrypted, and signed before leaving the agent\u2019s control.</p> <p>In short: The We-Space and Trust Channels are sovereignty-preserving service layers. They are the reason MAP can operate fully decentralized without central servers \u2014 and why MAP apps can remain secure, interoperable, and trust-aligned by default.</p>"},{"location":"shared/glossary/","title":"\ud83e\uddfe Glossary","text":"<p>This glossary defines key concepts and terms used throughout the MAP architecture and narrative framework. Terms are listed alphabetically. Multiple definitions are included where distinctions emerged between narrative threads.</p>"},{"location":"shared/glossary/#agent","title":"Agent","text":"<p>An Agent is any entity capable of sensing and responding to its environment. It may be biological (e.g., a person, whale, or tree), technical (e.g., a computing process), or social (e.g., a family, cooperative, or commons).</p> <ul> <li>Every Agent has a unique identity and a corresponding I-Space \u2014 a private AgentSpace that houses its LifeCode, Data Grove, and core affordances. </li> <li>Agents can make offers and accept offers made by others to form Agreements.</li> </ul> <p>Agents are expressed as Holons that belong to one or more AgentSpaces. Every Agent belongs to the Exosphere and typically one or more additional AgentSpaces.</p>"},{"location":"shared/glossary/#agentspace","title":"AgentSpace","text":"<p>An AgentSpace is a membrane-bound social space where Agents interact, co-create, and participate in regenerative value flows. It is simultaneously:</p> <ul> <li>A HolonSpace \u2014 stewarding both Agents and Holons</li> <li>A container for knowledge, relationships, and shared governance</li> <li>A venue for Offers, Agreements, Promises, and visualization</li> </ul> <p>Every AgentSpace has its own LifeCode, and every interaction between Agents happens within an AgentSpace.</p> <p>\u26a0\ufe0f Not every AgentSpace is itself an Agent (i.e., not all are Social Organisms), but some  AgentSpaces, once sufficiently coherent and governed, may themselves become Agents \u2014 emergent wholes acting at a higher level of the holarchy.</p>"},{"location":"shared/glossary/#agreement","title":"Agreement","text":"<p>An Agreement is created from an Offer when agents have accepted all of the mandatory roles of the Offer. An Agreement may instantiate its own Agreement-Based AgentSpace which becomes the interaction venue for activities governed by that agreement.</p>"},{"location":"shared/glossary/#agreement-based-agentspace","title":"Agreement-Based AgentSpace","text":"<p>An Agreement-Based AgentSpace is a bounded interaction context that emerges when an Offer is accepted and an Agreement is formed.</p> <p>It includes: - All participating Agents - A LifeCode derived from the shared promises and intent of the Agreement - A scoped Data Grove of relevant Holons and references - The governance and coordination logic encoded in the Agreement, including optional roles for verification, mediation, or escalation</p> <p>While agreements may expire, be revoked, or become inactive, the AgentSpace itself \u2014 like all entities in the MAP \u2014 is immutable and persistent. Its history, structure, and prior interactions remain verifiable and accessible, preserving both accountability and lineage.</p> <p>An Agreement-Based AgentSpace is the sovereign membrane where promises take form, interactions unfold, and trust-based coordination becomes possible \u2014 with a cryptographically assured memory.</p>"},{"location":"shared/glossary/#choreographer","title":"Choreographer","text":"<p>The Choreographer is the MAP\u2019s native coordination engine. It manages the invocation and sequencing of modular dances across agents, spaces, and roles using declarative Dance Flows. </p> <p>Each dance performs a single task and emits a completion signal. The Choreographer listens for these signals and, based on the active flow specification and local context, invokes the next appropriate step. By keeping sequencing logic outside of individual dances, MAP enables complex behaviors to be composed from simple, intelligible parts.</p>"},{"location":"shared/glossary/#commoning","title":"Commoning","text":"<p>Commoning is the ongoing social process through which people collaboratively create, steward, and sustain shared resources (i.e., Vital Capitals) and relationships. At its core, commoning is a relational, participatory, and adaptive practice that reclaims shared power in managing the conditions of life. It is not just a structure, but a way of being and doing together.</p> <p>Commoning emerges outside of \u2014 and often in resistance to \u2014 market and state logics, cultivating trust, reciprocity, and long-term ecological and social flourishing. The lived practice of mutual care, collective governance, and cultural co-creation is what enables a commons to thrive.</p> <p>\u201cCommoning is a verb. It\u2019s about the social practices and cultural traditions that people devise to manage shared resources in fair, inclusive, and sustainable ways.\u201d  \u2014 David Bollier, \u201cThink Like a Commoner\u201d (2014)</p> <p>\u201cThere is no commons without commoning.\u201d \u2014 Peter Linebaugh, \u201cThe Magna Carta Manifesto\u201d (2008)</p>"},{"location":"shared/glossary/#commons","title":"Commons","text":"<p>A Commons is a social system for the long-term stewardship of Vital Capital that preserves shared values and community identity. A self-organized system by which communities manage vital capital (both depletable and replenishable) with minimal or no reliance on the Market or State. In the MAP, a commons is represented by an Agent Space whose  LifeCode conveys its community values, join membrane, and governance model.</p>"},{"location":"shared/glossary/#dahn","title":"DAHN (Dynamic Adaptive Holon Navigator)","text":"<p>A personalized, dynamic interface layer for exploring the MAP holon graph. DAHN empowers each agent to shape their own experience \u2014 not just by choosing settings, but by composing the very way information is seen, explored, and interacted with.</p> <p>Rather than each app imposing its own interface, DAHN provides a coherent visual and interaction layer across all Mapps. This coherence is achieved through dynamic selection of visualizers \u2014 modular components contributed by HX designers to the federated Visualizer Commons.</p> <p>DAHN embodies the MAP design philosophy: putting agents at the center of their digital experience, enabling expressive, adaptable, and trustable interfaces that evolve with collective and individual needs.</p>"},{"location":"shared/glossary/#dance","title":"Dance","text":"<p>A Dance is a named, invocable action that a Holon can perform or participate in \u2014 such as querying data, initiating a service, accepting an offer, or responding to a relationship.</p> <p>In MAP, dances represent affordances \u2014 the ways a Holon can be interacted with \u2014 but the term affordance felt overly technical and lacked poetic resonance.</p> <p>So we coined the term Dance.</p> <p>Why Dance?</p> <ul> <li>Because dances are relational \u2014 they involve interaction, timing, rhythm, consent.</li> <li>Because they convey graceful interdependence, not mechanical execution.</li> <li>Because in MAP, even technical operations are wrapped in patterns of trust, meaning, and flow.</li> </ul> <p>Dances are defined through the MAP Uniform API, where each <code>DanceRequest</code> expresses: - Who is dancing (the Holon) - What dance is being performed - With what input parameters - Under what conditions</p> <p>And the <code>DanceResponse</code> returns: - The result of the dance - A set of next possible dances based on the current state of the system</p> <p>A Dance is not just a function call \u2014 it's a structured act of agency within a living graph of relationship and meaning.</p>"},{"location":"shared/glossary/#dance-flow","title":"Dance Flow","text":"<p>A Dance Flow is a named, context-aware sequence of individual dances that collectively coordinate a process across agents, promises, or Agent Spaces.</p> <p>Each dance within the flow performs a discrete task or role and emits a signal upon completion. The MAP Choreographer responds to these signals by invoking the next appropriate dance in the flow, guided by shared agreements and contextual conditions.</p> <p>Key Characteristics: - Composable: Built from modular, reusable dances. - Declarative: Specifies what should unfold, not how each dance works internally. - Membrane-aware: Executes within or across Agent Spaces while respecting boundaries and permissions. - Promise-aligned: Flows often reflect and reinforce explicit promises among participants.</p> <p>Purpose: Dance Flows enable complex behaviors to emerge through the orchestration of simple, intelligible steps \u2014 making collaborative processes legible, adaptable, and agency-respecting.</p> <p>Related Concepts: \u2192 Dance, Choreographer, Promise Weave, Agent Space</p>"},{"location":"shared/glossary/#dance-interface-protocol","title":"Dance Interface Protocol","text":"<p>The Dance Interface Protocol is the universal invocation protocol in the MAP. It replaces traditional REST or RPC calls with a more expressive, memetic, and composable request model.</p> <p>Every Holon exposes available Dances depending on its current state and context.</p>"},{"location":"shared/glossary/#dancerequest","title":"DanceRequest","text":"<p>A DanceRequest is a Holon-encoded invocation of a Dance. It tells a Holon what is being requested \u2014 and under what terms.</p> <p>Each <code>DanceRequest</code> contains: - The ID of the Holon being danced with - The name of the Dance being invoked - A RequestBody \u2014 including input parameters, context, and initiating agent identity - (Optionally) an associated Agreement that governs the terms of the interaction</p> <p>Like all things in the MAP, the DanceRequest is itself a Holon \u2014 with its own type descriptor, provenance, access policy, and potential for visual representation.</p> <p>DanceRequests can be created by: - Human users interacting through DAHN  - Other Holons (e.g., service Holons triggering dances) - External systems interfacing through the MAP Uniform API</p> <p>A <code>DanceRequest</code> is a memetically and permissionally aware act of intent \u2014 a moment of coordinated agency within a shared graph.</p>"},{"location":"shared/glossary/#danceresponse","title":"DanceResponse","text":"<p>A DanceResponse is the result of performing a Dance. It includes not only the outcome of the request but also the forward affordances \u2014 what the Holon now makes possible.</p> <p>Each <code>DanceResponse</code> includes: - A ResponseBody \u2014 containing results, messages, or new Holons - A list of next available Dances \u2014 HATEOAS-style descriptors of follow-up actions - Provenance metadata and optional diagnostics - Links to updated state, derived Agreements, or resulting relationships</p> <p>Like the <code>DanceRequest</code>, the <code>DanceResponse</code> is a fully self-describing Holon and can be visualized, shared, or referenced by other components of the MAP.</p> <p>A <code>DanceResponse</code> is not just a return value \u2014 it\u2019s the moment-by-moment emergence of possibility in a living graph of consent and flow.</p>"},{"location":"shared/glossary/#data-grove","title":"Data Grove","text":"<p>A Data Grove is the sovereign, Holochain-based data storage area. Each AgentSpace has its own private Data Grove.  All of the mapps that are imported into an Agent Space store their information in the Data Grove of that Space.</p>"},{"location":"shared/glossary/#echo","title":"Echo","text":"<p>An Echo is a signed affirmation of a Promise made by another Agent, issued by an agent who chooses to align with that promise.</p> <p>Echoes serve as memetic endorsements\u2014reinforcing, repeating, and extending the trustworthiness of a promise in a given AgentSpace or across spaces.</p> <p>An Echo is:</p> <ul> <li>A verbatim reference to an existing Promise, not a reinterpretation</li> <li>A social trust gesture\u2014binding the echoing agent\u2019s reputation to the original claim</li> <li>A signal of observability\u2014often grounded in direct experience, shared context, or role-based verification</li> <li>A building block of memetic trust networks, used to evaluate promises, inform Agreements, and govern access or delegation</li> </ul> <p>Echoes may carry optional metadata such as echo weight, reasoning, or contextual scope (e.g., \u201cwithin this space only\u201d).</p> <p>\u2733\ufe0f Echoes are foundational to MAP\u2019s distributed trust model\u2014allowing agents to construct verifiable, socially-scaffolded identity and reputation without centralized authorities.</p>"},{"location":"shared/glossary/#echo-weight","title":"Echo Weight","text":"<p>An Echo Weight is an optional indicator attached to an Echo, expressing the echoing Agent\u2019s degree of confidence, verification, or proximity to the original Promise.</p> <p>Echo Weights enable more nuanced interpretation of social signals by:</p> <ul> <li>Differentiating firsthand from secondhand endorsements</li> <li>Informing access decisions, Agreement thresholds, and trust scores</li> <li>Supporting evaluative logic in AgentSpaces and across social holarchies</li> </ul> <p>Weights may be numeric (e.g., 0.9), categorical (e.g., \u201cstrong,\u201d \u201clight\u201d), or policy-defined by a GroupAgent.</p> <p>\u2733\ufe0f While optional, Echo Weights help MAP spaces distinguish between weak support and strong verification\u2014without requiring rigid central scoring systems.</p>"},{"location":"shared/glossary/#exosphere","title":"Exosphere","text":"<p>The Exosphere is the outermost, most inclusive AgentSpace in the MAP. It includes all Agents by default and serves as the lowest-threshold interaction venue across the entire platform.</p> <p>The Exosphere is:</p> <ul> <li>Non-governed (aside from platform-level rules)</li> <li>High-reach, low-trust</li> <li>The place where initial Offers may be surfaced to broad audiences</li> </ul> <p>It is not a commons or Social Organism \u2014 it is a shared membrane of visibility.</p>"},{"location":"shared/glossary/#governance-scaffold","title":"Governance Scaffold","text":"<p>A Governance Scaffold is a modular structure of roles, rules, and processes that guides how coordination and decision-making unfold within an AgentSpace.</p> <p>Rather than imposing a fixed governance model, a governance scaffold provides lightweight, composable affordances that can evolve alongside the needs and context of the space. These scaffolds are often memetically sourced from the Global Meme Pool, where patterns like sociocracy, holacracy, liquid democracy, or bespoke cultural traditions can be adapted and instantiated.</p> <p>Governance scaffolds define: - Who has voice and agency - How decisions are made and validated - What roles exist and how they are assigned or rotated - How conflicts are mediated or escalated</p> <p>They can be: - Hard-coded into Agreements - Expressed as Memeplexes in the Meme Pool - Referenced dynamically during Dance Flows</p> <p>\ud83e\udde9 Governance scaffolds are to governance what protocols are to software: flexible, interoperable building blocks that support resilient, adaptive coordination.</p> <p>See also: AgentSpace, LifeCode, Agreement, Meme Pool</p>"},{"location":"shared/glossary/#holon","title":"Holon","text":"<p>A Holon is the foundational unit of structure, meaning, and interaction in the MAP.</p> <p>Every object in the MAP \u2014 whether it\u2019s a piece of content, an Agent, a relationship, a service, or a visual element \u2014 is encoded as a self-describing, active Holon or HolonRelationship.</p>"},{"location":"shared/glossary/#self-describing","title":"\u2727 Self-Describing","text":"<p>A Holon contains within itself everything needed to interpret and interact with it. When you encounter a Holon \u201cin the wild,\u201d you can ask:</p> <ul> <li> <p>What properties do you have?   What are your current values for those properties?</p> </li> <li> <p>What types of relationships do you participate in?   To what other Holons are you related via those relationships?</p> </li> <li> <p>Through what visualizations can I view and interact with you?   Holons reference one or more Visualizers from the commons, allowing fully customizable rendering and interaction \u2014 from list views to immersive spatial experiences.</p> </li> <li> <p>What types of data access are permitted?   Holons carry their own access policies, provenance signatures, and licensing terms \u2014 enabling granular, trustable permissioning.</p> </li> </ul>"},{"location":"shared/glossary/#active","title":"\u2727 Active","text":"<p>Holons aren\u2019t just data \u2014 being active means holons can do stuff... they offer affordances.</p> <p>Every Holon can declare the Dances it is capable of performing \u2014 actions that can be invoked via the MAP Uniform API. These may include:</p> <ul> <li>Responding to queries</li> <li>Invoking relationships</li> <li>Triggering services</li> <li>Participating in negotiations, offers, or agreements</li> </ul> <p>In this way, Holons are not passive records, but sovereign, interactive knowledge actors that make up the living substrate of the MAP.</p> <p>A Holon is not just a piece of data \u2014 it is a meaningful, permissioned, expressive agent of action in a graph of relationships. It sees, responds, and evolves.</p>"},{"location":"shared/glossary/#holonspace","title":"HolonSpace","text":"<p>A HolonSpace is the foundational data container in the MAP, equivalent to an AgentSpace. While the term highlights its function as a steward of Holons, in MAP narratives, the two terms are generally treated as synonymous.</p>"},{"location":"shared/glossary/#i-space","title":"I-Space","text":"<p>An I-Space is an AgentSpace viewed from the interior perspective \u2014 focusing on internal structure, properties, intentions, and affordances of an Agent.</p> <p>Every Agent has an I-Space. For persons, this is often referred to as a Personal I-Space, but not all I-Spaces are personal.</p> <p>See also: We-Space</p>"},{"location":"shared/glossary/#join-membrane","title":"Join Membrane","text":"<p>The set of rules defined by an AgentSpace's Life Code that govern adding new members of the Agent Space.</p>"},{"location":"shared/glossary/#lifecode","title":"LifeCode","text":"<p>A LifeCode (also known as a Memetic Signature) is the values-and-identity encoding of an Agent, AgentSpace, Offer or Agreement. It defines:</p> <ul> <li>Aspirational purpose</li> <li>Memetic values and ethics</li> <li>Governance expectations</li> <li>Membership criteria</li> <li>Expressed Promises</li> </ul> <p>The LifeCode is the symbolic \"membrane\" of an AgentSpace and plays a foundational role in trust-based interaction.</p>"},{"location":"shared/glossary/#meme","title":"Meme","text":"<p>A Meme is a pattern, story, value, or shared practice that carries meaning and can be passed from one person or group to another.</p> <p>In the MAP, a meme could be a community ritual, a traditional teaching, a way of solving problems, a decision-making method, a symbol, or even a sacred story. Some memes are old and passed down through generations. Others are new, shared in conversation, taught in workshops, or built into tools and agreements.</p> <p>What matters is not just where a meme comes from \u2014 but that it helps people live together with intention, take action, or share understanding.</p> <p>Memes travel in many ways. Some are copied, some are taught, some are woven into daily life. In MAP, we honor all of these. Whether a meme is passed in a ceremony, a drawing, a document, or a song \u2014 it becomes part of our living culture when people put it into use.</p> <p>Memes are gathered into Meme Pools, where they can be shared, adapted, and stewarded with care \u2014 so that wisdom from one place can grow in another, without losing its roots.</p> <p>See also: Meme Pool, Vital Capital, LifeCode</p>"},{"location":"shared/glossary/#meme-technical","title":"Meme (technical)","text":"<p>A Meme is a structured unit of cultural meaning that can be defined, expressed, enacted, and evolved by Agents.</p> <p>In the MAP, a meme may take many forms \u2014 including values, principles, protocols, schemas, profiles, practices, rituals, governance models, economic models, or other cultural structures that guide interaction and meaning-making. Every meme is modular, stewardable, and context-aware.</p> <p>In the MAP, memes are not just viral ideas \u2014 they are the living infrastructure of cultural evolution.</p> <p>MAP extends Richard Dawkins\u2019 original definition \u2014 which emphasized replication through imitation \u2014 to include agentic enactment, contextual re-use, and memetic evolution. Memes may spread via imitation (per Dawkins), but also through instruction, documentation, or embedded use in systems and agreements. What defines a meme is not just how it spreads, but that it encodes actionable meaning and can be activated across diverse contexts.</p> <p>Memes are replicable and selectable: they persist through evolutionary dynamics, where their relevance and effectiveness are tested in lived experience. In this way, MAP supports not just cultural transmission, but the iterative refinement and ecological adaptation of its memetic commons.</p> <p>Epistemic rigor \u2014 such as practices rooted in the scientific method \u2014 can strengthen the fidelity and resilience of a meme by making it easier to reproduce, test, and refine across contexts. However, epistemic rigor is neither the sole pathway to replicability nor a universal standard: many memes in MAP draw from spiritual traditions, embodied practices, or lived experience that offer their own forms of coherence, relevance, and transmission.</p> <p>Memes can be classified by:</p> <ul> <li>Type (e.g. atomic meme, schema, protocol, visualizer)</li> <li>Category (e.g. governance, economics, learning, identity)</li> <li>Functional structure (e.g. memeplex, memefamily)</li> </ul> <p>Every Meme in MAP is a form of Vital Capital, and is stewarded within one or more Meme Pools.</p> <p>See also: Meme Pool, Vital Capital, LifeCode</p>"},{"location":"shared/glossary/#meme-pool","title":"Meme Pool","text":"<p>A Meme Pool is a collection of memes together with the agents and governance processes that steward them. In other words, a Meme Pool is a Commons.</p>"},{"location":"shared/glossary/#memetic-signature","title":"Memetic Signature","text":"<p>Synonym for LifeCode. Refers to the expressive encoding of an Agent\u2019s identity, values, and memetic alignment.</p>"},{"location":"shared/glossary/#observability","title":"Observability","text":"<p>Observability describes the degree to which a Promise can be independently verified by other Agents within a given AgentSpace.</p> <p>Every Promise has an implicit or explicit observability profile, which may be:</p> <ul> <li>Direct \u2014 fulfillment is visible to others (e.g., a submitted file, a public action)</li> <li>Indirect \u2014 fulfillment is verifiable through roles, logs, or trusted intermediaries</li> <li>Unobservable \u2014 fulfillment is private or unverifiable (e.g., internal state, intentions)</li> </ul> <p>Spaces may define Observability Profiles that specify the kinds of promises they accept, echo, or require in Agreements.</p> <p>\u2733\ufe0f Observability governs the memetic legibility of a promise\u2014what others can trust, echo, or build upon.</p>"},{"location":"shared/glossary/#offer","title":"Offer","text":"<p>An Offer is a proposed bundle of Promises, expressing both:</p> <ul> <li>What the offering Agent is willing to do or provide</li> <li>What reciprocal Promises it expects in return</li> </ul> <p>Offers are shared into specific AgentSpaces (e.g., the Exosphere or a Social Organism) and may result in Agreements.</p>"},{"location":"shared/glossary/#offer-type","title":"Offer Type","text":"<p>An Offer Type is a reusable template or pattern that defines the structure, roles, conditions, and expectations for a class of Offers in the MAP.</p> <p>Offer Types allow communities and Agents to create Offers with shared semantics and validated structure. Each Offer Type is a Meme \u2014 discoverable, remixable, and stewarded in the Global Meme Pool.</p> <p>Key properties of an Offer Type may include: - A named purpose or intent (e.g., \u201cTimebank Exchange\u201d, \u201cMicrogrant Application\u201d, \u201cCommons Stewardship Invitation\u201d) - The required and optional roles (e.g., Initiator, Contributor, Verifier) - Preconditions and fulfillment criteria - Common reciprocity patterns (e.g., \u201coffer of service in exchange for learning\u201d)</p> <p>By standardizing structure while remaining adaptable, Offer Types reduce friction and ambiguity in peer coordination, and enable the creation of Agreements that are intelligible across diverse contexts.</p> <p>\ud83d\udce6 An Offer Type is a memetic design pattern for regenerative coordination \u2014 shaping how value is proposed, negotiated, and enacted.</p> <p>See also: Offer, Agreement, Meme, Meme Pool</p>"},{"location":"shared/glossary/#promise","title":"Promise","text":"<p>A Promise is a voluntary, sovereign commitment made by one Agent. It is the atomic unit of value coordination within MAP.</p> <p>Promises may be formal (e.g., I promise to transfer 10 units of water in exchange for 5 units of labor) or informal (e.g., I promise to show up with care and attention).</p> <p>All Agreements are built from bundles of Promises.</p>"},{"location":"shared/glossary/#service","title":"Service","text":"<p>Services support the flow and transformation of vital capitals to/from other agents for mutual benefit. Services are the focus of Offers, Agreements, and Service Invocations.</p>"},{"location":"shared/glossary/#service-invocation","title":"Service Invocation","text":"<p>A request to an offering agent to perform a requested service within the context of an active agreement.</p>"},{"location":"shared/glossary/#social-organism","title":"Social Organism","text":"<p>A Social Organism is an AgentSpace that has developed enough internal coherence, governance capacity, and memetic identity to act as an Agent in its own right\u2014a Holon one level up.</p> <p>Unlike the default Exosphere, which includes all agents by default and lacks any collective governance, a Social Organism is formed intentionally. It may emerge from one or more Agreement-Based AgentSpaces and evolve into an agentic identity through extensions to its LifeCode.</p> <p>A key property of Social Organisms\u2014described by Ken Wilber as Social Holons<sup>1</sup>\u2014is that membership is non-exclusive. That is, an individual agent can participate in multiple Social Organisms at once. This contrasts with Biological Holons (e.g., cells or mitochondria), whose parts typically belong to a single organism. Social Holons reflect the fluid, overlapping, and context-dependent nature of social identity and affiliation.</p> <p>Social Organisms are not merely large groups\u2014they are living holons: capable of acting, adapting, evolving, and participating in higher-order Social Organisms themselves. A canonical example is a corporation\u2014a persistent, governance-equipped AgentSpace that can form agreements and delegate authority to sub-agents.</p> <p>Other examples might include co-ops, intentional communities, DAOs, or bioregional networks.</p> <p>See also: AgentSpace, Exosphere, LifeCode, Agreement, Agent, Holon</p>"},{"location":"shared/glossary/#stewardship","title":"Stewardship","text":"<p>In the MAP, stewardship replaces \"ownership\" to describe the relationship between an AgentSpace and the Holons it is responsible for. Each Holon is stewarded by exactly one AgentSpace, though it may be referenced in many.</p> <p>Stewardship emphasizes care, consent, and accountability.</p>"},{"location":"shared/glossary/#uniform-api","title":"Uniform API","text":"<p>The Uniform API is the singular interface through which all interactions with the MAP take place. It is based on the metaphor of the Dance, framing every invocation \u2014 from data queries to service calls \u2014 as a shared, consensual interaction.</p> <p>At its core is the <code>dance()</code> function, which accepts a <code>DanceRequest</code> and returns a <code>DanceResponse</code>.</p> <ul> <li>The DanceRequest specifies:</li> <li>The Holon (or relationship) initiating the Dance</li> <li>Parameters for the action (e.g., queries, inputs, filters)</li> <li> <p>Optionally, an OpenCypher query \u2014 enabling expressive graph traversal and transformation</p> </li> <li> <p>The DanceResponse returns:</p> </li> <li>Results from the invocation (e.g., data, confirmation, computation)</li> <li>Updated state where appropriate</li> <li>Additional <code>DanceRequest</code> options (HATEOAS-style), revealing the next set of affordances available in the current state</li> </ul> <p>Because the MAP is knowledge-graph native, all interactions \u2014 including service calls, interface rendering, and value flows \u2014 are expressible as Dances across a dynamic graph of Holons.</p> <p>The Uniform API means every Holon interaction is symmetric, discoverable, and composable \u2014 turning the MAP into a danceable language of consent, action, and agency.</p>"},{"location":"shared/glossary/#vital-capital","title":"Vital Capital","text":"<p>A core MAP holon type representing the diverse forms of value that can flow between Agents \u2014 including knowledge, care, trust, materials, attention, and more. Vital Capital is what flows as a result of service invocations and fulfilled Promises. While not inherently scarce or commodified, each Vital Capital holon is definable, describable, and context-aware. When under the stewardship of a particular Agent, it may be treated as an Asset. The concept draws from multiple sources, including Context-Based Sustainability (McElroy), the Metacurrency Project (which defines wealth as \"the capacity to meet the needs of a living system\"), and the 8 Forms of Capital in permaculture theory.</p> <p>The MAP concept of Vital Capital refers to the many forms of value \u2014 not just financial \u2014 that flow through MAP Agreements. These include:</p> <p>draws heavily on the work around Context-Based Sustainability (see citation below) </p> Capital Type Description Natural Capital Ecosystem services, land, water, air, biodiversity Human Capital Skills, labor, knowledge, health, attention Social Capital Trust, reputation, relationships, group cohesion Cultural Capital Stories, rituals, symbols, traditions, identity Built Capital Tools, infrastructure, digital systems, physical assets Financial Capital Currency, tokens, credit, investments Experiential Capital Aesthetic, emotional, and lived experiences Memetic Capital Values, beliefs, narratives, memetic signatures Temporal Capital Time, availability, scheduling of attention or actions Spiritual Capital Purpose, presence, connection to meaning (optional but supported dimension) <ul> <li>Social capital</li> <li>Ecological contributions</li> <li>Attention, care, and creativity</li> <li>Knowledge and memetic resources</li> </ul> <p>Vital capital flows are explicitly tracked via Promises and Agreements.</p> <p>For more information: see  McElroy, M. W. (2008). Social Footprints: Measuring the Social Sustainability Performance of Organizations. Middlebury: Center for Sustainable Innovation. https://www.sustainableinnovation.org ResearchGate PDF</p>"},{"location":"shared/glossary/#visualizer","title":"Visualizer","text":"<p>A Visualizer is a Holon that describes how another Holon should be rendered and interacted with \u2014 in 2D, 3D, text, graph, gallery, immersive environment, or any other format.</p> <p>Visualizers are contributed to the Visualizer Commons and selected at runtime by DAHN based on: - The type of Holon - The preferences of the Agent viewing it - The popularity and contextual fit of available visualizers</p> <p>Every Holon can reference one or more Visualizers, allowing radically different renderings for different contexts \u2014 from dashboards to immersive journeys.</p> <p>A Visualizer is not just a UI component \u2014 it is a semantic lens, a votable style, and a participatory aesthetic contribution to the shared experience of the MAP. </p>"},{"location":"shared/glossary/#visualizer-commons","title":"Visualizer Commons","text":"<p>A federated network of stewarded sets of Visualizers. DAHN dynamically selects and configures visualizers from the Visualizer Commons to present and enable interaction with the MAP' self-describing, active Holons</p>"},{"location":"shared/glossary/#we-space","title":"We-Space","text":"<p>A We-Space is an AgentSpace viewed from the exterior perspective \u2014 how it participates within larger structures, how it exposes interfaces and affordances, and how it relates to other spaces.</p> <p>A Social Organism is always a We-Space, but not all We-Spaces are yet Social Organisms.</p> <ol> <li> <p>Wilber, Ken. Sex, Ecology, Spirituality: The Spirit of Evolution. Shambhala Publications, 1995.\u00a0\u21a9</p> </li> </ol>"}]}