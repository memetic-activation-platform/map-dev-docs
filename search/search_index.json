{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MAP Developer Documentation","text":"<p>Welcome to the MAP Developer Documentation.</p> <p>This site is intended to support developers, schema authors, and community contributors who are building with the MAP Type System and holonic data structures.</p> <p>MAP is designed to be:</p> <ul> <li>Self-describing \u2014 every type is a holon</li> <li>Composable \u2014 types and schemas can be extended without breaking compatibility</li> <li>Federated \u2014 schema evolution happens across a network of independently defined but interoperable types</li> </ul>"},{"location":"#getting-started","title":"\ud83e\udded Getting Started","text":"<p>This documentation is still evolving. It's initial focus is on a JSON File Authoring Guide as part of the MAP Holon Data Loader. </p> <ul> <li>Explore the type system design in the MAP wiki</li> <li>Review example import files in <code>schemas/</code> if available</li> <li>Watch this space for developer guides and schema authoring tips</li> </ul> <p>We\u2019ll be adding more structured guides and references as the project grows. Contributions are welcome.</p> <p>For licensing info, see LICENSE.md.</p>"},{"location":"core/dances-design/","title":"MAP Design Spec: DanceType \u2194 DanceImplementation Binding &amp; Dispatch","text":"<p>Status: Draft Author: MAP Core / Steve Melville Intent: Specify how types declare dances, how implementations are bound, and how the host dispatches calls safely and dynamically. Scope: Type system extensions, import format, governance/validation, runtime dispatch, security, caching, and compatibility with existing MAP/Holochain patterns.</p>"},{"location":"core/dances-design/#0-foundations-assumptions","title":"0) Foundations &amp; Assumptions","text":"<ol> <li> <p>Self\u2011describing types</p> <ul> <li>All MAP types are holons described by TypeDescriptor holons.</li> <li><code>InstanceProperties</code> and <code>InstanceRelationships</code> declare expectations for instances.</li> <li>The metaschema already supports declaring new PropertyTypes and RelationshipTypes.</li> </ul> </li> <li> <p>Holon identity &amp; immutability</p> <ul> <li>Instances are immutable; newer versions create new holons.</li> <li>References are stable and do not \u201cgo stale\u201d; caches can safely retain instances until memory pressure requires eviction.</li> </ul> </li> <li> <p>Import format conventions</p> <ul> <li>Holon JSON import files use the unified <code>holons</code> array, with relationships and properties defined on each holon.</li> <li><code>$ref</code> resolution is strict within the provided file set (no implicit global context).</li> <li><code>key</code> MUST appear before <code>type</code> in each holon definition.</li> <li><code>type</code> is shorthand for a <code>DescribedBy</code> relationship and should not be duplicated unless rules require exact match.</li> </ul> </li> <li> <p>Key rules</p> <ul> <li>Some holons are keyed, some are keyless, per existing KeyRuleType semantics.</li> <li>Enum Variant holons are keyed and top-level (not embedded).</li> </ul> </li> <li> <p>Governance membranes</p> <ul> <li>Spaces (I\u2011Spaces / We\u2011Spaces) enforce admission, attestation, and activation policies for new descriptors and modules.</li> <li>Provenance and attestations are recorded as holons and/or signatures on content hashes.</li> </ul> </li> <li> <p>Runtime execution</p> <ul> <li>Host supports WASM/WASI execution and may optionally support:<ul> <li>Process (spawned executable with stream protocol),</li> <li>Rust dylib (FFI with stable ABI),</li> <li>Builtin (host-registered functions).</li> </ul> </li> <li>Single-threaded isolation for WASM execution is assumed.</li> <li>Modules are addressed by content hash and may be fetched via membrane-authorized channels.</li> </ul> </li> </ol>"},{"location":"core/dances-design/#1-conceptual-model","title":"1) Conceptual Model","text":"<p>At its heart, the MAP type system implements a dynamic dispatch model in which every type \u2014 not just <code>HolonType</code> \u2014 can advertise the behaviors it supports via fine-grained dispatch tables. These tables are essentially the per-type registries of \u201cwhat this type can do,\u201d expressed as relationships from the type descriptor to a set of DanceTypes.</p> <p>In our new terminology, we\u2019re formalizing this as:</p> <pre><code>&lt;TypeDescriptor&gt; \u2014AFFORDS\u2192 &lt;DanceType&gt;\n</code></pre>"},{"location":"core/dances-design/#dynamic-dispatch-tables","title":"Dynamic Dispatch Tables","text":"<ul> <li> <p>One per type:   Every <code>TypeDescriptor</code> can have its own dispatch table \u2014 a set of <code>Affords</code> relationships that point to the <code>DanceType</code>s it supports. This allows dispatch to be as fine-grained as needed: even closely related types can differ in the set of dances they afford.</p> </li> <li> <p>Any type can afford dances:   We don\u2019t limit affordances to <code>HolonType</code>s. <code>ValueType</code>s, <code>RelationshipType</code>s, even <code>DanceType</code>s themselves can have <code>Affords</code> links to other dances, enabling compositional and meta-level behaviors.</p> </li> <li> <p>Behavior resolution:   When the system receives a <code>DanceRequest</code> for a specific target, the dispatch mechanism:</p> <ol> <li>Identifies the type of the target holon.</li> <li>Looks up that type\u2019s <code>Affords</code> relationships.</li> <li>Matches the requested dance against the list.</li> <li>Routes execution to the handler bound to that dance for this type.</li> </ol> </li> </ul>"},{"location":"core/dances-design/#affordances-as-first-class-relationships","title":"Affordances as First-Class Relationships","text":"<ul> <li><code>Affords</code> is itself a RelationshipType holon (like all type descriptors in MAP).</li> <li>Concrete instances of <code>Affords</code> are smartlinks between a type and a dance type.</li> <li>Because <code>Affords</code> is part of the schema, it can carry metadata \u2014 version constraints, capability conditions, or even parameter hints \u2014 making affordances declarative, inspectable, and extensible.</li> </ul>"},{"location":"core/dances-design/#why-this-matters","title":"Why This Matters","text":"<ul> <li>Granularity: Instead of large, monolithic capability declarations, we get fine-grained, composable affordances that can evolve per type.</li> <li>Flexibility: Adding a new dance is a matter of creating a <code>DanceType</code> and linking it via <code>Affords</code>; no core code needs changing for schema-driven dispatch.</li> <li>Uniformity: All affordances are modeled the same way, whether they\u2019re about creating a holon, validating a property, or triggering a real-world workflow.</li> <li>Extensibility: The dispatch model is naturally open to extension in downstream schemas or spaces without schema rewrites \u2014 just add new <code>Affords</code> links.</li> </ul>"},{"location":"core/dances-design/#2-newupdated-descriptors-relationships","title":"2) New/Updated Descriptors &amp; Relationships","text":""},{"location":"core/dances-design/#21-descriptors","title":"2.1 Descriptors","text":"<ul> <li> <p>DanceType (HolonType, abstract)   The DanceType defines the interface for a single dance. This includes the dance name (by convention, this should be a verb) (e.g., <code>Render</code>, <code>Validate</code>, <code>SyncOut</code>).</p> <ul> <li>Properties (examples): <code>display_name</code>, <code>description</code>, <code>abi_id</code> (optional if polymorphic).</li> <li>Relationships:</li> <li><code>Request</code> -- to a HolonType that bundles the input parameters to the DanceRequest. </li> </ul> </li> <li> <p>DanceImplementation (Holon)   A concrete binding of a <code>DanceType</code> for a specific <code>TypeDescriptor</code>.</p> <ul> <li>Properties (required unless noted):<ul> <li><code>Engine</code> (Enum): <code>WasmWasi</code> | <code>Process</code> | <code>RustDylib</code> | <code>Builtin</code></li> <li><code>ModuleRef</code> (String): content address (e.g., <code>b3:\u2026</code> multihash, URL with hash, capability address)</li> <li><code>Entrypoint</code> (String): export/function name (WASM symbol, FFI symbol, command name)</li> <li><code>ABI</code> (String): stable ABI signature id the host supports (e.g., <code>map.dance.v1</code>)</li> <li><code>Version</code> (String): semver or content-hash pin</li> <li><code>CompatRange</code> (String, optional): semver range allowed</li> <li><code>ActivationStatus</code> (Enum): <code>proposed</code> | <code>active</code> | <code>disabled</code></li> <li><code>Scope</code> (Enum): <code>Builtin</code> | <code>SchemaDefault</code> | <code>SpaceOverride</code></li> <li><code>ModuleHash</code> (String): cryptographic hash of the content (if not implicit in ModuleRef)</li> </ul> </li> <li>Relationships:</li> <li><code>DanceType</code>-&gt;DanceType -- The Dance being implemented.</li> <li><code>AffordingType</code>-&gt; TypeDescriptor (?) the type on whose behalf this dance is being implemented</li> </ul> </li> <li> <p>(optional) DanceParameterSchema (Holon)   Describes structured inputs/outputs for ABI validation.</p> </li> </ul>"},{"location":"core/dances-design/#22-relationships","title":"2.2 Relationships","text":"<ul> <li> <p>Affords (DeclaredRelationshipType) <code>(TypeDescriptor) -[Affords]-&gt; (DanceType)</code>   Declares that instances of the type afford/expose the dance.</p> </li> <li> <p>ImplementsDance (DeclaredRelationshipType) <code>(TypeDescriptor) -[ImplementsDance]-&gt; (DanceImplementation)</code>   Binds concrete implementations available to the dispatcher.</p> </li> <li> <p>ForDance (DeclaredRelationshipType) <code>(DanceImplementation) -[ForDance]-&gt; (DanceType)</code>   The interface this implementation satisfies.</p> </li> <li> <p>(optional) ParametersSchema (DeclaredRelationshipType) <code>(DanceType) -[ParametersSchema]-&gt; (DanceParameterSchema)</code></p> </li> </ul> <p>All descriptors follow the foundational rule: <code>type: \"#TypeDescriptor\"</code> with <code>Extends</code> pointing at the appropriate meta-type, and they adopt MAP import conventions (key before type, unified relationships block, etc.).</p>"},{"location":"core/dances-design/#3-import-file-additions-examples-illustrative","title":"3) Import File Additions &amp; Examples (Illustrative)","text":"<p>Note: Examples are schematic and omit boilerplate. Use your established keys/type shorthands and naming patterns. (No code fences here; the following is raw markdown text with indentation.)</p> <p>Example A: Declaring a DanceType and parameter schema - key: <code>Render.DanceType</code> - type: <code>#DanceType</code> - properties: <code>display_name=\"Render\"</code>, <code>description=\"Produce a representation\"</code> - relationships: <code>ParametersSchema -&gt; #Render.Params.Schema</code> (optional)</p> <p>Example B: A TypeDescriptor that supports and implements a dance - key: <code>BookType.TypeDescriptor</code> - type: <code>#TypeDescriptor</code> - relationships:     - <code>Affords -&gt; #Render.DanceType</code>     - <code>ImplementsDance -&gt; #BookType.Render.WasmImpl</code> (below)</p> <p>Example C: A DanceImplementation bound to <code>BookType</code> for <code>Render</code> - key: <code>BookType.Render.WasmImpl</code> - type: <code>#DanceImplementation</code> - properties:     - <code>Engine=\"WasmWasi\"</code>     - <code>ModuleRef=\"b3hash:Qm...\"</code>     - <code>Entrypoint=\"render_book\"</code>     - <code>ABI=\"map.dance.v1\"</code>     - <code>Version=\"1.2.0\"</code>     - <code>CompatRange=\"^1.0.0\"</code>     - <code>ActivationStatus=\"active\"</code>     - <code>Scope=\"SchemaDefault\"</code>     - <code>ModuleHash=\"sha256:abcd...\"</code> - relationships:     - <code>ForDance -&gt; #Render.DanceType</code></p> <p>Space-scoped override A We\u2011Space can introduce a second implementation with <code>Scope=\"SpaceOverride\"</code> and <code>ActivationStatus=\"active\"</code>. Resolution rules (Section 5) ensure overrides take precedence without mutating the schema default.</p>"},{"location":"core/dances-design/#4-abi-application-binary-interface","title":"4) ABI (Application Binary Interface)","text":""},{"location":"core/dances-design/#41-goals","title":"4.1 Goals","text":"<ul> <li>Stable contract between host and implementation irrespective of engine.</li> <li>Enable content-addressed modules to be swapped/upgraded safely.</li> <li>Keep functions stateless and deterministic (inputs \u2192 outputs), with side effects routed through explicit host calls (capability-gated).</li> </ul>"},{"location":"core/dances-design/#42-core-shape-mapdancev1","title":"4.2 Core shape (<code>map.dance.v1</code>)","text":"<ul> <li>Inputs<ul> <li><code>dance_type_id</code> (ref)</li> <li><code>type_descriptor_id</code> (ref)</li> <li><code>instance_refs</code> (list of holon ids or $ref proxies)</li> <li><code>parameters</code> (bytes or canonical JSON/CBOR)</li> <li><code>context</code> (agent id, space id, capability token, call chain, clock)</li> </ul> </li> <li>Outputs<ul> <li><code>status</code> (OK | Error(code))</li> <li><code>result</code> (bytes or canonical JSON/CBOR)</li> <li><code>emitted_events</code> (optional; for telemetry)</li> </ul> </li> <li>Host imports<ul> <li><code>holon_fetch(id)</code> \u2192 bytes</li> <li><code>relationship_query(query)</code> \u2192 ids</li> <li><code>attest(proof)</code> \u2192 receipt</li> <li><code>emit(event)</code> \u2192 ack</li> <li>(All host functions are capability-gated and audited.)</li> </ul> </li> </ul>"},{"location":"core/dances-design/#43-serialization-determinism","title":"4.3 Serialization &amp; determinism","text":"<ul> <li>Canonical encoding (CBOR or JSON Canonical Form).</li> <li>No host clock access except via provided <code>context</code>.</li> <li>No ambient I/O except via host-imported capabilities.</li> </ul>"},{"location":"core/dances-design/#5-dispatch-algorithm-host","title":"5) Dispatch Algorithm (Host)","text":"<p>Given a request <code>(T, D, ctx)</code>:</p> <ol> <li>Affordance check: Ensure <code>T Affords D</code>; otherwise fail with <code>NotSupported(T,D)</code>.</li> <li>Collect candidates: <code>C = { impl | T ImplementsDance impl \u2227 impl ForDance = D \u2227 impl ActivationStatus=active }</code>.</li> <li>Select binding (deterministic precedence):<ul> <li>Prefer <code>Scope=\"SpaceOverride\"</code> in <code>ctx.space</code> &gt; <code>SchemaDefault</code> &gt; <code>Builtin</code>.</li> <li>Prefer exact <code>Version</code> pin &gt; satisfied <code>CompatRange</code> &gt; latest compatible by semver.</li> <li>Optional: apply policy filter (agent role, license/flowshare rules, allowlist).</li> <li>If multiple remain, choose lexicographically by <code>(Version, ModuleHash)</code> or policy-defined tiebreaker.</li> </ul> </li> <li>Load &amp; cache:<ul> <li>Fetch module by <code>ModuleRef</code> (verify <code>ModuleHash</code>, signatures, provenance).</li> <li>Instantiate per engine; reuse cached instance if ABI/spec allows (see lifecycle).</li> </ul> </li> <li>Invoke:<ul> <li>Marshal inputs to ABI.</li> <li>Call <code>Entrypoint</code>.</li> <li>Enforce time/memory fuel limits and capability quotas.</li> </ul> </li> <li>Validate &amp; return:<ul> <li>Check ABI contract on outputs.</li> <li>Apply membrane \u201cexfiltration filter\u201d (response validation &amp; redaction as promised).</li> <li>Return <code>DanceResponse</code>.</li> </ul> </li> </ol> <p>Error handling: Produce structured errors: <code>NotSupported</code>, <code>NoActiveImpl</code>, <code>ABIIncompatible</code>, <code>ModuleFetchFailed</code>, <code>SignatureInvalid</code>, <code>PolicyDenied</code>, <code>EngineError</code>, <code>Timeout</code>, <code>MemoryLimit</code>, <code>ResultValidationFailed</code>.</p>"},{"location":"core/dances-design/#6-module-lifecycle-caching-eviction","title":"6) Module Lifecycle, Caching, Eviction","text":"<ul> <li>Cache keys: <code>(Engine, ModuleHash, ABI)</code>; instance-specific caches may include <code>(SpaceId)</code> when overrides alter host imports.</li> <li>Warm: LRU or LFU for frequently used modules; prewarm on activation if policy allows.</li> <li>Evict: Under memory pressure, evict least-recently-used; keep provenance index regardless.</li> <li>Isolation: WASM instances single-threaded; no shared mutable state across invocations.</li> <li>Pure-function posture: Dances are stateless; all state arrives as inputs or accessed through explicit host capabilities.</li> </ul>"},{"location":"core/dances-design/#7-governance-licensing-and-flowshare-hooks","title":"7) Governance, Licensing, and Flowshare Hooks","text":"<ul> <li> <p>Activation workflow:</p> <ul> <li>A <code>DanceImplementation</code> arrives with <code>ActivationStatus=\"proposed\"</code>.</li> <li>Membrane policy may require two-key attest (Steward of <code>T</code> + Space Admin) and automated checks (hash, signature, license).</li> <li>On success, flip to <code>active</code> (space-scoped or schema default).</li> </ul> </li> <li> <p>Flowshare attachment:</p> <ul> <li>Implementations/Types may declare a ValueFlowPolicy holon that expresses revenue/reciprocity terms (e.g., non-extractive use-permitted; reciprocal flowshare when vital capitals exchanged).</li> <li>Dispatcher records <code>(T, D, impl_id)</code> in telemetry for downstream settlement.</li> </ul> </li> <li> <p>Non-extractive licensing posture:</p> <ul> <li>Free use in non-commercial/gift contexts remains unaffected.</li> <li>When reciprocal value flows are detected (per policy integration), contributors participate according to warrants/agreements.</li> </ul> </li> </ul>"},{"location":"core/dances-design/#8-validation-rules-import-time-and-activation-time","title":"8) Validation Rules (Import-time and Activation-time)","text":"<p>Import-time (schema-level) - <code>supports-impl-consistency</code>: If <code>(T ImplementsDance impl)</code> then <code>(impl ForDance) \u2208 (T Affords)</code>. Error otherwise. - <code>single-active-impl</code>: For each <code>(T, D, scope)</code>, at most one <code>ActivationStatus=\"active\"</code>. Error otherwise. - <code>engine-fields-required</code>: Property presence by engine:     - <code>WasmWasi</code> \u21d2 <code>ModuleRef</code>, <code>Entrypoint</code>, <code>ABI</code>     - <code>Process</code> \u21d2 <code>ModuleRef</code>, <code>ABI</code> (and <code>Entrypoint</code> if multiplexed)     - <code>RustDylib</code> \u21d2 <code>ModuleRef</code>, <code>Entrypoint</code>, <code>ABI</code>     - <code>Builtin</code> \u21d2 <code>Entrypoint</code>, <code>ABI</code> - <code>instance-type-kind-matches-extended-meta-type-name</code>: Continue enforcing your existing meta/type-kind rules.</p> <p>Activation-time (runtime policy) - <code>abi-compat</code>: <code>impl.ABI</code> supported by host. - <code>module-integrity</code>: <code>ModuleHash</code> matches fetched bytes; signatures and attestations verified. - <code>policy-eligibility</code>: Space policy permits activation (governance roles, allowlists, flowshare acceptance). - <code>parameters-schema-match</code> (optional): <code>parameters</code> conform to <code>DanceParameterSchema</code>.</p>"},{"location":"core/dances-design/#9-security-provenance-and-audit","title":"9) Security, Provenance, and Audit","text":"<ul> <li>Content addressing: <code>ModuleRef</code> and <code>ModuleHash</code> cryptographically bind code identity.</li> <li>Signatures: Contributors sign module manifests; Spaces countersign activation.</li> <li>Reproducibility: Prefer reproducible builds; include build-info holon.</li> <li>Supply chain: Maintain provenance graph from source \u2192 build \u2192 artifact; store as holons.</li> <li>Audit trail: Every dispatch logs <code>(timestamp, agent, space, T, D, impl_id, module_hash, status, duration, fuel_used)</code>.</li> </ul>"},{"location":"core/dances-design/#10-engines-host-integrations","title":"10) Engines &amp; Host Integrations","text":"<ul> <li> <p>WASM/WASI (preferred):</p> <ul> <li>Deterministic execution with resource caps (fuel, memory).</li> <li>Host imports expose capability-guarded functions.</li> <li>Versioned ABI adapters <code>map.dance.v1</code>, <code>v2</code>, \u2026 allow evolution.</li> </ul> </li> <li> <p>Process:</p> <ul> <li>IPC over stdin/stdout with canonical envelope.</li> <li>Strong isolation; higher overhead.</li> </ul> </li> <li> <p>Rust dylib:</p> <ul> <li>Stable FFI surface identical to ABI envelope.</li> <li>Platform coupling; reserved for controlled deployments.</li> </ul> </li> <li> <p>Builtin:</p> <ul> <li>Registered host handlers for critical hot paths.</li> <li>Still declared as <code>DanceImplementation</code> with <code>Scope=\"Builtin\"</code> for traceability.</li> </ul> </li> </ul>"},{"location":"core/dances-design/#11-performance-considerations","title":"11) Performance Considerations","text":"<ul> <li>Cold-start: Prewarm frequently-used <code>(T,D)</code> in background when allowed by policy.</li> <li>Batching: Allow vectorized invocation (<code>Render</code> for many instances) when ABI supports arrays.</li> <li>Streaming: Optional chunked results for large outputs (with exfiltration filter applied per chunk).</li> <li>Caching: Separate caches for (a) holons (state), (b) modules (code), (c) relationships (indices).</li> </ul>"},{"location":"core/dances-design/#12-compatibility-migration","title":"12) Compatibility &amp; Migration","text":"<ul> <li> <p>Holochain conductor:</p> <ul> <li>Aligns with zome WASM loading (single-threaded WASM, dynamic dispatch).</li> <li>This spec generalizes beyond zomes by attaching behavior to any TypeDescriptor.</li> </ul> </li> <li> <p>Incremental rollout:     1) Introduce descriptors/relationships with validators, no runtime usage.     2) Implement host-side dispatcher with <code>WasmWasi</code> only.     3) Add governance activation path and telemetry.     4) Add overrides (<code>SpaceOverride</code>) and precedence rules.     5) (Optional) Add <code>Process</code>/<code>RustDylib</code> engines.</p> </li> </ul>"},{"location":"core/dances-design/#13-open-questions","title":"13) Open Questions","text":"<ul> <li>ABI evolution: Which fields must be strictly stable vs. adapter-shimmed?</li> <li>Parameter schemas: Standardize on JSON Schema vs. ValueType holons?</li> <li>Multi-impl composition: Should a dance support ordered pipelines/compose-many?</li> <li>Sandbox capability surface: Minimum viable host imports per dance category?</li> <li>Flowshare metering: Best trigger points to detect \u201creciprocal value\u201d reliably and fairly?</li> </ul>"},{"location":"core/dances-design/#14-acceptance-criteria","title":"14) Acceptance Criteria","text":"<ul> <li>Types can declare <code>Affords</code> and bind one or more <code>DanceImplementation</code>s.</li> <li>Host can resolve <code>(T,D)</code> to an active implementation deterministically and execute it through <code>map.dance.v1</code> ABI.</li> <li>Import-time validators catch misconfigurations; activation-time checks enforce integrity and policy.</li> <li>Telemetry records every dispatch with provenance, enabling governance and (optional) flowshare settlement.</li> </ul>"},{"location":"core/dances-design/#15-risks-mitigations","title":"15) Risks &amp; Mitigations","text":"<ul> <li>Complexity creep \u2192 Keep dispatcher minimal; push variability to data + ABI.</li> <li>Security of third-party code \u2192 Content hashing, signatures, sandboxing, capability gates, resource caps.</li> <li>Version skew \u2192 Semantic ranges with explicit pins; strong precedence rules; safe fallbacks.</li> <li>Memory growth \u2192 LRU/LFU eviction, per-engine instance pooling, prewarm limits.</li> </ul>"},{"location":"core/dances-design/#16-next-steps","title":"16) Next Steps","text":"<ol> <li>Add new descriptors and relationships to the metaschema &amp; base-core import files.</li> <li>Implement import-time validation rules listed above.</li> <li>Define <code>map.dance.v1</code> ABI envelope precisely (field names, encoding, error codes).</li> <li>Build the host dispatcher (WASM/WASI path first) + module cache.</li> <li>Implement governance activation flows and attest capture.</li> <li>Instrument telemetry and add audit holons.</li> <li>Ship example: <code>BookType</code> with <code>Render</code> dance (schema default) and a Space-scoped override.</li> </ol>"},{"location":"core/holon-data-loader-design-spec/","title":"MAP Holon Data Loader Design Specification (Updated)","text":"<p>The Holon Data Loader will convert holon data presented in JSON files into Holons and HolonRelationships that are staged and committed to a (single) MAP Space using existing MAP APIs. Because all MAP types (e.g., PropertyType, HolonType, RelationshipType) are themselves holons, the Holon Data Loader can be used to load TypeDescriptors just like any other data \u2014 eliminating the need for a separate type-specific loader. Input files are syntactically validated against a JSON Schema to ensure they represent well-formed holons, properties, relationships and, eventually, dances.</p> <p>Validation of imported holons and their properties and relationships against their Type Descriptors is triggered by standard Holochain validation callbacks. These callback functions, implemented in the <code>holons_integrity_zome</code> invoke shared validation functions to actually perform the validations. All Holochain dependencies are isolated in the integrity zome so that the shared validation functions have no holochain dependencies.</p> <p>If the target space does not already contain all required TypeDescriptors (e.g., BookType, title, HAS_AUTHOR), they must be included as part of the import and loaded first. Since we do not yet have deployed instances of the MAP that persist data, all types and data required for an integration Test Case must be loaded as part of the test case itself. This includes importing the MAP Schema. Thus, the test case initialization includes the following steps:</p> <ol> <li>Import MAP Meta-Schema</li> <li>Import MAP Core Schema</li> <li>Import Domain-Specific Type Descriptors (if any)</li> <li>Import Domain-Specific Data (if any)</li> </ol> <p>All four test steps use the same Holon Data Loader. Each step imports the type descriptors needed to validate the data imported in the subsequent step.</p>"},{"location":"core/holon-data-loader-design-spec/#process-overview","title":"\ud83e\udde9 Process Overview","text":"<p>The following diagram shows the Holon Data Loading process.</p> <p></p>"},{"location":"core/holon-data-loader-design-spec/#step-by-step-map-holon-data-loader-flow","title":"\ud83e\udded Step-by-Step: MAP Holon Data Loader Flow","text":"<ol> <li> <p>Define Holons in Airtable -- For now, we are using Airtable as our source of truth for data imports. A user or domain expert defines holons, properties, and relationships as rows in a spreadsheet-like interface. NOTE: This is just one option \u2014 other JSON generation methods are possible.</p> </li> <li> <p>Export CSV from Airtable -- Airtable exports the holon definitions into a CSV file, which contains structured tabular data for each holon, including properties, types, and relationships.</p> </li> <li> <p>Convert CSV to JSON -- A Jupyter Notebook (written in Python) loads the CSV file and uses the MAP Holon JSON Generator to transform the rows into JSON-formatted Holon Definitions. These definitions conform to the MAP Holon Data Loader's expected schema.</p> </li> <li> <p>Run the JSON Schema Validator -- Before loading, the generated JSON input file is validated using a JSON Schema Validator. This ensures that the file:</p> </li> <li>Is structurally valid</li> <li>Uses valid type names and relationship formats</li> </ol> <p>The validated file represents well-formed Holons, Properties, and Relationships.</p> <ol> <li> <p>Parse and Prepare Holons  -- The validated JSON is parsed into in-memory data structures. The Holon Generator builds internal <code>HolonImportSpec</code> structs from the parsed data.</p> </li> <li> <p>Invoke the Holon Data Loader -- The Holon Generator passes the structured holon definitions to the Holon Data Loader, a Rust crate. This loader:</p> </li> <li>Handles all staging and relationship resolution</li> <li> <p>Works for both instance data and TypeDescriptors</p> </li> <li> <p>(Optional) Other Data Loaders -- Other data loaders may bypass JSON entirely and produce Rust-structured holon definitions directly. These are also accepted by the Holon Data Loader pipeline.</p> </li> <li> <p>Stage Holons -- The loader performs Pass 1, where each holon is:</p> </li> <li>Assigned a local ID or temp key</li> <li>Validated for syntactic structure</li> <li> <p>Staged with its properties only (relationships deferred)</p> </li> <li> <p>Stage Relationships -- The loader performs Pass 2, resolving all deferred relationships:</p> </li> <li>References to staged holons use <code>temp_key</code></li> <li>References to saved holons use keys or HolonIds</li> <li> <p>External references resolve via space proxies</p> </li> <li> <p>Commit Holons -- All staged holons are committed into the MAP space via the <code>holons_core</code> crate. This action triggers holochain\u2019s commit lifecycle.</p> </li> <li> <p>Trigger Validation -- As part of the commit, the Holochain Conductor invokes validation actions. These hit the HolonNode Validation Hooks in the <code>holons_integrity_zome</code>. The implementation of these hook functions converts the data into \"holochain-independent\" data structures in order to invoke the shared validation functions.</p> </li> <li> <p>Run Shared Validation Logic The hooks delegate to the Shared Holons Validator, which contains:</p> </li> <li>Validation against TypeDescriptors</li> <li>Enforcement of required properties and cardinalities</li> <li>No direct Holochain dependencies \u2014 enabling reuse of these validations from holons_core without pulling in holochain and its dependencies.</li> </ol>"},{"location":"core/holon-data-loader-design-spec/#design-philosophy","title":"\ud83e\udde0 Design Philosophy","text":"Principle Description Holonic Uniformity Everything \u2014 including types \u2014 is a holon Self-Describing Types The <code>type</code> and <code>key</code> fields provide identity and classification Declarative Imports Inverse relationships and embedded holons may be expressed naturally Keyed Reference Integrity Only keyed holons may be targeted by <code>$ref</code> Two-Pass Import Enables circular references and loose ordering in authoring Minimal, Consistent Format Supports both human authoring and automated generation"},{"location":"core/holon-data-loader-design-spec/#keyed-vs-keyless-holons","title":"\ud83d\udccc Keyed vs Keyless Holons","text":"<p>MAP distinguishes two structural categories of holons:</p> Feature Keyed Holons Keyless Holons Includes <code>key</code> \u2705 Yes \u274c No Unique within space \u2705 Yes \u274c Not applicable Can be referenced via <code>$ref</code> \u2705 Yes \u274c No Must be embedded in JSON \u274c Optional \u2705 Required Can be target of declared relationship \u2705 Yes \u274c No Must declare outgoing relationship to keyed holon \u274c Optional \u2705 Required <ul> <li>Keyed holons include a stable <code>key</code> (materialized from properties) and may be referenced by other holons via <code>$ref</code>.</li> <li>Keyless holons are contextual and must be embedded as part of another holon\u2019s relationship. They must not be referenced or stand alone.</li> </ul> <p>This pattern ensures clean graph semantics, staging integrity, and simplicity for authors.</p>"},{"location":"core/holon-data-loader-design-spec/#declared-vs-inverse-relationships-in-json","title":"\ud83d\udd01 Declared vs Inverse Relationships in JSON","text":"<p>MAP represents both Declared and Inverse relationships using SmartLinks, but only Declared Relationships are:</p> <ul> <li>Explicitly defined in schemas</li> <li>Directly populated and persisted</li> </ul> <p>Inverse Relationships are: - Inferred by the system - Automatically maintained as mirrors of their declared counterparts - Not directly writable in the storage layer</p>"},{"location":"core/holon-data-loader-design-spec/#ergonomic-authoring-support","title":"\u2728 Ergonomic Authoring Support","text":"<p>To improve JSON authoring, the Holon Data Loader supports:</p> <p>\u2705 Expressing inverse relationships in JSON \u2014 which are then automatically rewritten into their declared equivalents before staging</p> <p>For example, a JSON snippet like:</p> <pre><code>{\n  \"type\": \"#Schema\",\n  \"key\": \"LibrarySchema\",\n  \"relationships\": [\n    { \"name\": \"Components\", \"target\": [{ \"$ref\": \"BookType\" }] }\n  ]\n}\n</code></pre> <p>will be rewritten internally to:</p> <pre><code>{\n  \"type\": \"#BookType\",\n  \"relationships\": [\n    { \"name\": \"ComponentOf\", \"target\": { \"$ref\": \"LibrarySchema\" } }\n  ]\n}\n</code></pre> <p>This preserves the storage model while making authoring more intuitive.</p> <p>\ud83d\uded1 Note: If both directions of a relationship pair are expressed in the same import file, the loader will raise a warning or error.</p>"},{"location":"core/holon-data-loader-design-spec/#json-import-file-structure","title":"\ud83d\udcc2 JSON Import File Structure","text":"<p>Details about JSON formatting, required fields, reference expressions (<code>$ref</code>), embedded holons, and schema validation rules have been moved to the Holon Data Loader Guide.</p> <p>See: Holon Data Loader Guide \u2013 Authoring Valid JSON Files</p>"},{"location":"core/holon-data-loader-design-spec/#validation-lifecycle","title":"\ud83d\udd0d Validation Lifecycle","text":"<p>The Holon Data Loader and MAP system use multiple layers of validation to ensure correctness, schema alignment, and safe persistence.</p>"},{"location":"core/holon-data-loader-design-spec/#1-schema-validation-pre-load","title":"1. Schema Validation (Pre-Load)","text":"<p>Before holons are even staged, input files are validated using JSON Schema:</p> <ul> <li>The loader always begins by validating imports against the <code>bootstrap-import.schema.json</code> schema. This schema ensures:<ul> <li>Holons are properly structured</li> <li>Properties are well-formed</li> <li>Relationship targets follow required structure</li> <li>No invalid reference forms are present (e.g., unkeyed <code>$ref</code> targets)</li> </ul> </li> </ul>"},{"location":"core/holon-data-loader-design-spec/#cascading-schema-validation","title":"\ud83e\uddec Cascading Schema Validation","text":"<p>After loading the MAP Meta-Schema, additional JSON Schemas can be generated automatically for downstream validation:</p> <ul> <li>Meta-Schema \u2192 Used to validate Core Type imports (e.g., PropertyType, ValueType)</li> <li>Core Schema \u2192 Used to validate Domain-Specific Schema files</li> <li>Domain Schema \u2192 Used to validate Domain-Specific Data files</li> </ul> <p>This allows every import layer to be validated against a holon-based, introspected schema, enforcing MAP type rules long before runtime.</p>"},{"location":"core/holon-data-loader-design-spec/#2-runtime-validation-post-commit","title":"2. Runtime Validation (Post-Commit)","text":"<p>After holons are committed, Holochain's Conductor orchestrates the integrity checks by invoking validation callbacks defined in the <code>map_holons_integrity</code> zome.</p> <p>\u2757 Holons do not themselves trigger validation \u2014 the request to persist a holon causes the Conductor to invoke validation logic.</p> <p>The validation callbacks: - Receive Holochain-native types like <code>Record</code>, <code>Link</code>, <code>ActionHash</code> - Convert these into MAP-native, Holochain-independent structures:     - <code>Holon</code>     - <code>HolonRelationships</code>     - <code>LocalId</code>, etc.</p> <p>These converted forms are passed to shared validation functions (in <code>holons_core</code>) that enforce:</p> <ul> <li>Required and optional property rules</li> <li>Cardinality constraints on relationships</li> <li>Reference resolution and type compatibility</li> <li>Key and relationship uniqueness</li> <li>Schema-defined constraints (e.g., min/max values, enum values, etc.)</li> </ul> <p>This design allows the same validation logic to be reused across client tools, data loaders, and runtime validation \u2014 avoiding duplication and enabling introspection.</p>"},{"location":"core/holon-data-loader-design-spec/#3-loader-level-validations","title":"3. Loader-Level Validations","text":"<p>The Holon Data Loader performs additional checks during staging:</p> <ul> <li>Ensures no inverse relationship appears more than once (after rewriting)</li> <li>Validates that all <code>$ref</code> targets resolve to keyed holons or embedded holons</li> <li>Rejects direct references to keyless holons</li> <li>Ensures that all keyless holons are:<ul> <li>Embedded as relationship targets</li> <li>The source of at least one declared relationship</li> </ul> </li> <li>Ensures that keys (when present) are unique within the load scope</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#staging-and-commit-process","title":"\ud83d\udcbe Staging and Commit Process","text":""},{"location":"core/holon-data-loader-design-spec/#pass-1-stage-holons","title":"Pass 1: Stage Holons","text":"<ul> <li>Create in-memory Holon stubs for each input</li> <li>Only properties are staged; relationships are deferred</li> <li>Holons must include <code>type</code> (and <code>key</code>, if keyed)</li> <li>Relationships are stored for Pass 2</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#pass-2-stage-relationships","title":"Pass 2: Stage Relationships","text":"<ul> <li>Resolve all <code>relationships</code> from JSON</li> <li>References are resolved by <code>$ref</code>, <code>Type:Key</code>, or embedded inline</li> <li>Inverse relationships are rewritten to their declared form</li> <li>Embedded keyless holons are inlined into source holon relationships</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#commit-and-validate","title":"Commit and Validate","text":"<ul> <li>After all holons are staged, the loader invokes <code>holons_core</code> to commit</li> <li>Holochain callbacks are triggered</li> <li>Shared validation logic enforces type rules</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#schema-loading","title":"Schema Loading","text":"<p>As noted previously, the</p> Programming Concept MAP Base Type MAP <code>type_kind</code> <code>String</code> <code>MapStringValueType</code> <code>ValueString</code> <code>bool</code> <code>MapBooleanValueType</code> <code>ValueBoolean</code> <code>i64</code> / <code>number</code> <code>MapIntegerValueType</code> <code>ValueInteger</code> <code>Vec&lt;u8&gt;</code> / base64 <code>MapBytesValueType</code> <code>ValueBytes</code> Enum (string symbol) <code>MapEnumValueType</code> <code>ValueEnum</code> Holon descriptor <code>MapHolonType</code> <code>Holon</code> Relationship descriptor <code>MapRelationshipType</code> <code>Relationship</code> Property descriptor <code>MapPropertyType</code> <code>Property</code>"},{"location":"core/holon-data-loader-design-spec/#future-enhancements","title":"\ud83d\udd2e Future Enhancements","text":"<ul> <li>Add schema-based authoring for enum types, constraint types, and complex nested holons</li> <li>Expand support for symbolic references (<code>DanceRequest</code>)</li> <li>Enhance loader validation to support contextual awareness of target schemas</li> <li>Support streaming JSON parsing for very large imports</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#summary","title":"\ud83d\udcce Summary","text":"<p>The Holon Data Loader is the universal import engine for MAP Types and Instances. It supports:</p> <ul> <li>Bootstrap loading of MAP Meta-Schema and Core Schema</li> <li>Domain-specific extension imports</li> <li>Declarative instance creation with ergonomic syntax</li> <li>Unified graph population using a two-pass process</li> <li>Rewriting of inverse relationships for intuitive JSON authoring</li> <li>Holochain-independent shared validation</li> </ul> <p>Authors and tool builders can rely on a consistent, minimal JSON format while benefiting from full MAP introspection, validation, and schema enforcement.</p> <p>See also: Holon Data Loader Guide for JSON authoring rules and examples.</p>"},{"location":"core/holon-data-loader-design-spec/#obsolete-content","title":"========== OBSOLETE CONTENT ==============","text":"<p>Everything after this point is left-over from prior versions are targeted to be deleted.</p>"},{"location":"core/holon-data-loader-design-spec/#json-file-structure","title":"\ud83d\udd0e JSON File Structure","text":"<p>A JSON import file contains two top-level keys:</p> <pre><code>{\n   \"meta\": { ... },\n   \"holons\": [ { ... }, { ... }, ... ]\n}\n</code></pre> <ul> <li><code>meta</code> contains metadata about the import (version, author, etc.).</li> <li><code>holons</code> contains the list of holons to be imported.</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#holon-structure","title":"Holon Structure","text":"<p>Each holon in the <code>holons</code> list is represented as a JSON object with the following keys:</p> <ul> <li><code>type</code> (string): Fully qualified <code>$ref</code> to the holon's type (e.g., <code>\"#MapStringValueType\"</code>). Replaces the older <code>DescribedBy</code> pattern.</li> <li><code>key</code> (optional): A unique identifier if the holon is keyed.</li> <li><code>temp_key</code> (optional): A temporary key for referencing other holons within the same import file.</li> <li><code>properties</code>: A map of property name to typed value.</li> <li><code>relationships</code>: A list of relationship objects, each containing:</li> <li><code>name</code>: Relationship name</li> <li><code>target</code>: Either a <code>$ref</code> string or an embedded holon</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#key-design-rules","title":"\ud83d\udd0e Key Design Rules","text":""},{"location":"core/holon-data-loader-design-spec/#type-implies-describedby","title":"\u2705 <code>type</code> Implies <code>DescribedBy</code>","text":"<ul> <li>Every holon must specify a <code>type</code> using <code>#Key</code> syntax.</li> <li>This replaces the need for an explicit <code>DescribedBy</code> relationship.</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#use-components-instead-of-iscomponentof","title":"\u2705 Use <code>Components</code> Instead of <code>IsComponentOf</code>","text":"<ul> <li>All imported holons are children of a <code>MapSchemaType</code> holon.</li> <li>The <code>Components</code> relationship replaces <code>IsComponentOf</code>.</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#declare-useskeyrule-for-keyed-holons","title":"\u2705 Declare <code>UsesKeyRule</code> for Keyed Holons","text":"<p>Each keyed holon must include a relationship: <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": {\n    \"type\": \"#FormatKeyRule\",\n    \"properties\": {\n      \"format\": \"$0\",\n      \"property_names\": [\"type_name\"]\n    }\n  }\n}\n</code></pre></p>"},{"location":"core/holon-data-loader-design-spec/#fully-qualified-keys-for-relationship-types","title":"\u2705 Fully Qualified Keys for Relationship Types","text":"<p>Use a <code>key</code> such as: <pre><code>(HolonType)-[DescribedBy]-&gt;(TypeDescriptor)\n</code></pre> This prevents ambiguity and supports inverse resolution.</p>"},{"location":"core/holon-data-loader-design-spec/#ref-is-the-only-reference-format","title":"\u2705 <code>$ref</code> Is the Only Reference Format","text":"<p>Reference targets in relationships must use <code>$ref</code> strings, such as: - <code>#temp-key</code> - <code>Type:Key</code> - <code>id:&lt;HolonId&gt;</code> - <code>@Proxy:Type:Key</code> - <code>ext:&lt;ProxyId&gt;:&lt;LocalId&gt;</code></p>"},{"location":"core/holon-data-loader-design-spec/#data-loader-flow","title":"\ud83d\udcca Data Loader Flow","text":"<ol> <li>Author Holons \u2013 Use Airtable or any editor</li> <li>Convert to JSON \u2013 Jupyter notebook or custom tool</li> <li>Validate \u2013 Run against JSON Schema</li> <li>Parse \u2013 Create internal <code>HolonImportSpec</code> structs</li> <li>Pass 1: Stage Holons<ul> <li>Assign temp_keys and validate shape</li> <li>Properties only; defer relationships</li> </ul> </li> <li>Pass 2: Stage Relationships<ul> <li>Resolve references using <code>$ref</code></li> </ul> </li> <li>Commit \u2013 Insert holons via <code>holons_core</code></li> <li>Validate \u2013 Trigger integrity zome and shared validators</li> </ol>"},{"location":"core/holon-data-loader-design-spec/#example-holon-with-relationships","title":"\ud83d\udd01 Example Holon with Relationships","text":"<pre><code>{\n  \"type\": \"#BookType\",\n  \"temp_key\": \"book-001\",\n  \"properties\": {\n    \"title\": { \"type\": \"#MapStringValueType\", \"value\": \"Future Primal\" }\n  },\n  \"relationships\": [\n    { \"name\": \"AUTHORED_BY\", \"target\": { \"$ref\": \"PersonType:charles-eisenstein\" } },\n    { \"name\": \"MENTORED_BY\", \"target\": { \"$ref\": \"#mentor-temp-001\" } }\n  ]\n}\n</code></pre>"},{"location":"core/holon-data-loader-design-spec/#meta-modeling-relationship-types","title":"\ud83c\udf93 Meta-Modeling: Relationship Types","text":""},{"location":"core/holon-data-loader-design-spec/#primary-vs-inverse-relationship-types","title":"\u2709\ufe0f Primary vs. Inverse Relationship Types","text":"<p>Use two types: - <code>MetaPrimaryRelationshipType</code>: explicitly declared by source - <code>MetaInverseRelationshipType</code>: inferred only</p>"},{"location":"core/holon-data-loader-design-spec/#inverse-links","title":"\ud83d\udd01 Inverse Links","text":"<p>Each relationship holon must link to its inverse using: <pre><code>{\n  \"name\": \"InverseOf\",\n  \"target\": { \"$ref\": \"#OtherRelationshipType\" }\n}\n</code></pre></p> <p>Only primary relationships are listed in <code>PRIMARY_SOURCE_FOR</code> of the source HolonType.</p>"},{"location":"core/holon-data-loader-design-spec/#key-rules-for-relationship-types","title":"\ud83d\udcc4 Key Rules for Relationship Types","text":"<pre><code>{\n  \"format\": \"($0)-[$1]-&gt;($2)\",\n  \"property_names\": [\"source_type\", \"type_name\", \"target_type\"]\n}\n</code></pre> <p>This ensures uniqueness and proper <code>$ref</code> resolution.</p>"},{"location":"core/holon-data-loader-design-spec/#validation-overview","title":"\ud83e\udd1d Validation Overview","text":"<ul> <li>Holon validation happens via Holochain callbacks</li> <li>Type validation uses shared holochain-independent logic</li> <li><code>$ref</code> entries must resolve in Pass 2 or trigger errors</li> </ul>"},{"location":"core/holon-data-loader-design-spec/#design-philosophy_1","title":"\ud83c\udf10 Design Philosophy","text":"Principle Description Holonic Uniformity Everything (types, rules, instances) is a holon Self-Describing <code>type</code> and <code>key</code> provide all descriptor info Keyed Reference Integrity No reference unless <code>key</code> or <code>temp_key</code> defined Two-Pass Import Enables circular refs and easy authoring Minimal Format Concise JSON with embedded metadata"},{"location":"core/holon-data-loader-design-spec/#next-steps","title":"\ud83d\udd2e Next Steps","text":"<ul> <li>Add section on symbolic references via <code>DanceRequest</code></li> <li>Add schema examples for EnumType, PropertyType, etc.</li> <li>Publish complete reference <code>bootstrap-import.schema.json</code></li> </ul> <p>\u2e3b</p>"},{"location":"core/i18n-design-spec/","title":"Internationalization Design Spec","text":""},{"location":"core/i18n-design-spec/#map-internationalization-localized-holons-design","title":"\ud83c\udf0d MAP Internationalization &amp; Localized Holons Design","text":"<p>Version: August 2025 Status: Rough Consensus Architecture</p>"},{"location":"core/i18n-design-spec/#1-overview","title":"1. Overview","text":"<p>MAP\u2019s internationalization (i18n) model uses fully localized holons to support multilingual content and context-specific knowledge representation. Rather than extracting localized strings into separate holons or defining a specialized type, each holon is a complete locale-specific instance of a <code>HolonType</code>.</p> <p>Localization is modeled via relationships and properties directly on the core <code>HolonType</code>, enabling consistent treatment of localized holons as first-class data entities.</p>"},{"location":"core/i18n-design-spec/#terminology-internationalization-vs-localization","title":"\ud83e\udded Terminology: Internationalization vs. Localization","text":""},{"location":"core/i18n-design-spec/#internationalization-i18n","title":"Internationalization (i18n)","text":"<p>Internationalization is the process of designing software and data models in a way that makes them adaptable to multiple languages, regions, and cultures without requiring engineering changes for each new locale.</p> <p>In the context of MAP: - Internationalization enables holons to be stored, queried, and presented in multiple languages. - It introduces structural support for locale-specific resource pools, canonical representations, and fallback logic. - It ensures that holons, their properties, and relationships can vary by locale without breaking semantic or identity integrity.</p> <p>Mnemonic: \u201cDesign once, localize many times.\u201d</p>"},{"location":"core/i18n-design-spec/#localization-l10n","title":"Localization (l10n)","text":"<p>Localization is the process of adapting data or interface elements for a specific language, region, or cultural context. This includes translating human-readable strings and may involve restructuring or adapting content to fit local norms.</p> <p>In the context of MAP: - A localized holon is a full instance of a holon whose values and relationships are resolved in the context of a particular locale. - One holon per group is designated the canonical representation, and others reference it via a <code>CanonicalRepresentation</code> relationship. - Localization includes translated display names, descriptions, and possibly locale-specific relationships (e.g. tags, categorizations).</p> <p>Mnemonic: \u201cLocalization is applying the design to a specific place and language combination.\u201d</p> <p>These two processes are complementary: - Internationalization is an architectural concern. - Localization is a content and presentation concern.</p>"},{"location":"core/i18n-design-spec/#2-key-design-decisions","title":"2. Key Design Decisions","text":"<ul> <li>\u2705 Each localized representation is a full holon of the same <code>HolonType</code>, scoped to a specific locale</li> <li>\u2705 One representation per locale, grouped via <code>CanonicalRepresentation</code> relationship</li> <li>\u2705 One holon is designated as the canonical representation using <code>is_canonical_representation = true</code></li> <li>\u2705 All other localized holons declare a <code>CanonicalRepresentation</code> link to that canonical holon</li> <li>\u2705 All properties and relationships are resolved relative to locale context</li> <li>\u2705 Locale affiliation is modeled via a <code>LocalPool</code> relationship to a <code>LocalizedResourcePool</code></li> <li>\u2705 No <code>LocalizedString</code> holons or derived <code>LocalizedHolonType</code> subtype</li> </ul>"},{"location":"core/i18n-design-spec/#3-map-internationalization-structure","title":"3. MAP Internationalization Structure","text":"<p>A <code>LocalizedResourcePool</code> groups holons by a shared <code>locale</code> (e.g., <code>en</code>, <code>fr</code>, <code>fr-CA</code>).</p> <p>Each pool is associated with a single Locale (language/region combination)</p> <p>Each localized holon must belong to one such pool via <code>Pool</code>.</p> <p></p> <p>One localized holon is designated as the canonical representation, all others are designated LocalizedRepresentations of the canonical representation and have a relationship to it.</p>"},{"location":"core/i18n-design-spec/#3-holon-localization-semantics","title":"3. Holon Localization Semantics","text":""},{"location":"core/i18n-design-spec/#31-localized-holons","title":"3.1 Localized Holons","text":"<p>Each localized holon is a complete instance of its type (e.g., <code>Book</code>, <code>Person</code>, <code>Organization</code>) with values and links tailored to a specific locale. While string properties are typically the only materialized locale-specific values, all properties and relationships are conceptually locale-relative.</p> <p>Localized holons contain:</p> <ul> <li><code>Pool</code> relationship to their (single) locale-specific <code>LocalizedResourcePool</code></li> <li><code>is_canonical_representation</code> boolean property (true only for one holon per group)</li> <li>Fully materialized string values are expressed in the regional variant of their language (e.g., French Canadian)</li> <li>Relationships are resolved by the most appropriate representation of the target holon(s), given the source holon's locale.</li> </ul> <p>Consider the following example:</p> <p></p> <p>Le Petit Prince is the canonical representation of the Livre (fr:FR) and Antoine de Saint-Exup\u00e9ry is the canonical representation of a Personne. Both belong to the Un d\u00e9p\u00f4t de ressources en fran\u00e7ais pool (as does the Livre and Personne Type Descriptors) - Optional <code>CanonicalRepresentation</code> \u2192 reference to the canonical version (required for non-canonical variants)</p>"},{"location":"core/i18n-design-spec/#32-canonical-representation","title":"3.2 Canonical Representation","text":"<ul> <li>Exactly one localized holon per group should be flagged with <code>is_canonical_representation = true</code></li> <li>Updates should always be made to the canonical holon</li> <li>Other localized holons must eventually be kept in sync via explicit update/translation flows</li> <li>Each localized holon (except the canonical one) must declare a <code>CanonicalRepresentation</code> relationship</li> </ul>"},{"location":"core/i18n-design-spec/#4-locale-affiliation","title":"4. Locale Affiliation","text":"<p>All holons are scoped to a specific locale by including:</p> <pre><code>\"relationships\": {\n  \"LocalPool\": { \"$ref\": \"LocalizedResourcePool:fr-CA\" }\n}\n</code></pre> <p>This enables: - Organized partitioning of holons by language/culture - Locale-sensitive fallback resolution - Query and navigation behaviors that adapt to user preferences</p>"},{"location":"core/i18n-design-spec/#6-cross-locale-equivalence","title":"6. Cross-Locale Equivalence","text":"<p>Localized holons are grouped semantically via:</p> <ul> <li>Shared Type and conceptual identity</li> <li>One canonical representation identified via <code>is_canonical_representation = true</code></li> <li>All others linking back to that canonical holon via <code>CanonicalRepresentation</code></li> </ul> <p>This design supports: - Consistent object identity across languages - Round-trip translation and editing workflows - Clean integration with fallback logic and search resolution</p>"},{"location":"core/i18n-design-spec/#7-locale-precedence-and-fallback","title":"7. Locale Precedence and Fallback","text":"<p>Queries and navigation are executed with a contextual <code>locale_precedence</code> stack, e.g.:</p> <pre><code>{\n  \"requested_locale\": \"fr-CA\",\n  \"fallback_locales\": [\"fr-CA\", \"fr\", \"en-CA\", \"en\"]\n}\n</code></pre> <p>Used for: - Holon resolution - Property display and value substitution - Ranking search results</p>"},{"location":"core/i18n-design-spec/#8-heterogeneous-text-search","title":"8. Heterogeneous Text Search","text":""},{"location":"core/i18n-design-spec/#81-motivation","title":"8.1 Motivation","text":"<p>Text-based search is the first step in many MAP workflows (including AI-RAG). Users should be able to query across all types of holons, e.g. \"Tom Hanks\" \u2192 <code>Person</code>, <code>Film</code>, <code>Author</code>, etc.</p>"},{"location":"core/i18n-design-spec/#82-indexing-scope","title":"8.2 Indexing Scope","text":"<p>Each localized holon is indexed based on: - Locale-tagged <code>display_name</code>, <code>description</code>, <code>type_name</code>, etc. - Any string-bearing property - Relationship labels (for guidance/navigation)</p>"},{"location":"core/i18n-design-spec/#83-search-behavior","title":"8.3 Search Behavior","text":"<ul> <li>Query is matched against all localized holons</li> <li>Locale context guides scoring and fallback</li> <li>Results are enriched with type metadata and <code>DanceLink</code>s for structured navigation</li> </ul>"},{"location":"core/i18n-design-spec/#9-dance-query-integration","title":"9. Dance &amp; Query Integration","text":""},{"location":"core/i18n-design-spec/#91-locale-context","title":"9.1 Locale Context","text":"<p>All queries execute with a <code>locale_context</code>, which influences: - Holon resolution - Relationship traversal - Search indexing and scoring</p>"},{"location":"core/i18n-design-spec/#92-dance-integration","title":"9.2 Dance Integration","text":"<ul> <li><code>DANCE(\"viewBook\")</code> resolves to the localized holon variant matching the context</li> <li><code>DANCE(\"editBook\")</code> may route to the canonical version for source-of-truth editing</li> <li>Queries do not need to manually specify locale \u2014 fallback is automatic</li> </ul>"},{"location":"core/i18n-design-spec/#10-example","title":"10. Example","text":"Locale Holon Key <code>display_name</code> <code>is_canonical_representation</code> Pool Canonical Ref en-US Book:1@en-US \"Book\" true <code>LocalizedResourcePool:en-US</code> \u2014 fr Book:1@fr \"Livre\" false <code>LocalizedResourcePool:fr</code> \u2192 Book:1@en-US fr-CA Book:1@fr-CA \"Livre\" false <code>LocalizedResourcePool:fr-CA</code> \u2192 Book:1@en-US"},{"location":"core/i18n-design-spec/#11-implementation-roadmap","title":"11. Implementation Roadmap","text":"Phase Features \u2705 MVP Canonical holons, embedded string props \u23f3 v1 Localized holons + <code>LocalPool</code> relationships \u23f3 v2 Canonical representation logic (<code>is_canonical_representation</code>, <code>CanonicalRepresentation</code>) \u23f3 v3 Locale-aware fallback resolution \u23f3 v4 Indexed multilingual search \u23f3 v5 Dance integration + canonical update tooling"},{"location":"core/i18n-design-spec/#12-open-design-questions","title":"12. Open Design Questions","text":"<ul> <li>Should canonical holons be excluded from a <code>LocalizedResourcePool</code>, or have a special <code>canonical</code> pool? NO</li> <li>Should properties like <code>is_canonical_representation</code> be enforced at the type level? NO</li> <li>How are canonical updates tracked and propagated (e.g. via translation queues)? TBD</li> <li>How should locale-specific validation be applied to ensure completeness and fidelity? TBD</li> </ul>"},{"location":"core/i18n-design-spec/#13-summary","title":"13. Summary","text":"<p>MAP\u2019s localized holon design enables a powerful, consistent, and high-performance internationalization strategy that:</p> <ul> <li>Keeps all holons in a uniform representation</li> <li>Avoids fragmentary or per-property lookup logic</li> <li>Fully supports multilingual search and navigation</li> <li>Integrates seamlessly with canonical edit flows and localization workflows</li> </ul> <p>This architecture is designed to scale with complexity while remaining intuitive and developer-friendly across all layers of the MAP platform.</p>"},{"location":"core/map-type-system-revised/","title":"MAP Type System","text":"<p>The MAP Type System provides a holonic, self-describing, and extensible foundation for representing knowledge in an agent-centric world. Every type in MAP is a holon \u2014 a versioned, queryable, and linkable unit of meaning. Every holon is, in turn, typed \u2014 grounded in a rich schema of interrelated descriptors.</p> <p>This holonic approach means:</p> <ul> <li>Types can describe types.</li> <li>Types can inherit from other types.</li> <li>Types can be extended, queried, and versioned just like data.</li> </ul> <p>The MAP Type System enables agents to: - Define their own schemas and vocabularies - Share and evolve types collaboratively - Validate, introspect, and visualize holons at runtime</p> <p></p> <p>This document introduces the architecture of the MAP Type System, structured into three foundational layers and supported by unified schema import, key rules, and introspection semantics.</p>"},{"location":"core/map-type-system-revised/#1-introduction-what-is-the-map-type-system","title":"1. Introduction: What Is the MAP Type System?","text":"<p>The MAP Type System is: - \ud83e\udde0 Self-describing \u2014 Every type is a holon, and every holon can describe itself. - \ud83e\uddf1 Compositional \u2014 Holons can be connected through typed relationships to build meaningful graphs. - \ud83d\udd0d Introspectable \u2014 Any holon can answer:   \u2192 What kind of Holon am I?   \u2192 What properties do I have?   \u2192 What relationships do I participate in? - \ud83c\udf31 Extensible \u2014 Agents can define new types without altering the core codebase.</p>"},{"location":"core/map-type-system-revised/#maps-ontology-as-data-meta-modeling-approach","title":"MAP\u2019s Ontology-as-Data Meta-Modeling Approach","text":"<p>The Memetic Activation Platform (MAP) models its entire ontology as data\u2014not as code, not as syntax-bound models, but as a fully introspectable, declarative system of holons. Every type, property, relationship, and rule in the MAP ecosystem is represented as a holon\u2014a data entity described by other data entities\u2014creating a self-describing, semantically rigorous system.</p>"},{"location":"core/map-type-system-revised/#what-it-is","title":"What It Is","text":"<ul> <li>Ontology-as-data: All type system elements (e.g. <code>BookType</code>, <code>MetaEnumValueType</code>, <code>MapStringValueType</code>) are modeled as structured data instances. These are holons described by <code>TypeDescriptor</code> holons, forming a fully reflective type graph.</li> <li>Declarative architecture: Relationships, constraints, and inheritance are declared explicitly, rather than implied by code or assumed by syntax. Examples include <code>Extends</code>, <code>InstanceProperties</code>, and <code>UsesKeyRule</code>.</li> <li>Syntax-independent: The data model is not coupled to any specific concrete syntax like OWL, LinkML, JSON Schema, or Ecore. This allows MAP to remain neutral and flexible.</li> <li>Portable and generative: Because the ontology is described entirely in data, it can be programmatically transformed into any number of target modeling formats, including OWL (RDF), Ecore, LinkML, JSON Schema, or domain-specific APIs.</li> </ul>"},{"location":"core/map-type-system-revised/#why-this-matters","title":"Why This Matters","text":"<ul> <li>Interoperability: By remaining syntax-agnostic, MAP avoids vendor lock-in and promotes compatibility across tooling ecosystems.</li> <li>Transparency and introspection: Every element of the type system is visible and inspectable\u2014users and systems can query, reason about, and validate types and their relationships using the same underlying structures.</li> <li>Extensibility: New type kinds, validation rules, or relationship semantics can be introduced declaratively without requiring changes to core code or parsers.</li> <li>Automation: The data-native structure supports auto-generation of syntax-bound schemas, documentation, forms, validators, and converters across ecosystems.</li> <li>Evolvability: Standards, formats, and tools evolve over time. By anchoring the MAP ontology in a neutral, declarative core, it remains resilient to external changes. New representations can be generated as needed, without requiring redefinition of the underlying semantics.</li> </ul>"},{"location":"core/map-type-system-revised/#a-foundation-for-federated-semantics","title":"A Foundation for Federated Semantics","text":"<p>This architecture positions MAP not just as a platform, but as a semantic engine capable of supporting fluid translation between formal modeling environments. It is particularly well-suited to decentralized systems, federated knowledge graphs, and commons-oriented technology\u2014where semantic clarity, flexibility, and sovereignty are paramount.</p>"},{"location":"core/map-type-system-revised/#2-organizing-the-map-type-system","title":"2. Organizing the MAP Type System","text":"<p>At the heart of the MAP architecture is a self-describing type system built entirely from data. The foundational building block of this system is the TypeDescriptor\u2014a holon that defines the structure, semantics, and constraints of a particular type within MAP. These TypeDescriptors describe not only data instances, but also other types, enabling a fully introspectable and evolvable modeling framework.</p> <p>A relatively small number of these type descriptors are \"built-in\" to the MAP. These provide the foundation from which an open-ended set of types can be derived.</p> <p>TypeDescriptors are grouped into schemas, which are cohesive collections of related type definitions. Each schema defines its own conceptual namespace and boundary of meaning. In turn, every schema is stewarded within a single HolonSpace, anchoring it in a governance and trust context. While a schema belongs to exactly one HolonSpace, it may be referenced by types or instances across other spaces, supporting reuse and interoperability without centralization.</p> <p>This layered organization follows a clear pattern:</p> <ul> <li>TypeDescriptors define types.</li> <li>Schemas group TypeDescriptors.</li> <li>HolonSpaces steward schemas.</li> </ul> <p>This structure allows types to evolve in well-bounded contexts while participating in broader federated semantics.</p>"},{"location":"core/map-type-system-revised/#type-kind-a-semantic-organizing-principle","title":"Type Kind: A Semantic Organizing Principle","text":"<p>Every TypeDescriptor in MAP declares a type kind\u2014a high-level classification that serves dual purposes:  1. Organizational: They help group and reason about types across schemas. All <code>Relationship</code> types, for instance, share common structural expectations and validation behavior. 2. Semantic: They convey the ontological category of the type\u2014what kind of \"thing\" it is in the MAP worldview.</p> <p>In this way, Type Kind functions as a semantic meta-tag that informs how a type is expected to behave, how it is validated, and how it can be composed within other types. While it doesn't encode structure directly (like <code>DescribedBy</code> or <code>Extends</code>), <code>type_kind</code> plays a central role in how types are declared, introspected, and extended across the system.</p>"},{"location":"core/map-type-system-revised/#complete-list-of-type-kinds","title":"$ \ud83d\udcda Complete List of Type Kinds","text":"<p>The current set of supported Type Kinds is listed in the following table. This set will continue to evolve as the MAP matures. Adding Type Kinds (e.g., adding support for a Value(Video) Type Kind) requires a new MAP release. Adding <code>TypeDescriptors</code> does not. </p> Type Kind Category Description <code>Holon</code> Structural Describes a type that classifies data-bearing holons <code>Property</code> Structural Describes a scalar property of a holon <code>Relationship</code> Structural Describes a directed link between holons <code>EnumVariant</code> Structural Describes a variant in a defined enum <code>Collection</code> Structural Describes a named group or set of holons <code>Dance</code> Behavioral Describes an interactive protocol or workflow <code>Value(String)</code> Scalar Value A scalar value based on a string <code>Value(Integer)</code> Scalar Value A scalar value based on an integer <code>Value(Boolean)</code> Scalar Value A scalar value based on a boolean <code>Value(Enum)</code> Scalar Value A scalar value selected from a known enumeration <code>Value(Bytes)</code> Scalar Value A binary value serialized as base64 <code>ValueArray(String)</code> Scalar Array An array of strings <code>ValueArray(Integer)</code> Scalar Array An array of integers <code>ValueArray(Boolean)</code> Scalar Array An array of booleans <code>ValueArray(Enum)</code> Scalar Array An array of enum values <code>ValueArray(Bytes)</code> Scalar Array An array of binary values"},{"location":"core/map-type-system-revised/#3-four-level-model","title":"3. Four-Level Model","text":"<p>To support full self-description, schema extensibility, and type safety, MAP organizes its entire type system using a four-level model. This layered structure spans from abstract meta-concepts to concrete, instantiable types and data.</p> <p></p> \ud83d\udd17 Compositional Inheritance via <code>Extends</code> <p>MAP embraces compositional inheritance as its primary structuring mechanism. Rather than relying on rigid class hierarchies, MAP types declare structure by extending other types \u2014 combining properties, relationships, and semantic expectations through composition.</p> <pre><code>The `Extends` relationship is used throughout the type system to:\n- Declare that a type fulfills the obligations of a more general type\n- Inherit shared properties and relationship definitions\n- Align a descriptor with the structural pattern of its kind\n\nThis enables:\n- Meta-types to declare required features (Level 1)\n- Abstract types to specialize those features per TypeKind (Level 2)\n- Concrete types to fulfill both (Level 3)\n\n&gt; Compositional inheritance keeps MAP types modular, transparent, and incrementally extensible \u2014 without locking them into brittle class hierarchies.\n</code></pre>"},{"location":"core/map-type-system-revised/#level-1-meta-types","title":"\ud83e\uddf1 Level 1: Meta-Types","text":"<p>Meta-types define the structural obligations for categories of types. Each meta-type declares: - Required <code>InstanceProperties</code> and <code>InstanceRelationships</code> (and, soon, <code>Validations</code> and <code>Dances</code>) - The <code>type_kind</code> it governs</p> <p>Examples: - <code>MetaPropertyType</code> defines the structure of all <code>PropertyType</code> descriptors - <code>MetaRelationshipType</code> defines shared expectations for relationship descriptors - <code>MetaTypeDescriptor</code> defines common expectations for all descriptor types</p> <p>These are the most abstract holons. They describe the kinds of type descriptors MAP supports.</p> <p>Top-Level Meta-types themselves extend nothing \u2014 their obligations are fulfilled for them, not by them. Meta-Types can have sub-meta types that <code>Extend</code> them (e.g., <code>MetaInverseRelationship</code> <code>Extends</code> <code>MetaRelationship</code>).</p>"},{"location":"core/map-type-system-revised/#level-2-abstract-type-descriptors","title":"\ud83e\udde9 Level 2: Abstract Type Descriptors","text":"<p>Abstract type descriptors <code>Extend</code> meta-types and anchor relationships for a type kind. </p> <p>Examples: - <code>PropertyType</code> extends <code>MetaPropertyType</code> - <code>HolonType</code> extends <code>MetaHolonType</code> - <code>EnumValueType</code> extends <code>MetaEnumValueType</code></p> <p>These abstract types are not instantiated directly. They serve as category-specific templates for concrete descriptors and provide end-points for core relationships.</p>"},{"location":"core/map-type-system-revised/#level-3-concrete-typedescriptors","title":"\ud83d\udce6 Level 3: Concrete TypeDescriptors","text":"<p>Concrete <code>TypeDescriptor</code> holons define actual, instantiable MAP types. These are the types agents use to define schemas and classify holons. Concrete type descriptors <code>Extend</code> (and fulfill the obligations of) BOTH <code>TypeDescriptor</code> AND the Abstract Type specific to their TypeKind</p> <p>Each concrete descriptor: - Extends both an Abstract Type and TypeDescriptor - Is a holon that participates in schemas - Carries metadata (<code>type_name</code>, <code>description</code>, etc.) - Declares structure via <code>InstanceProperties</code> and <code>InstanceRelationships</code></p> <p>Examples: - <code>BookType</code> extends <code>TypeDescriptor</code> and <code>HolonType</code> - <code>MapStringValueType</code> extends <code>TypeDescriptor</code> and <code>StringValueType</code> - <code>HAS_AUTHOR</code> extends <code>TypeDescriptor</code> and <code>DeclaredRelationshipType</code></p> <p>Every concrete type in MAP is described by a single, self-contained <code>TypeDescriptor</code>.</p>"},{"location":"core/map-type-system-revised/#level-4-instances-of-types","title":"\ud83d\udd01 Level 4: Instances of Types","text":"<p>These are the actual holons that populate MAP Spaces. They: - Are typed by one of the concrete type descriptors (via <code>DescribedBy</code>) - Include values for properties and relationships specified by their type - May be keyed or keyless, depending on the <code>UsesKeyRule</code> of their type</p> <p>Examples: - <code>\"Future Primal\"</code> is an instance of <code>BookType</code> - <code>\"title\"</code> is an instance of <code>PropertyName</code> - <code>\"LibrarySchema\"</code> is an instance of <code>SchemaName</code></p> <p>Holons in this layer are the data-level objects that conform to a schema.</p>"},{"location":"core/map-type-system-revised/#typedescriptor-the-keystone-type","title":"\ud83e\udde0 TypeDescriptor: The Keystone Type","text":"<p>The <code>TypeDescriptor</code> holon plays a special dual role in this hierarchy:</p> <ul> <li>It is a concrete type descriptor (Level 3)</li> <li>It is the type used to describe all other type descriptors, including itself (Level 4)</li> <li>It extends both <code>MetaTypeDescriptor</code> and <code>HolonType</code>, fulfilling the obligations of both</li> </ul> <p>This elegant recursion prevents infinite regress and anchors MAP\u2019s fully self-describing architecture.</p>"},{"location":"core/map-type-system-revised/#abstract-types-as-anchors","title":"\ud83e\udde9 Abstract Types as Anchors","text":"<p>In MAP, every relationship type (such as <code>DescribedBy</code>, <code>InstanceProperties</code>, or <code>ValueType</code>) must declare a <code>SourceType</code> and a <code>TargetType</code>. These define which types of holons a relationship is valid between.</p> <p>To support reusable relationships across many schemas and domains, MAP anchors relationship types to abstract type descriptors. For example: - The <code>DescribedBy</code> relationship has <code>HolonType</code> (abstract) as its <code>TargetType</code> - The <code>ValueType</code> relationship has <code>PropertyType</code> (abstract) as its <code>SourceType</code></p> <p>While these abstract types are not instantiable, they are valid, referenceable holons in their own right\u2014each described by a <code>TypeDescriptor</code>. This means they can serve as targets in relationships, enabling relationship types to be defined at the abstract level and reused across all concrete types that extend them.</p> <p>\ud83d\udd0d In practice: when a concrete type descriptor (like <code>BookType</code>) declares a relationship such as <code>HAS_AUTHOR</code>, the validation logic walks the <code>Extends</code> chain to ensure that the concrete type conforms to the <code>SourceType</code> and <code>TargetType</code> expectations anchored in the abstract layer.</p> <p>This leads to a clean separation: - Core relationships are defined once and anchored to abstract types. - Concrete descriptors, whether core or domain-specific, extend those abstract types and automatically participate in those relationships.</p>"},{"location":"core/map-type-system-revised/#validation-behavior","title":"Validation Behavior","text":"<p>The use of abstract types as anchors supports a flexible but robust validation model: - Holon instances must be <code>DescribedBy</code> a concrete type descriptor. - Relationship instances (e.g., SmartLinks) are validated by:   1. Looking up the <code>SourceType</code> and <code>TargetType</code> of the relationship's descriptor   2. Ensuring the instance's actual types extend (or are equal to) those expected types</p> <p>This allows core relationships to be broadly defined and applied without coupling them to specific schemas or concrete descriptors.</p>"},{"location":"core/map-type-system-revised/#domain-extensions","title":"Domain Extensions","text":"<p>Domain-specific types (e.g., <code>BookType</code>, <code>FilmType</code>) are: - <code>DescribedBy</code> \u2192 <code>TypeDescriptor</code> - <code>Extend</code> \u2192 their TypeKind's abstract template (e.g., <code>HolonType</code>)</p> <p>These extension types never extend a concrete core type like <code>HolonType</code>; instead, they instantiate their own concrete descriptors aligned with the abstract templates.</p> <p>This means that application developers never need to deal with meta-types or abstract scaffolding directly\u2014they simply define concrete types that extend templates and conform to a known pattern.</p>"},{"location":"core/map-type-system-revised/#design-principles-recap","title":"\ud83d\udccc Design Principles Recap","text":"<ul> <li>Each Type Kind has a single (top-level) Meta Type </li> <li>Meta Types declare a Type Kind\u2019s obligations via instance properties and instance relationships.</li> <li>Top-level Meta Types do not <code>Extend</code> anything \u2014 their obligations are fulfilled for them, not by them.</li> <li>Meta Types may have sub\u2013meta types that <code>Extend</code> them (e.g., <code>MetaInverseRelationship</code> <code>Extends</code> <code>MetaRelationship</code>).</li> <li>Abstract type descriptors <code>Extend</code> Meta Types and anchor core relationship types for a Type Kind.</li> <li>Each MAP type is <code>DescribedBy</code> a single concrete Type Descriptor.</li> <li><code>TypeDescriptor</code> declares the instance properties and instance relationships shared by all type descriptors (including itself).</li> <li><code>TypeDescriptor</code> is a concrete Type Descriptor that <code>Extends</code> both <code>MetaTypeDescriptor</code> and the abstract <code>HolonType</code>. It acts as both an abstract and a concrete type, preventing infinite regress.</li> <li>Concrete Type Descriptors <code>Extend</code> both the general <code>TypeDescriptor</code> and the Abstract Type for their Type Kind, fulfilling both.</li> </ul> <p>This 4-level model ensures that types, schemas, and even schema-of-schemas are composable, inspectable, and extensible \u2014 enabling MAP to support open-ended, agent-defined semantics.</p>"},{"location":"core/map-type-system-revised/#map-type-system-design-abstract-types-as-anchors","title":"\ud83e\udded MAP Type System Design: Abstract Types as Anchors","text":"<p>This document formalizes the design principle that abstract types serve as anchors for relationship definitions within the MAP type system. This approach preserves both the structural integrity of the type system and the flexibility needed for large-scale domain modeling.</p>"},{"location":"core/map-type-system-revised/#starting-premises","title":"\u2705 Starting Premises","text":"Concept Clarification Abstract types Are real holons with referenceable identity. They are <code>TypeDescriptor</code> instances with <code>is_abstract_type = true</code>. They are not instantiable (i.e., no holon may declare <code>DescribedBy \u2192 [abstract type]</code>). Concrete types Are also <code>TypeDescriptor</code>s, but with <code>is_abstract_type = false</code>. They can be used in <code>DescribedBy</code> to describe holons. Relationship types Are concrete <code>DeclaredRelationshipType</code> holons that declare their expected <code>SourceType</code> and <code>TargetType</code>. SmartLink validation Ensures that the holons involved in a SmartLink conform to the type constraints of the relationship type. This requires comparing the <code>DescribedBy</code> of the source/target holons to the relationship type\u2019s <code>SourceType</code> and <code>TargetType</code>."},{"location":"core/map-type-system-revised/#design-principle-abstract-types-as-anchors","title":"\ud83e\udde9 Design Principle: Abstract Types as Anchors","text":""},{"location":"core/map-type-system-revised/#core-concept","title":"\ud83d\udcd0 Core Concept","text":"<p>Abstract types (e.g., <code>HolonTypeTemplate</code>, <code>PropertyType</code>, <code>ValueType</code>) are used as the <code>SourceType</code> and <code>TargetType</code> in the declaration of relationship types.</p> <p>Validation is based not on strict equality, but on type conformance: A holon is valid as the source or target of a SmartLink if its <code>DescribedBy</code> extends the relationship\u2019s <code>SourceType</code> or <code>TargetType</code>.</p>"},{"location":"core/map-type-system-revised/#smartlink-validation-rule","title":"\u2705 SmartLink Validation Rule","text":"<p>When validating a SmartLink instance:</p> <ul> <li>Let <code>R</code> be the <code>DeclaredRelationshipType</code> describing the link</li> <li>Let <code>S</code> be the source holon</li> <li>Let <code>T</code> be the target holon</li> <li>Then the SmartLink is valid if:</li> <li><code>S.DescribedBy</code> Extends <code>R.SourceType</code></li> <li><code>T.DescribedBy</code> Extends <code>R.TargetType</code></li> </ul> <p>This preserves the non-instantiability of abstract types while still allowing them to define broad, reusable relationship categories.</p>"},{"location":"core/map-type-system-revised/#why-this-matters_1","title":"\ud83e\udde0 Why This Matters","text":"<ul> <li>Abstract types define type-kind-specific obligations via their <code>InstanceProperties</code> and <code>InstanceRelationships</code>.</li> <li>They act as anchors for relationships such as:</li> <li><code>(PropertyType)-[ValueType]-&gt;(ValueType)</code></li> <li><code>(HolonType)-[InstanceProperties]-&gt;(PropertyType)</code></li> <li><code>(RelationshipType)-[SourceType]-&gt;(HolonType)</code></li> <li>Domain-specific concrete types (e.g., <code>Book.HolonType</code>) extend these abstract types and inherit their structural expectations.</li> </ul>"},{"location":"core/map-type-system-revised/#example-author-relationship","title":"\ud83d\udd17 Example: Author Relationship","text":""},{"location":"core/map-type-system-revised/#relationship-definition","title":"Relationship Definition","text":"<pre><code>{\n  \"key\": \"(Holon)-[AuthorOf]-&gt;(Holon)\",\n  \"type\": \"#TypeDescriptor\",\n  \"properties\": {\n    \"type_name\": \"AuthorOf\",\n    \"type_kind\": \"Relationship\",\n    \"is_abstract_type\": false\n  },\n  \"relationships\": [\n    { \"name\": \"Extends\", \"target\": \"#DeclaredRelationshipType\" },\n    { \"name\": \"SourceType\", \"target\": \"#Person.HolonTypeTemplate\" },\n    { \"name\": \"TargetType\", \"target\": \"#CreativeWork.HolonTypeTemplate\" }\n  ]\n}\n</code></pre>"},{"location":"core/map-type-system-revised/#valid-smartlink","title":"Valid SmartLink","text":"<pre><code>{\n  \"key\": \"person123-authorOf-book456\",\n  \"type\": \"#AuthorOf\",\n  \"source\": \"#person123\",\n  \"target\": \"#book456\"\n}\n</code></pre> <p>Where:</p> <ul> <li><code>person123.DescribedBy \u2192 Person.HolonType</code></li> <li> <p><code>Person.HolonType Extends \u2192 Person.HolonTypeTemplate</code></p> </li> <li> <p><code>book456.DescribedBy \u2192 Book.HolonType</code></p> </li> <li><code>Book.HolonType Extends \u2192 CreativeWork.HolonTypeTemplate</code></li> </ul> <p>\u2705 The validation passes: the SmartLink conforms because both source and target types extend the expected abstract anchors.</p>"},{"location":"core/map-type-system-revised/#summary","title":"\u2705 Summary","text":"<p>This approach provides: - A unified, extensible model of type descriptors - Support for validation against abstract categories - Clean modeling of relationship expectations without sacrificing type safety - A clear separation between instantiable and non-instantiable types</p> <p>By anchoring relationships in abstract types and validating against the extension hierarchy, MAP maintains both strict type safety and maximal reuse of schema structures.</p> <p>Several of the <code>type_kind</code> variants \u2014 such as <code>Value(String)</code>, <code>Value(Boolean)</code>, or <code>ValueArray(Enum)</code> \u2014 correspond to scalar value types. These are backed by a fixed set of Base Types that define how values are represented, stored, and validated across environments. Let\u2019s look next at the Base Types and Base Values that support these value type kinds.</p>"},{"location":"core/map-type-system-revised/#base-types-and-base-values","title":"Base Types and Base Values","text":"<p>BaseTypes are the foundational, portable types in the MAP system. A Base Type determines how a given value is represented across programming environments \u2014 such as Rust on the backend and TypeScript or JSON on the client. The Base Types layer includes scalar types (e.g., MapInteger, MapString) and compound types (e.g., MapBytes). The set of Base Types is fixed for any given version of the MAP. Changes or additions to any of these types requires a recompile of the MAP code and an evolution of the persistent data stored using a prior version of the MAP.</p> <p>\u2705 Principle: Preserve Type Identity Across Platforms * The Base Type name should be treated as portable name, used consistently across environments, and interpretable as such by the MAP type system. * In Rust, we get this via <code>pub struct MapString(pub String)</code> \u2014 which gives us a unique type identity at the compiler level. * In TypeScript, and even JSON, we can do similar things \u2014 not with strong typing, but through type aliases, tagging, or enforced schema constraints.</p>"},{"location":"core/map-type-system-revised/#current-base-types-with-portable-name-bindings","title":"Current Base Types with Portable Name Bindings","text":"<p>The following table shows each MAP Base Type alongside its language-specific bindings and its portable JSON representation.</p> Base Type Rust Binding TypeScript Binding JSON Binding (Tagged Format) <code>MapString</code> <code>pub struct MapString(pub String)</code> <code>export type MapString = string;</code> <code>{ \"type\": \"MapString\", \"value\": \"...\" }</code> <code>MapBoolean</code> <code>pub struct MapBoolean(pub bool)</code> <code>export type MapBoolean = boolean;</code> <code>{ \"type\": \"MapBoolean\", \"value\": true }</code> <code>MapInteger</code> <code>pub struct MapInteger(pub i64)</code> <code>export type MapInteger = number;</code> <code>{ \"type\": \"MapInteger\", \"value\": 42 }</code> <code>MapEnumValue</code> <code>pub struct MapEnumValue(pub String)</code> <code>export type MapEnumValue = string;</code> <code>{ \"type\": \"MapEnumValue\", \"value\": \"DRAFT\" }</code> <code>MapBytes</code> <code>pub struct MapBytes(pub Vec&lt;u8&gt;)</code> <code>export type MapBytes = string; // base64</code> <code>{ \"type\": \"MapBytes\", \"value\": \"aGVsbG8=\" }</code>"},{"location":"core/map-type-system-revised/#base-values","title":"Base Values","text":"<p>MAP represents actual runtime values using the <code>BaseValue</code> enum. This enum wraps each of the base types, enabling them to be used uniformly in property maps, serialized holons, and validation contexts.</p> <pre><code>pub enum BaseValue {\n    StringValue(MapString),\n    BooleanValue(MapBoolean),\n    IntegerValue(MapInteger),\n    EnumValue(MapEnumValue),\n    BytesValue(MapBytes),\n}\n</code></pre> <p>Each variant corresponds to a specific MAP Base Type. This allows property values to be stored and inspected in a type-safe and introspectable way.</p> <p>Only <code>BaseValue</code> variants may be used as <code>PropertyValue</code>s within a holon's <code>PropertyMap</code>:</p> <pre><code>pub type PropertyValue = BaseValue;\npub type PropertyMap = BTreeMap&lt;PropertyName, Option&lt;PropertyValue&gt;&gt;;\n</code></pre> <p>By wrapping all scalar values in a unified enum, MAP ensures that holon properties are portable, self-describing, and easy to serialize and deserialize across environments.</p>"},{"location":"core/map-type-system-revised/#notes","title":"Notes","text":"<ul> <li> <p>Rust bindings use the newtype pattern (e.g. <code>pub struct MapString(pub String)</code>) to distinguish each base type with a unique identity while still leveraging native Rust primitives. This allows custom trait implementations, typed serialization, and compile-time safety.</p> </li> <li> <p>All types derive <code>Clone</code>, <code>PartialEq</code>, and other basic traits, ensuring they are usable in Holochain entry types, maps, and standard logic.</p> </li> <li> <p>Display implementations are provided for all base types and for <code>BaseValue</code>, with formatting that is human-readable and variant-specific. This is especially helpful for debugging, logging, or visualization.</p> </li> <li> <p><code>BaseValue</code> acts as the unified runtime representation of scalar values. Its variant names are aligned with the base type wrappers (e.g., <code>StringValue(MapString)</code>), and it includes:</p> </li> <li>A method <code>into_bytes()</code> for deterministic binary encoding</li> <li>A <code>Display</code> implementation</li> <li> <p>A <code>From&lt;&amp;BaseValue&gt; for String</code> conversion (via <code>Into&lt;String&gt;</code>)</p> </li> <li> <p>TypeScript bindings are currently defined as simple aliases (e.g., <code>type MapString = string</code>) for interoperability with JSON and browser-based UIs. This preserves the MAP naming scheme in typed code.</p> </li> <li> <p>JSON bindings assume a tagged format for clarity and round-tripping, such as:</p> </li> </ul> <p>{   \"type\": \"StringValue\",   \"value\": \"Hello\"   }</p> <ul> <li> <p><code>ValueType</code> defines the kind of scalar value a property can hold, and is used within type descriptors to constrain values semantically (e.g., enforce that a field is a <code>String</code>, <code>Integer</code>, etc.).</p> </li> <li> <p>The previously defined <code>BaseType</code> enum has been removed. Its responsibilities are now handled more cleanly by:</p> </li> <li><code>TypeKind</code> \u2014 for classifying descriptors at the schema level (e.g., <code>Property</code>, <code>Value</code>, <code>Relationship</code>)</li> <li><code>ValueType</code> \u2014 for describing scalar semantics in descriptors</li> <li><code>BaseValue</code> \u2014 for representing actual runtime values</li> </ul>"},{"location":"core/map-type-system-revised/#older-stuff-ignore-everything-that-follows","title":"OLDER STUFF -- Ignore everything that follows","text":"<p>MAP distinguishes types by their role in the type system. Each layer builds on the one below it:</p> Layer Role Example Types Meta Types Describe types themselves <code>MetaPropertyType</code>, <code>MetaHolonType</code> Core Types Used by MAP system logic and behavior <code>PropertyType</code>, <code>SchemaName</code> Extension Types Defined by agents to model domains <code>BookType</code>, <code>LibrarySchema</code> <ul> <li>Meta Types form the introspective backbone of MAP \u2014 they define how all other types are structured and understood.</li> <li>Core Types provide the foundational categories and semantic roles that MAP depends on to validate, model, and interpret holons.</li> <li>Extension Types let agents build on the core by defining their own reusable, introspectable structures \u2014 without any need to modify system logic.</li> </ul> <p>Each type in MAP is a holon, and every holon is typed by another holon \u2014 its TypeDescriptor \u2014 via the <code>DescribedBy</code> relationship. That descriptor defines the holon\u2019s properties, relationships, and structural expectations. This self-describing pattern ensures that every holon carries with it enough semantic metadata to be interpreted, validated, and extended \u2014 without relying on external schemas.</p> <p>Together, these layers support a fully self-aware, agent-defined ecosystem of meaning.</p>"},{"location":"core/map-type-system-revised/#3-meta-types-holons-that-describe-types","title":"3. Meta Types: Holons That Describe Types","text":"<p>Every holon in MAP is DescribedBy a <code>TypeDescriptor</code>. That descriptor serves two essential roles:</p> <ul> <li>It classifies the holon as a specific type (e.g., <code>BookHolonType</code>, <code>SchemaHolonType</code>)</li> <li>It describes the structure that instances of that type must or may include \u2014 such as properties, relationships, and (eventually) dances</li> </ul> <p>But each <code>TypeDescriptor</code> is itself a holon. For example, <code>BookHolonType</code> and <code>SchemaHolonType</code> are both type descriptors \u2014 and also holons that can be queried, versioned, and linked.</p> <p>So what describes a type descriptor?</p> <p>The types that describe other types are known as meta-types.</p>"},{"location":"core/map-type-system-revised/#31-map-meta-schema","title":"3.1 MAP Meta-Schema","text":"<ul> <li><code>MetaHolonType</code>, <code>MetaTypeDescriptor</code>, <code>MetaSchemaType</code></li> <li><code>DescribedBy</code>, <code>Extends</code>, <code>InstanceProperties</code></li> <li>\ud83d\udcca Diagram: Meta-Schema Graph</li> </ul>"},{"location":"core/map-type-system-revised/#311-typedescriptor-anatomy-and-inheritance","title":"3.1.1 TypeDescriptor Anatomy and Inheritance","text":"<ul> <li>Holon structure: <code>type</code>, <code>properties</code>, <code>relationships</code></li> <li>Semantic role of <code>Extends</code></li> <li>Reflexive closure of the type system</li> </ul>"},{"location":"core/map-type-system-revised/#32-map-meta-value-schema","title":"3.2 MAP Meta-Value Schema","text":"<ul> <li><code>MetaValueType</code>, <code>MetaStringValueType</code>, <code>MetaEnumValueType</code>, etc.</li> <li>\ud83d\udcca Diagram: Meta-Value Schema</li> </ul>"},{"location":"core/map-type-system-revised/#33-map-keyrule-schema","title":"3.3 MAP KeyRule Schema","text":"<ul> <li><code>KeyRuleType</code> and its subtypes:<ul> <li><code>Format.KeyRuleType</code>, <code>None.KeyRuleType</code>, <code>Relationship.KeyRuleType</code></li> </ul> </li> <li>\ud83d\udcca Diagram: KeyRule Schema</li> </ul>"},{"location":"core/map-type-system-revised/#331-keyed-vs-keyless-holon-types","title":"3.3.1 Keyed vs. Keyless Holon Types","text":"<ul> <li>Structural rules and constraints</li> <li>Key derivation formats and <code>UsesKeyRule</code></li> <li>Bootstrapping with materialized keys</li> </ul>"},{"location":"core/map-type-system-revised/#34-semantic-vs-structural-inheritance-in-the-map-type-system","title":"3.4 Semantic vs Structural Inheritance in the MAP Type System","text":"<p>The MAP <code>Extends</code> relationship enables a flexible form of type composition and lineage. But the meaning and effect of <code>Extends</code> depends on whether the type being extended is abstract or concrete.</p> <p>This section distinguishes semantic vs structural inheritance, and clarifies how <code>Extends</code> behaves in each case.</p>"},{"location":"core/map-type-system-revised/#semantic-inheritance-extending-abstract-types","title":"\ud83d\udd39 Semantic Inheritance (Extending Abstract Types)","text":"<p>Abstract types in MAP define expectations, not structure. They play a role similar to Interfaces in Java and Traits in Rust.</p> <ul> <li>They specify what kinds of properties and relationships their concrete subtypes must declare.</li> <li>But, abstract types are not instantiated; they do not automatically contribute structural content to the types that extend them.</li> <li>In MAP, the first instantiable subtype in the Extends chain must explicitly declare the union of all InstanceProperties and InstanceRelationships expected by its abstract ancestors. This means its instances that it describes must populate values for those properties and relationships.</li> </ul>"},{"location":"core/map-type-system-revised/#example","title":"\u2705 Example","text":"<p><pre><code>MetaTypeDescriptor  (abstract) with InstanceProperties: TypeName, Description, etc.\n  \u2191 Extends\nMetaHolonType       (abstract) with InstanceRelationships: DescribedBy and OwnedBy\n  \u2191 Extends\nTypeDescriptor      (concrete)\n  \u2191 Describe\n BookHolonType\n</code></pre> TypeDescriptor is the first concrete type descriptor in the chain and therefore must declare the union of all InstanceProperties and InstanceRelationships required by its abstract ancestors (MetaTypeDescriptor, MetaHolonType).</p> <p>Likewise, BookType \u2014 a concrete extension of HolonType \u2014 fulfills the expectations declared by HolonType. - <code>TypeDescriptor</code> must declare its own <code>InstanceProperties</code> and <code>InstanceRelationships</code> that are the union of those declared by all the abstract types up its Extends chain, because those expectations come from its ancestors.</p> <p>This pattern supports: - Schema validation rules (e.g., \"all MetaHolonType subtypes must declare <code>InstanceRelationships</code>\") - Introspection tools that identify \u201cWhat kind of thing is this descriptor?\u201d</p> <p>\ud83e\udde0 Think of semantic inheritance as interface or trait conformance.</p>"},{"location":"core/map-type-system-revised/#structural-inheritance-extending-concrete-types","title":"\ud83d\udd39 Structural Inheritance (Extending Concrete Types)","text":"<p>Concrete types in MAP define structure \u2014 real properties and relationships that apply to all instances of the type.</p> <p>When a concrete type <code>A</code> extends another concrete type <code>B</code>: - A new holon instance is created for each \u2014 one for <code>A</code>, one for <code>B</code>. - The holon instance of <code>A</code> populates the <code>InstanceProperties</code> and <code>InstanceRelationships</code> declared by <code>A</code>. - The holon instance of <code>B</code> populates the structure declared by <code>B</code>.</p> <p>Together, these form a compositional chain of holons, and the effective structure of a holon is the combined result of traversing the <code>Extends</code> chain.</p>"},{"location":"core/map-type-system-revised/#example_1","title":"\u2705 Example","text":"<p>Consider a library containing lots of different kinds of items -- magazines, tools, books, CD's, DVD's, etc. There are some characteristics shared by all of these items and additional charactertistics that are specific to the kind of element.</p> <pre><code>LibraryItemType       (concrete)\n  \u2191\nBookType              (concrete)\n</code></pre> <ul> <li>An instance of <code>BookType</code>:</li> <li>Is its own holon</li> <li>Declares and populates properties like <code>author</code>, <code>publisher</code>, <code>isbn</code></li> <li>It also <code>Extends</code> an instance of <code>LibraryItemType</code>, which:</li> <li>Is a separate holon</li> <li>Declares and populates properties like <code>title</code>, <code>language</code>, <code>identifier</code></li> </ul> <p>The full shape of the book holon is realized by composing these layered instances. Each contributes to the structure through its declared type.</p> <p>\ud83e\udde0 Think of structural inheritance in MAP as compositional layering \u2014 not property flattening.</p>"},{"location":"core/map-type-system-revised/#summary-table","title":"\u2705 Summary Table","text":"Feature Abstract Type Concrete Type Declares expectations \u2705 Yes \u274c No Declares structure \u274c No \u2705 Yes Must be re-declared \u2705 (by subtypes) \u274c (structure accumulates) Used for validation rules \u2705 Yes \u2705 Yes Used for type conformance \u2705 Yes \u2705 Yes Affects instance shape \u274c No \u2705 Yes Produces a holon instance \u274c No \u2705 Yes"},{"location":"core/map-type-system-revised/#design-principle","title":"\ud83e\udde0 Design Principle","text":"<p>In MAP, inheritance is explicit and introspectable. - Abstract types guide what must be declared. - Concrete types contribute actual structure. - Each concrete type produces its own holon instance. - The effective holon shape is the result of traversing the Extends chain.</p> <p>This makes the MAP type system composable, schema-validatable, and fully self-describing \u2014 with no hidden inheritance or magical behavior.</p>"},{"location":"core/map-type-system-revised/#4-core-types-semantic-foundations-of-map","title":"4. Core Types: Semantic Foundations of MAP","text":"<ul> <li><code>PropertyType</code>, <code>RelationshipType</code>, <code>EnumVariantType</code></li> <li><code>PropertyName</code>, <code>RelationshipName</code>, <code>SchemaName</code></li> <li>Core enum types (e.g. <code>DeletionSemantic</code>)</li> <li>Role in validation, schema definition, and system behavior</li> </ul>"},{"location":"core/map-type-system-revised/#5-extension-types-agent-defined-semantics","title":"5. Extension Types: Agent-Defined Semantics","text":"<ul> <li>Instances of core types</li> <li>Examples: <code>BookType</code>, <code>\"HAS_AUTHOR\"</code>, <code>\"LibrarySchema\"</code></li> <li>Dual role: type + data</li> <li>Cross-schema interoperability and reuse</li> </ul>"},{"location":"core/map-type-system-revised/#6-base-types-language-portable-value-kinds","title":"6. Base Types: Language-Portable Value Kinds","text":"<ul> <li><code>MapString</code>, <code>MapBoolean</code>, <code>MapInteger</code>, etc.</li> <li><code>BaseValue</code> enum</li> <li>Rust, TypeScript, JSON bindings</li> <li>Tagged JSON format and display conventions</li> <li>Open design questions</li> </ul>"},{"location":"core/map-type-system-revised/#7-self-describing-holons","title":"7. Self-Describing Holons","text":"<p>Transition section: from types to instances</p> <ul> <li>Introspection via <code>DescribedBy</code>, <code>InstanceProperties</code>, etc.</li> <li>Aggregating inherited structure through <code>Extends</code></li> <li>How any holon reveals:<ul> <li>What kind of thing it is</li> <li>What properties it has</li> <li>What relationships it participates in</li> <li>(Future) what dances it supports</li> </ul> </li> </ul>"},{"location":"core/map-type-system-revised/#8-authoring-and-importing-types","title":"8. Authoring and Importing Types","text":"<ul> <li>JSON structure: <code>key</code>, <code>type</code>, <code>properties</code>, <code>relationships</code></li> <li><code>$ref</code> and embedding</li> <li>Key rules and validation</li> <li>Authoring conventions and import-time enforcement</li> </ul>"},{"location":"core/meta-value-types-import-guide/","title":"Meta-Value Import Guide","text":""},{"location":"core/meta-value-types-import-guide/#starting-point-types-as-holons","title":"\ud83e\uddec Starting Point: Types as Holons","text":"<p>In MAP, every type description is, itself, a holon.</p> <p>This means that every type must: - Be described by a <code>TypeDescriptor</code> - Be owned by a <code>HolonSpace</code></p> <p>These aren't optional conventions \u2014 they are defining structural obligations of being a holon.</p> <p>\u2705 Every type in MAP is a holon. Therefore: every type must have <code>DescribedBy</code> and <code>OwnedBy</code> relationships.</p>"},{"location":"core/meta-value-types-import-guide/#modeling-map-value-types","title":"Modeling MAP Value Types","text":""},{"location":"core/meta-value-types-import-guide/#example-mapstringvaluetype-and-propertynamevaluetype","title":"\ud83d\udd20 Example: MapStringValueType and PropertyNameValueType","text":"<p>Consider two value types:</p> <ul> <li><code>MapStringValueType</code>: A general-purpose string type</li> <li><code>PropertyNameValueType</code>: A string type used specifically for property names</li> </ul> <p>They both represent strings at the data level, but differ in usage and constraint.</p> <p>Both are:</p> <ul> <li>Holons \u2192 Must be <code>DescribedBy</code> and <code>OwnedBy</code></li> <li>TypeDescriptors \u2192 Must be instances of <code>MetaValueType</code></li> </ul> <p>So the following relationships apply:</p> <pre><code>MapStringValueType \u2014[DescribedBy]\u2192 MetaValueType  \nPropertyNameValueType \u2014[DescribedBy]\u2192 MetaValueType\n</code></pre> <p>At this point, we know these two holons are not just any holons \u2014 they are type descriptors used in the schema.</p>"},{"location":"core/meta-value-types-import-guide/#shared-constraints-via-compositional-inheritance","title":"\ud83e\uddf1 Shared Constraints via Compositional Inheritance","text":"<p>Different value types require different constraints:</p> <ul> <li>Strings \u2192 min/max length, format, case convention</li> <li>Integers \u2192 min/max values</li> <li>Enums \u2192 allowed variants</li> <li>Bytes \u2192 fixed length, encoding</li> </ul> <p>But many types share these constraints. For example:</p> <pre><code>MapStringValueType        \u2500\u2510\n                          \u251c\u2500[Extends]\u2192 StringValueConstraints\nPropertyNameValueType     \u2500\u2518\n</code></pre> <p>In this pattern:</p> <ul> <li><code>MapStringValueType</code> and <code>PropertyNameValueType</code> are both holons and descriptors.</li> <li><code>StringValueConstraints</code> is just a constraint facet \u2014 it contributes properties like <code>min_length</code>, <code>max_length</code>, or <code>case_convention</code>.</li> </ul> <p>Importantly:</p> <p><code>StringValueConstraints</code> is not a type. It\u2019s not a descriptor. It doesn\u2019t have a <code>type_name</code>, doesn\u2019t need to be <code>DescribedBy</code>, and doesn\u2019t appear in any schema.</p> <p>It just extends the value type it\u2019s associated with, in a purely compositional way.</p>"},{"location":"core/meta-value-types-import-guide/#why-keys-matter","title":"\ud83e\uddf7 Why Keys Matter","text":"<p>Semantic keys are foundational to the MAP architecture \u2014 not just for expressing relationships during import, but for enabling retrieval, referencing, and bootstrapping in a decentralized, descriptor-driven system.</p> <p>They enable holons to be meaningfully identified and linked across the full lifecycle \u2014 from initial import to runtime introspection \u2014 even before they've been committed to the system or assigned a permanent ID.</p>"},{"location":"core/meta-value-types-import-guide/#staged-relationships-without-ids","title":"\ud83d\udd04 Staged Relationships Without IDs","text":"<p>In staged or import workflows, holons frequently reference other holons that haven\u2019t yet been committed \u2014 and therefore lack a system-assigned ID (e.g., a Holochain <code>ActionHash</code>).</p> <p>Keys solve this by allowing holons to be referenced using <code>$ref: \"key\"</code> rather than relying on fragile temporary identifiers or rigid load ordering.</p> <p>\u2705 Keys enable: - Cross-file linkage between staged holons - ID-free <code>$ref</code> expressions in JSON - Relationship validation prior to commit - Deduplication and merging of equivalent entries</p> <p>\ud83d\udcd8 Example: <pre><code>{\n  \"type_name\": \"RelationshipType\",\n  \"key\": \"(PersonType)-[MentoredBy]-&gt;(PersonType)\",\n  \"relationships\": [\n    { \"name\": \"SOURCE_FOR\", \"target\": [{ \"$ref\": \"PersonType\" }] },\n    { \"name\": \"TARGET_FOR\", \"target\": [{ \"$ref\": \"PersonType\" }] }\n  ]\n}\n</code></pre></p> <p>This relationship type can be referenced by other holons using its <code>key</code>, without requiring an ID to exist yet.</p>"},{"location":"core/meta-value-types-import-guide/#bootstrapping-descriptors-before-descriptor-logic-exists","title":"\ud83e\uddf1 Bootstrapping Descriptors Before Descriptor Logic Exists","text":"<p>Many MAP behaviors \u2014 including validation, inverse relationship population, and declarative key generation \u2014 depend on descriptors like <code>PropertyType</code>, <code>RelationshipType</code>, or <code>HolonType</code>.</p> <p>But you can\u2019t run logic that depends on descriptors until descriptors are present.</p> <p>By requiring materialized <code>key</code> fields in the JSON of Keyed Holons, we can: - Import descriptors without requiring key generation logic - Reference them from other holons in the same import graph - Stage and introspect schemas and data prior to persistence</p> <p>This makes it possible to: - Import the MAP Meta-Schema - Import domain-specific schema extensions - Import valid data instances   ...all in a single, unified process.</p>"},{"location":"core/meta-value-types-import-guide/#associative-retrieval-in-distributed-systems","title":"\ud83d\udd0d Associative Retrieval in Distributed Systems","text":"<p>In distributed architectures like Holochain, data is stored in Distributed Hash Tables (DHTs) \u2014 meaning:</p> <ul> <li>You cannot \u201cquery the whole database\u201d as you would in a centralized store</li> <li>You typically need a known hash or path to locate content efficiently</li> </ul> <p>Materialized keys provide the critical link between semantic meaning and retrieval paths:</p> <p>\u2705 They support: - Associative lookup: finding content based on associated properties (e.g., type, relationship role) - Path-based indexing: storing holons under DHT paths that reflect their keys (e.g., <code>path!((\"HolonType\", key))</code>) - Declarative retrieval APIs: enabling callers to say \u201cget me the [MentoredBy] relationship\u201d without knowing its ID</p> <p>Without keys: - Content is only retrievable via opaque identifiers - Queries become tightly coupled to global indexes or full scans (inefficient or unavailable in DHTs) - Schema introspection and semantic queries are significantly harder</p>"},{"location":"core/meta-value-types-import-guide/#summary","title":"\ud83e\udde0 Summary","text":"<p>Keys are not just syntactic sugar \u2014 they are critical infrastructure for:</p> <ul> <li>Declarative, schema-linked imports</li> <li>ID-free reference resolution across files</li> <li>Bootstrapping descriptors before runtime logic is available</li> <li>Efficient, semantic-based retrieval in distributed systems</li> <li>Federated schema evolution and shared introspection</li> </ul> <p>By embracing materialized, semantically meaningful keys, MAP achieves a powerful combination of:</p> <ul> <li>Structural clarity</li> <li>Introspectable relationships</li> <li>Decentralized operability</li> <li>Self-hosted schema evolution</li> </ul> <p>This makes keys one of the most essential capabilities in the MAP Type System.</p>"},{"location":"core/meta-value-types-import-guide/#layered-inheritance-the-value-type-stack","title":"\ud83d\udcd0 Layered Inheritance: The Value Type Stack","text":"<pre><code>MetaValueType \u2014[Describes]\u2192 MapStringValueType \u2014[Extends]\u2192 StringValueConstraints\n</code></pre> <p>This gives us three clear layers:</p> <ol> <li>Meta Descriptor Level \u2014 defines what a value type must contain</li> <li>Descriptor Level \u2014 a value type like <code>MapStringValueType</code> or <code>PropertyNameValueType</code></li> <li>Constraint Layer \u2014 reusable modular constraints via <code>Extends</code></li> </ol> Layer Holon Purpose Meta <code>MetaValueType</code> Describes value type descriptors Type <code>MapStringValueType</code> Actual TypeDescriptor Constraint <code>StringValueConstraints</code> Adds constraint properties"},{"location":"core/meta-value-types-import-guide/#pattern-repeats-for-all-primitive-types","title":"\ud83d\udd01 Pattern Repeats for All Primitive Types","text":"<p>Here\u2019s the same pattern across other type kinds:</p> ValueType DescribedBy ExtendedBy Constraints Provided <code>MapStringValueType</code> <code>MetaValueType</code> <code>StringValueConstraints</code> <code>min_length</code>, <code>max_length</code>, etc. <code>PropertyNameValueType</code> <code>MetaValueType</code> <code>StringValueConstraints</code> Custom limits, <code>case_convention</code> <code>MapIntegerValueType</code> <code>MetaValueType</code> <code>IntegerValueConstraints</code> <code>min_value</code>, <code>max_value</code> <code>MapBytesValueType</code> <code>MetaValueType</code> <code>BytesValueConstraints</code> <code>length</code>, <code>encoding</code>, <code>format_hint</code> <code>MapEnumValueType</code> <code>MetaValueType</code> <code>EnumValueConstraints</code> <code>Variants</code> relationship <code>MapBooleanValueType</code> <code>MetaValueType</code> (none needed) (no constraints required)"},{"location":"core/meta-value-types-import-guide/#are-meta-types-holons-too","title":"\ud83e\udde9 Are Meta Types Holons Too?","text":"<p>Yes \u2014 and this is where the architectural recursion becomes elegant.</p> <p>Just as <code>MapStringValueType</code> is a holon and needs to be <code>DescribedBy</code>, so too does <code>MetaValueType</code>.</p> <p>Let\u2019s follow the thread:</p> <pre><code>MetaValueType         \u2014[DescribedBy]\u2192 MetaTypeDescriptor  \nMetaIntegerValueType  \u2014[DescribedBy]\u2192 MetaValueType\n</code></pre> <p>So: \ud83d\udd01 Meta types themselves are holons \ud83d\udd01 They need to be described \ud83d\udd01 They participate in the same system they define</p>"},{"location":"core/meta-value-types-import-guide/#recursion-meets-structure-metatypedescriptor-extends-metaholontype","title":"\ud83d\udd04 Recursion Meets Structure: MetaTypeDescriptor Extends MetaHolonType","text":"<p>To avoid repeating the structural obligations of all holons (like needing <code>DescribedBy</code> and <code>OwnedBy</code>) across every Meta type\u2026</p> <p>We simply declare:</p> <pre><code>MetaTypeDescriptor \u2014[Extends]\u2192 MetaHolonType\n</code></pre> <p>Now, every Meta type (like <code>MetaValueType</code>, <code>MetaPropertyType</code>, etc.) that is an instance of <code>MetaTypeDescriptor</code> inherits from <code>MetaHolonType</code>, which defines the baseline expectations for all holon types.</p> <p>\u2705 Every Meta type becomes both a type descriptor and a holon \u2705 DRY design: <code>MetaHolonType</code> captures shared structural rules \u2705 Recursive closure: the system defines itself in clean, layered cycles</p>"},{"location":"core/meta-value-types-import-guide/#summary-of-the-pattern","title":"\ud83e\udde0 Summary of the Pattern","text":"Concept Relationship Notes ValueType <code>DescribedBy \u2192 MetaValueType</code> Marks as a valid type holon ValueType <code>Extends \u2192 ValueConstraints</code> Adds constraints modularly MetaValueType <code>DescribedBy \u2192 MetaTypeDescriptor</code> Makes it a descriptor of type descriptors MetaValueType <code>Extends \u2192 MetaHolonType</code> Inherits holon-level expectations Constraints (e.g. StringValueConstraints) (no type) Purely compositional constraint layer"},{"location":"core/meta-value-types-import-guide/#bonus-how-you-might-use-this-in-validation-or-import","title":"\ud83e\uddf0 Bonus: How You Might Use This in Validation or Import","text":"<p>When validating a <code>PropertyType</code> that refers to a ValueType:</p> <ol> <li>Confirm the target is a holon</li> <li>Confirm it\u2019s <code>DescribedBy</code> <code>MetaValueType</code></li> <li>Confirm it satisfies the constraints from any <code>Extends</code> facets</li> </ol> <p>This lets you:</p> <ul> <li>Reuse constraints</li> <li>Compose constraint types</li> <li>Keep descriptors clean and minimal</li> <li>Keep validation DRY and generalizable</li> </ul> <p>================ OLDER ATTEMPTS FOLLOW</p>"},{"location":"core/meta-value-types-import-guide/#starting-point-types-as-holons_1","title":"\ud83e\uddec Starting Point: Types as Holons","text":"<p>In MAP, every type \u2014 including value types \u2014 is a holon.</p> <p>Because every type is a holon, it must:</p> <ul> <li>Be described by a <code>TypeDescriptor</code></li> <li>Be owned by a <code>HolonSpace</code></li> </ul>"},{"location":"core/meta-value-types-import-guide/#layer-1-descriptor-level-meta-types","title":"\ud83e\uddf1 Layer 1: Descriptor Level (Meta Types)","text":"<p>This is the type of types level \u2014 Meta types describe what type descriptors are.  </p> <p>For example:</p> <ul> <li><code>MetaValueType</code> is a <code>TypeDescriptor</code></li> <li>It specifies properties and relationships common to all ValueTypes<ul> <li>e.g., <code>type_name</code>, <code>ValueType</code> relationship from <code>PropertyType</code>, <code>type_kind</code>, etc.</li> </ul> </li> </ul> <p>So:</p> <pre><code>MapStringValueType \u2014[DescribedBy]\u2192 MetaValueType  \nPropertyNameValueType \u2014[DescribedBy]\u2192 MetaValueType\n</code></pre> <p>Now these holons are known to be TypeDescriptors and are expected to provide things like <code>type_name</code>, and be usable in <code>ValueType</code> relationships from <code>PropertyType</code>.</p> <p>But because every type is also a holon, the types themselves need to be <code>DescribedBy</code> a <code>TypeDescriptor</code> and <code>OwnedBy</code> a <code>HolonSpace</code>. So TypeDescriptor needs to <code>Extend</code> Me</p>"},{"location":"core/meta-value-types-import-guide/#layer-2-constraint-types-via-extends","title":"\ud83e\uddf1 Layer 2: Constraint Types via <code>Extends</code>","text":"<p>Some ValueTypes want to specify type-kind-specific constraints \u2014 but you don\u2019t want to bake those constraints into every ValueType. You want a modular, reusable structure.</p> <p>That\u2019s where <code>Extends</code> comes in.</p> <p>Let\u2019s take an example:</p> <pre><code>MapStringValueType \u2014[Extends]\u2192 StringValueConstraints  \nPropertyNameValueType \u2014[Extends]\u2192 StringValueConstraints\n</code></pre> <p>Here:</p> <ul> <li><code>MapStringValueType</code> defines the general-purpose string value type.</li> <li><code>PropertyNameValueType</code> is a specialized string type, e.g., requiring <code>snake_case</code>, specific min/max lengths, etc.</li> <li>Both share the constraint logic defined in <code>StringValueConstraints</code>.</li> </ul> <p>The key insight is that <code>StringValueConstraints</code> is not a type itself. It doesn\u2019t need a <code>type_name</code>, <code>DescribedBy</code>, etc. It simply adds constraint properties like:</p> <ul> <li><code>min_length</code></li> <li><code>max_length</code></li> <li><code>case_convention</code></li> <li><code>format_hint</code></li> </ul> <p>It's a constraint facet, not a descriptor.</p>"},{"location":"core/meta-value-types-import-guide/#parallel-pattern-for-other-type-kinds","title":"\ud83d\udd04 Parallel Pattern for Other Type Kinds","text":"<p>You\u2019d follow this same pattern for other primitive types:</p> ValueType Extends Constrains via\u2026 <code>MapIntegerValueType</code> <code>IntegerValueConstraints</code> <code>min_value</code>, <code>max_value</code> <code>MapBytesValueType</code> <code>BytesValueConstraints</code> <code>length</code>, <code>encoding</code> <code>MapBooleanValueType</code> (no constraints) (no extra facet needed) <code>MapEnumValueType</code> <code>EnumValueConstraints</code> <code>Variants</code> relationship"},{"location":"core/meta-value-types-import-guide/#layered-design-overview","title":"\ud83d\udcd0 Layered Design Overview","text":"<pre><code>          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502     MetaValueType          \u2502 \u25c4\u2500\u2500 Describes all ValueType descriptors\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502 DescribedBy\n                       \u25bc\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502   MapStringValueType       \u2502 \u25c4\u2500\u2500 A TypeDescriptor\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502 Extends\n                       \u25bc\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502   StringValueConstraints   \u2502 \u25c4\u2500\u2500 Holds constraint properties only\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>You can generalize this:</p> <ul> <li>Any <code>MetaType</code> describes a descriptor</li> <li>Any actual <code>TypeDescriptor</code> may <code>Extend</code> a constraint holon</li> <li>Constraint holons are not TypeDescriptors \u2014 they don\u2019t get keys, <code>DescribedBy</code>, or <code>OwnedBy</code></li> </ul>"},{"location":"core/meta-value-types-import-guide/#benefits-of-this-pattern","title":"\u2705 Benefits of This Pattern","text":"<ul> <li>Clarity: Descriptors describe types. Constraints constrain them.</li> <li>DRY: Reuse constraints across many types (e.g., <code>StringValueConstraints</code>)</li> <li>Composability: Add further <code>Extends</code> layers if needed, e.g., <code>StringWithRegexConstraints</code></li> <li>Separation of Concerns: Keep metadata (<code>type_name</code>, etc.) distinct from behaviorally meaningful constraints</li> </ul>"},{"location":"core/meta-value-types-import-guide/#optional-schema-organization","title":"\ud83d\udca1 Optional: Schema Organization","text":"<p>You may wrap the constraint holons (like <code>StringValueConstraints</code>) in their own schema:</p> <pre><code>{\n  \"key\": \"MAP Value Constraints Schema\",\n  \"type\": \"Schema\",\n  \"relationships\": [\n    {\n      \"name\": \"Components\",\n      \"target\": [\n        { \"$ref\": \"#StringValueConstraints\" },\n        { \"$ref\": \"#IntegerValueConstraints\" },\n        ...\n      ]\n    }\n  ]\n}\n</code></pre> <p>Would you like to sketch out the JSON structure for one of these examples (e.g., <code>PropertyNameValueType</code> extending <code>StringValueConstraints</code>) using this approach?</p>"},{"location":"core/meta-value-types-import-guide/#annotated-example-map-strings","title":"Annotated Example -- MAP Strings","text":"<p><code>MapStringValueType</code> is an instance of <code>MetaValueType</code>. Thus, it can be the target of a Property's <code>ValueType</code> relationship. It may often be the case that the <code>ValueType</code> for a property is simply <code>MapString</code>. But sometimes we want more specific types. For example, the <code>PropertyNameValueType</code> is specifically intended to be the type used for <code>property_names</code> in the MAP. As a value type, it is ALSO an instance of <code>MetaValueType</code> (i.e., its \"type\" is <code>MetaValueType</code>). Note that <code>MapString</code> and <code>PropertyNameValueType</code> both have <code>instance_type_kind</code> of <code>String</code>, so they would both be represented in Rust by the MapString type. But <code>PropertyNameValueType</code> might want to specify its own case_convention (snake_case), and length restrictions that differ from the more generic <code>MapStringValueType</code>.  And, other than sharing the same type kind, MapStringValueType and PropertyNameValueType have no direct relationship to each other.</p> <p>Different value type kinds require different kinds of constraints. For example, <code>Strings</code> have min and max length and perhaps a format type or template. Integers have min/max values. So the definition of each ValueType has a common facet (in its role as a TypeDescriptor) and a type-kind-specific facet (its constraints.</p> <p>We can use compositional inheritance to model this. Thus,</p> <p>(MetaValueType) &lt;- [Extends] - (MapValueConstraintsType) and (MapStringValueType) &lt;- [Extends] - (StringValueConstraints) and (PropertyNameValueType) &lt;- [Extends] - (StringValueConstraints)</p> <p>At first, I thought MapValueConstraintsType should perhaps be MetaValueConstraintsType -- but then I realized it is not describing another type. For example, StringValueConstraints is not (itself) a type definition. It specifies the constraints for the ValueType that it extends. Values for the type_name property (and all other TypeDescriptor properties) are set on the ValueType it extends. In other words, the PropertyNameValueType is the actual TypeDescriptor.</p>"},{"location":"core/meta-value-types-import-guide/#metavaluetype","title":"MetaValueType","text":"<ul> <li>Is the type that <code>Describes</code> <code>MapValueType</code>, so its <code>type</code> is <code>TypeDescriptor</code></li> </ul> <p>Each instance of <code>MapValueType</code> describes a single ValueType. It is a <code>TypeDescriptor</code> that provides values for the standard <code>TypeDescriptor</code> properties (e.g, <code>type_name</code>, <code>display_name_plural</code>, <code>instance_type_kind</code>, etc.).</p> <p>MetaValueType is an instance of TypeDescriptor that describes MapValueType MapValueType is an instance of MetaValueType (i.e., its \"type\" is \"MetaValueType\") -- SINGLETON? MapStringType is an instance of MapValueType (or MetaValueType)</p> <p>An XxxValueType consists of a TypeDescriptor that is ExtendedBy an XxxConstraintType The X StringConstraints Extends MapStringType</p> <p>As such it provides values for the <code>TypeDescriptor</code> <code>properties</code>:</p> <ul> <li>\"type_name\": \"MetaValueType\",</li> <li>\"type_name_plural\": \"MetaValueTypes\",</li> <li>\"display_name\": \"Meta Value Type\",</li> <li>\"display_name_plural\": \"Meta Value Types\",</li> <li>\"description\": \"Describes the types that can be used as the target of a <code>Property</code>'s <code>ValueType</code> relationship.\"</li> <li>\"instance_type_kind\": \"Holon\"</li> </ul> <p>All Meta types describe types and all type definitions are, themselves, Holons. So the instance_type_kind for all Meta types is \"Holon\"</p> <ul> <li>\"UsesKeyRule\": { \"$ref\": \"#TypeName.KeyRule\" }</li> <li>instance_type_kind tells you the storage type (i.e., the BaseType) of instances of the type being described</li> <li>MapValueType is the TypeDescriptor for all value types</li> <li>MetaStringConstraints Extends MetaValueType and</li> </ul> <pre><code> {\n              \"key\": \"MetaPropertyType\",\n              \"type\": \"#TypeDescriptor\",\n              \"properties\": {\n                \"type_name\": \"MetaPropertyType\",\n                \"type_name_plural\": \"MetaPropertyTypes\",\n                \"display_name\": \"Meta Property Type\",\n                \"display_name_plural\": \"Meta Property Types\",\n                \"description\": \"Describes the types of scalar properties that holons can possess.\"\n              },\n              \"relationships\": [\n                {\n                  \"name\": \"Extends\",\n                  \"target\": {\n                    \"$ref\": \"#MetaTypeDescriptor\"\n                  }\n                },\n                {\n                  \"name\": \"UsesKeyRule\",\n                  \"target\": {  $ref\": \"#TypeName.KeyRule\" }\n                },\n                {\n                  \"name\": \"InstanceRelationships\",\n                  \"target\": [\n                    {\n                      \"$ref\": \"#(PropertyType)-[ValueType]-&gt;(ValueType)\"\n                    },\n                    {\n                      \"$ref\": \"#(PropertyType)-[ComponentOf]-&gt;(Schema)\"\n                    },\n                    {\n                      \"$ref\": \"#(PropertyType)-[DescribedBy]-&gt;(TypeDescriptor)\"\n                    }\n                  ]\n                }\n              ]\n            },\n</code></pre> <pre><code> {\n              \"key\": \"MetaPropertyType\",\n              \"type\": \"#TypeDescriptor\",\n              \"properties\": {\n                \"type_name\": \"MetaPropertyType\",\n                \"type_name_plural\": \"MetaPropertyTypes\",\n                \"display_name\": \"Meta Property Type\",\n                \"display_name_plural\": \"Meta Property Types\",\n                \"description\": \"Describes the types of scalar properties that holons can possess.\"\n              },\n              \"relationships\": [\n                {\n                  \"name\": \"Extends\",\n                  \"target\": {\n                    \"$ref\": \"#MetaTypeDescriptor\"\n                  }\n                },\n                {\n                  \"name\": \"UsesKeyRule\",\n                  \"target\": {\n                    \"$ref\": \"#TypeName.KeyRule\"\n                  }\n                },\n                {\n                  \"name\": \"InstanceRelationships\",\n                  \"target\": [\n                    {\n                      \"$ref\": \"#(PropertyType)-[ValueType]-&gt;(ValueType)\"\n                    },\n                    {\n                      \"$ref\": \"#(PropertyType)-[ComponentOf]-&gt;(Schema)\"\n                    },\n                    {\n                      \"$ref\": \"#(PropertyType)-[DescribedBy]-&gt;(TypeDescriptor)\"\n                    }\n                  ]\n                }\n              ]\n            },\n</code></pre>"},{"location":"core/meta-value-types-import-guide/#mapvaluetype","title":"MapValueType","text":"<pre><code>{\n  \"key\": \"MapValueType\",\n  \"type\": \"#TypeDescriptor\"\n}\n</code></pre>"},{"location":"core/transaction-model/","title":"MAP Transaction Model","text":"<p>Comparison to Event-Sourced Systems, Holochain, CRDTs, and MVCC</p>"},{"location":"core/transaction-model/#the-map-transaction-model","title":"\ud83c\udf31 The MAP Transaction Model","text":"<p>In the Memetic Activation Platform (MAP), every set of proposed changes to holons is staged in a local Nursery before being committed. A Transaction holon represents this unit of change. It is created at commit time and holds:</p> <ul> <li>Relationships to a set of ValidationResult holons</li> <li>Links to all updated Holons (via those results)</li> <li>State transitions such as <code>Unvalidated</code> \u2192 <code>Validated</code> \u2192 <code>Committed</code> or <code>RolledBack</code></li> <li>Optional logging of fine-grained operations to support undo/redo and compensating transactions</li> </ul> <p>The MAP\u2019s layered design separates validation (ensuring semantic correctness and consistency) from persistence (recording changes in the source of truth). Validation is performed before commit using rules scoped by both application logic and shared agreements (e.g. cardinality checks, role consistency, semantic integrity, etc.).</p>"},{"location":"core/transaction-model/#nursery-as-a-read-model-projection-layer","title":"\ud83e\udeb5 Nursery as a Read Model (Projection Layer)","text":"<p>In Event Sourced systems, projections (also called read models) are derived views of the event stream, optimized for user interaction. The MAP Nursery serves this role during a transaction:</p> <ul> <li>It maintains a materialized view of holons after every staged change.</li> <li>Ergonomic client APIs (e.g. <code>with_property</code>, <code>add_relationship</code>) mutate this staged state.</li> <li>These lightweight operations can be logged as Commands, enabling undo/redo support.</li> <li>Only at commit time is the transaction finalized and written as an immutable update.</li> </ul>"},{"location":"core/transaction-model/#comparison-to-event-sourcing-systems","title":"\ud83d\udd01 Comparison to Event Sourcing Systems","text":"Aspect Event Sourcing MAP Transaction Model Core Persistence Model Append-only event log Append-only holon updates (via DHT) Aggregates Derived from replaying events Materialized holons in nursery projections Validation Done before/after event persistence Done in the nursery, before commit Transaction Representation Often lacks explicit transaction Explicit <code>Transaction</code> holon Undo/Redo By reversing events or snapshots Via logged staged operations in nursery Compensating Transactions Application-defined Tracked via new Transaction holons Concurrency Control Typically OCC or snapshot isolation MVCC + Agreement-Scoped Conflict Resolution"},{"location":"core/transaction-model/#mvcc-in-map-vs-other-concurrency-strategies","title":"\u2699\ufe0f MVCC in MAP vs Other Concurrency Strategies","text":""},{"location":"core/transaction-model/#map-uses-multi-version-concurrency-control-mvcc","title":"\u2705 MAP uses Multi-Version Concurrency Control (MVCC)","text":"<ul> <li>Each holon update produces a new immutable version</li> <li>Writers do not block each other \u2014 they create parallel branches</li> <li>Version history is preserved and traceable</li> <li>Conflict detection is deferred, and resolution is semantic (not structural)</li> </ul>"},{"location":"core/transaction-model/#not-optimistic-concurrency-control-occ","title":"\u274c Not Optimistic Concurrency Control (OCC)","text":"<ul> <li>OCC would reject commits if the read version was outdated</li> <li>MAP instead accepts the write, creating a new fork</li> <li>This branching behavior supports collaborative divergence before reconciliation</li> </ul>"},{"location":"core/transaction-model/#conflict-resolution-strategies-crdts-vs-holochain-vs-map","title":"\ud83e\udde0 Conflict Resolution Strategies: CRDTs vs Holochain vs MAP","text":"Feature CRDTs Holochain MAP Conflict-Free? Claims \"conflict-free\" via auto-merge Leaves resolution to the application Explicitly supports semantic conflicts Merge Strategy Structural (e.g. last-write-wins, ORSet) None by default Application + Agreement-Scoped Semantics Determinism Always converges No built-in convergence Resolution logic is pluggable per domain Lost Updates Possible? Yes (e.g. in LWW) Yes Yes \u2014 but tracked and resolvable Undo Support Limited Manual Fine-grained undo via operation log Update Representation Per-property, tombstones, deltas Entry-level action history Per-holon, with ergonomic staging granularity Versioning Model Conflict-resolution per data type Full action chain (via hashes) Holon-level branches tracked via hashes <p>\ud83d\udd0d Note: While CRDTs automatically resolve structural conflicts, they often do so at the cost of semantic predictability. MAP preserves all branches and delegates resolution to shared agreements and application logic.</p>"},{"location":"core/transaction-model/#agreement-scopes-and-application-scopes","title":"\ud83d\udcdc Agreement Scopes and Application Scopes","text":"<p>To support meaningful conflict resolution:</p> <ul> <li>Agreement Scope: Specifies the participants and rules (e.g. communities, working groups) that govern semantic resolution.</li> <li>Application Scope: Defines the data boundaries (e.g. all holons in a shared Space) to which resolution applies.</li> </ul> <p>Resolution logic is therefore anchored in both the social commitments and the data model \u2014 ensuring that divergent updates are reconciled in a trustworthy, context-aware way.</p>"},{"location":"core/transaction-model/#summary","title":"\ud83e\udde9 Summary","text":"<p>MAP\u2019s Transaction model offers:</p> <ul> <li>A clear separation of staging, validation, and commit phases</li> <li>Fine-grained operation tracking for undo/redo and compensation</li> <li>Explicit MVCC-style version branching with later reconciliation</li> <li>A hybrid model blending Event Sourcing, Holochain DHT consistency, and semantic conflict resolution that goes beyond CRDTs</li> </ul> <p>This design supports both a robust technical foundation and the social contracts required for trustworthy, collaborative data stewardship.</p>"},{"location":"mapp-dev/extensibility-model/","title":"MAP Extensibility Model","text":""},{"location":"mapp-dev/extensibility-model/#introduction","title":"Introduction","text":"<p>In the Memetic Activation Platform (MAP), we embrace a fundamentally different approach to extensibility than traditional software systems. Instead of a rigid set of predefined types and relationships, the MAP offers a flexible and open-ended ontology where all entities are represented as holons. This document explains how this extensibility model works and why it matters for developers adopting the MAP.</p>"},{"location":"mapp-dev/extensibility-model/#the-problem-with-fixed-ontologies","title":"The Problem with Fixed Ontologies","text":"<p>Most traditional software systems operate with a fixed schema. Each release defines a set of types, relationships, and behaviors that are controlled by the application provider.</p> <p></p> <p>Over time, as these providers add more functionality, they introduce more and more predefined types\u2014sometimes ballooning into thousands of tightly coupled objects. While this might provide a broad feature set, it also leads to vendor lock-in due to high-switching costs. And no matter how large it gets, you are still limited by the app provider's imagination and release cadence. Got a need to manage different types of data? Novel behavior? A superior visual experience? Good luck! File your enhancement request and then... wait. </p>"},{"location":"mapp-dev/extensibility-model/#emergent-complexity-and-the-need-for-open-ended-ontology","title":"Emergent Complexity and the Need for Open-Ended Ontology","text":"<p>In contrast, the MAP is built on the idea that emergent complexity demands an open-ended ontology. </p> <p></p> <p>By treating everything as a holon\u2014a self-describing, active entity with properties, relationships, and behaviors (dances)\u2014we allow developers to extend the platform in ways that we, as the platform creators, could never fully predict.</p> <p>This means that instead of waiting for a central authority to add a new type, developers can create their own types and relationships as needed. They can share these extensions in a commons, fostering a rich ecosystem of visualizers, application behaviors, and more.</p>"},{"location":"mapp-dev/extensibility-model/#how-extensibility-works","title":"How Extensibility Works","text":"<p>The design goal is to: - Provide strong guarantees about structural compatibility. - Enable application-level innovation without duplicating or rewriting core definitions. - Preserve semantic integrity by constraining what \u201cextension\u201d means.</p> <p>The MAP\u2019s extensibility model is guided by clear, predictable rules that keep extensions simple, DRY (Don\u2019t Repeat Yourself), and interoperable:</p> <ol> <li> <p>Single Inheritance Only    Each new type can extend exactly one other type. There is no multiple inheritance. You inherit all properties, relationships, and dances from that single parent type.</p> </li> <li> <p>Additive, Not Subtractive    When you extend a type, you adopt all of its existing behaviors wholesale. You can add new behaviors, but you do not remove or override inherited ones. This keeps inheritance additive and predictable.</p> </li> <li> <p>Flattened Type Descriptors    The system flattens all inherited properties, relationships, and dances into a single type descriptor for the child type. You only specify what\u2019s unique about your new type; all common behavior is defined once and inherited automatically.</p> </li> <li> <p>Alternative for Variations    If you need a different set of behaviors, you start from a different parent type or reintroduce only the behaviors you want via composition. You avoid erasing or modifying inherited features directly.</p> </li> <li> <p>Extending Across Type Kinds    Extensibility is not limited to holon types. You can extend value types, property types, relationship types, and dance types. This allows you to evolve the ontology across all type kinds.</p> </li> <li> <p>Community and Self-Defined Extensions    You can extend not just core types, but also types defined by yourself or other MAP adopters. This makes the ecosystem a living, collaborative space where new types can evolve organically.</p> </li> <li>Leaf-Only Instantiation    Only the final (leaf) type in an Extends chain can be instantiated. All properties, relationships, and dances from parent types are flattened into the leaf type\u2019s descriptor, ensuring there is a single, complete definition for every instance. Intermediate types serve only as templates for shared structure and behavior, never as instantiable entities.</li> <li>Single Implementation per Dance    Every dance type defined anywhere in an Extends chain can have only one implementation within that chain. Implementations are bound to the type level that defines the dance type and may reference only properties and relationships defined at that level or above. You cannot \"override\" the implementation of a dance defined higher in the extends chain. Thus, if you do not want a dance (or property or relationship) of a type, do not extend that type.</li> </ol>"},{"location":"mapp-dev/extensibility-model/#core-types-as-your-starting-point","title":"Core Types as Your Starting Point","text":"<p>Although the MAP represents everything as a holon, you don\u2019t have to start from a blank slate. The platform ships with a rich foundation of Core Types \u2014 fully-defined, concrete holon types like <code>Meme</code>, <code>Agent</code>, <code>Service</code>, <code>VitalCapital</code>, <code>MemeGroup</code>, and <code>Memeplex</code>. These types already encapsulate key MAP semantics and relationships, giving you a solid base to extend from.</p> <p>When you extend a core type: - You inherit its properties, relationships, and dances. - You avoid re-defining the foundational semantics that MAP tools and visualizers expect. - You stay aligned with the larger ecosystem, improving interoperability with other mapps.</p> <p>Use of these core types is entirely optional. If your domain requires something fundamentally different, you can extend directly from <code>Holon</code> (the most general concrete type) or even create your own abstract type to serve as a base.</p> <p>A common mental model looks like this:</p> <pre><code>       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502       Meta Types         \u2502  (abstract obligations: structure of types)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502    Abstract Types        \u2502  (conceptual categories, no instances)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502     Core Types Layer     \u2502  (instantiable MAP-provided bases: Meme, Agent...)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502  Extension Types Layer   \u2502  (your domain-specific types)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>A powerful feature: You can extend not only core types, but also types defined by other MAP developers. This means the ontology can evolve in ever richer, more specialized ways \u2014 collaboratively and incrementally \u2014 without requiring changes to the core. The result is a living ecosystem of interoperable types, each building on the work of others.</p> <p>Pro tip for mapp developers: If you find yourself removing or avoiding core behaviors from a parent type, it may be better to pick a different starting point \u2014 either another core type, a type from another developer, or <code>Holon</code> itself \u2014 so you keep your inheritance clean and predictable.</p>"},{"location":"mapp-dev/extensibility-model/#an-example","title":"An Example","text":"<p>Let's look at an example to see how these rules work in action.</p>"},{"location":"mapp-dev/extensibility-model/#1-leaf-only-instances","title":"1. Leaf-Only Instances","text":"<p>If you have <code>A</code> Extends <code>B</code> Extends <code>Meme</code>, only A can have instances. - Properties and relationships from all levels are flattened into <code>A</code>\u2019s descriptor. - Your instance is \u201can A\u201d with one set of properties and relationships to populate. - Intermediate types (<code>B</code>, <code>Meme</code>) serve as templates for shared structure and behavior, but are never instantiated directly.</p>"},{"location":"mapp-dev/extensibility-model/#2-separate-the-contract-from-the-implementation","title":"2. Separate the Contract from the Implementation","text":"<p>Every dance has two aspects: - DanceDescriptor (contract): Name, arguments, result type, semantics, and required/optional status. - DanceImplementation (code): The executable logic, bound to the type that defines it.</p> <p>MAP preserves the contract vs. implementation distinction without introducing a separate \u201cinterface\u201d construct. Obligations are explicit in the type descriptor; the code is provided at the defining type.</p>"},{"location":"mapp-dev/extensibility-model/#3-where-implementations-may-live","title":"3. Where Implementations May Live","text":"<p>A DanceImplementation can be declared in: - The MAP Core Type you extended (e.g., <code>Meme</code>) - An intermediate type in the chain (<code>B</code>) - Your own leaf type (<code>A</code>)</p> <p>Instances always dispatch to the single implementation allowed for that descriptor in the chain.</p>"},{"location":"mapp-dev/extensibility-model/#4-rules-that-avoid-overrides","title":"4. Rules that Avoid Overrides","text":"<p>To keep things predictable, DRY, and override-free:</p> <ol> <li>Only the leaf instantiates \u2014 No instances of intermediate types.</li> <li>Unique dance identity across the chain \u2014 No two types in the chain may declare the same DanceDescriptor ID.</li> <li>Single implementation per dance per chain \u2014 At most one implementation for a given descriptor in the chain.</li> <li>If required and none found \u2192 validation fails.</li> <li>If optional and none found \u2192 allowed.</li> <li>If more than one found \u2192 validation fails.</li> <li>Bound to defining type \u2014 Implementations may only reference properties and relationships defined at their own level or above.</li> <li>Different behavior without overrides \u2014 If you need different logic, define a new (possibly versioned) DanceDescriptor or choose a different parent type.</li> </ol>"},{"location":"mapp-dev/extensibility-model/#5-effective-set-computation-loadvalidation-time","title":"5. Effective Set Computation (Load/Validation Time)","text":"<p>At load or validation time, MAP precomputes the EffectiveDanceSet for your leaf type:</p> <pre><code>EffectiveDanceSet(A):\n  let chain = [Meme, B, A]  // ancestor \u2192 leaf\n  let seen = {}\n  for each type T in chain:\n    for each DanceImplementation impl in T:\n      let id = impl.descriptor_id\n      if id in seen: error \"multiple implementations in chain\"\n      seen[id] = impl\n\n  // Ensure all required descriptors in chain have an implementation\n  for each required descriptor d in chain:\n      if d.id not in seen: error \"required dance missing\"\n\n  return seen\n</code></pre> <p>This means your mapp instances dispatch directly to the right implementation with no runtime search and no ambiguity.</p>"},{"location":"mapp-dev/extensibility-model/#benefits-for-developers","title":"Benefits for Developers","text":"<ul> <li>Clarity: No tangled multiple-inheritance chains or runtime delegation puzzles.</li> <li>Predictability: The full definition of a type is always visible in its flattened descriptor.</li> <li>Reusability: Shared behavior is defined once and reliably inherited.</li> <li>Interoperability: Extensions preserve all inherited relationships and obligations, ensuring they work seamlessly with existing MAP tooling.</li> </ul>"},{"location":"mapp-dev/extensibility-model/#comparison-to-traditional-inheritance-models","title":"Comparison to Traditional Inheritance Models","text":"<p>The MAP\u2019s model differs from common inheritance patterns found in mainstream programming languages:</p> <ul> <li>Classical OOP Inheritance (Java, C++)   These languages often allow single or multiple inheritance. Multiple inheritance can lead to the diamond problem, where it\u2019s unclear which inherited method should be used. The MAP avoids this entirely by allowing only single inheritance and flattening all inherited elements into one unified type descriptor.</li> <li> <p>Interfaces and Mixins (Java Interfaces, Ruby Modules)</p> </li> <li> <p>In languages like Java, interfaces separate the contract (what behaviors a type must provide) from the implementation (how those behaviors are carried out), to avoid the pitfalls of tying the two together in rigid inheritance chains. Mixins add reusable behavior across otherwise unrelated types.   In the MAP, this separation is preserved but modeled explicitly through the type system: a holon\u2019s type descriptor declares its obligations (its contract) via inherited properties, relationships, and required dances, while the actual implementation of those dances can be provided or overridden in the specific type or its runtime context. This makes contracts explicit without introducing a separate interface construct, and still allows behaviors to be composed or reused across types.</p> </li> <li> <p>Delegation and Composition (Go Interfaces, \u201ccomposition over inheritance\u201d)   Composition-based designs assemble objects from multiple components, often requiring explicit delegation. The MAP achieves similar modularity by letting you start from the most relevant parent type and additively extend it, while maintaining a single, flattened descriptor. You get the clarity of composition without the overhead of managing multiple internal objects.</p> </li> </ul> <p>By combining inheritance\u2019s clarity with composition\u2019s modularity, the MAP ensures that extensions are both powerful and easy to reason about.</p>"},{"location":"mapp-dev/extensibility-model/#conclusion","title":"Conclusion","text":"<p>By combining a stable foundation of core concrete types with a disciplined, flattened, single-inheritance model, the MAP gives developers a robust but simple way to extend the platform. You inherit everything you need from your parent type, add only what\u2019s unique, and know that your type will integrate cleanly into the larger ecosystem. This balance of openness and structure is what allows the MAP to evolve in step with the diverse needs of its community.  </p>"},{"location":"mapp-dev/holon-data-loader-guide/","title":"MAP Holon Data Loader: JSON Import Format \u2013 Comprehensive Authoring Guide","text":"<p>This guide provides developers with a complete and authoritative reference for constructing valid JSON import files for the MAP Holon Data Loader. It reflects current conventions for authoring schema definitions, base/core types, and domain-specific instances in a self-describing, holonic data model.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#overview","title":"\u2728 Overview","text":"<p>The MAP Holon Data Loader allows for the declarative import of holons and their relationships into a (single) MAP Holon Space. The import format is intentionally minimal, self-describing, and designed for bootstrapping both type descriptors and real data without relying on runtime logic.</p> <p>All holons \u2014 including types, schemas, and instances \u2014 are defined uniformly. Their type, structure, and descriptors are all expressible using the same format.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#foundational-concepts","title":"\ud83d\udcda Foundational Concepts","text":"<p>MAP import files are composed of holons \u2014 self-contained objects representing types, data, or components. This section introduces key concepts that underpin the entire format.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#holons-and-types","title":"Holons and Types","text":"<p>Every holon has a <code>type</code> that points to a type descriptor (e.g., <code>BookType</code>, <code>PropertyType</code>). The type is used to determine:</p> <ul> <li>What properties are allowed</li> <li>What relationships can be included</li> <li>How validation is applied</li> </ul> <p>The <code>type</code> field acts as both a signal and a shortcut. It removes the need to include an explicit <code>DescribedBy</code> relationship.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#keyed-vs-keyless-holon-types","title":"Keyed vs. Keyless Holon Types","text":"<p>Every holon in MAP is an instance of a HolonType, and that HolonType determines whether instances are keyed or keyless.</p> <ul> <li>Keyed Holon Types require that each instance includes a stable <code>key</code>, derived from one or more of its properties using a <code>UsesKeyRule</code>. Holons of these types:</li> <li>Must include a <code>key</code> field in the JSON import</li> <li>May be referenced elsewhere using <code>$ref</code></li> <li> <p>May be the target of declared relationships</p> </li> <li> <p>Keyless Holon Types do not permit their instances to include a key. Holons of these types:</p> </li> <li>Must be embedded inline wherever they are used</li> <li>May not be referenced via <code>$ref</code> (not even by <code>id:</code>)</li> <li>May not be the target of any declared relationship</li> <li>Must act as the source of at least one relationship to a keyed holon (to remain anchored in the graph)</li> </ul> <p>This distinction is structural and enforced during staging. The loader will reject any violation of these rules \u2014 including attempts to reference or directly target a keyless holon.</p> <p>\ud83d\udd0d Whether a holon is keyed is not an authoring choice \u2014 it is defined by the HolonType it instantiates.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key-derivation-rules","title":"\ud83d\udd22 Key Derivation Rules","text":"<p>Every keyed holon must declare a <code>UsesKeyRule</code>, pointing to a <code>FormatKeyRule</code> with:</p> <ul> <li><code>format</code>: A string template (e.g., <code>\"$0\"</code>, <code>\"($0)-[$1]-&gt;($2)\"</code>)</li> <li><code>property_names</code>: List of property or inferred names used to fill the format</li> </ul> <p>The authored <code>key</code> must match the result of evaluating the format rule.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#foundational-rule-for-all-types","title":"\ud83e\uddf1 Foundational Rule for All Types","text":"<p>Every MAP type descriptor (e.g., <code>BookType</code>, <code>PropertyType</code>, <code>MetaHolonType</code>) must:</p> <ul> <li>\u2705 Be DescribedBy the <code>MetaHolonType</code> \u2014 this defines the meta-structure of the type descriptor itself</li> <li>\u2705 Extend the foundational <code>MetaTypeDescriptor</code> \u2014 inheriting shared fields like <code>type_name</code>, <code>description</code>, etc.</li> </ul> <p>This rule applies uniformly to all types in MAP, including both core types (like <code>PropertyType</code>, <code>SchemaType</code>) and meta-types (like <code>MetaHolonType</code>, <code>MetaSchemaType</code>). It ensures:</p> <ul> <li>\ud83d\udd04 Reflexivity \u2014 Types are holons too</li> <li>\ud83d\udd0d Introspection \u2014 Schema tools can explore and validate all descriptors using a shared structure</li> <li>\ud83e\uddf1 Composability \u2014 Specialized descriptors build on common foundations</li> </ul> <p>\ud83e\udde0 Even <code>MetaHolonType</code> itself is DescribedBy the <code>MetaHolonType</code> and Extends <code>MetaTypeDescriptor</code>.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#holontype-requirements","title":"\ud83d\udd10 HolonType Requirements","text":"<p>In addition to the foundational rule above, all HolonTypes must:</p> <ul> <li>\u2705 Declare a <code>UsesKeyRule</code> \u2014 either a formatting rule (e.g., <code>TypeName.KeyRule</code>) or <code>None.KeyRule</code></li> </ul> <p>This ensures that the distinction between keyed and keyless types is structurally enforced and discoverable via introspection.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#best-practices","title":"\ud83d\udcda Best Practices","text":"<ul> <li>\u2705 Include <code>UsesKeyRule</code> for every HolonType descriptor</li> <li>\u2705 Use consistent naming across <code>type_name</code>, <code>display_name</code>, and <code>key</code></li> <li>\u2705 Use inline embedding for keyless holons or unique instances</li> <li>\u2705 Use <code>$ref</code> for reusable, keyed holons</li> <li>\u274c Do not author <code>DescribedBy</code> or <code>OwnedBy</code> \u2014 these are handled automatically</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#referencing-other-holons-ref-and-inline-embedding","title":"Referencing Other Holons: <code>$ref</code> and Inline Embedding","text":"<p>In MAP\u2019s JSON import format, holons frequently refer to other holons \u2014 whether to define relationships, specify constraints, compose schemas, or extend descriptors. These references can be expressed in one of two interchangeable forms:</p> <ol> <li><code>$ref</code> strings \u2014 Concise pointers to other keyed holons</li> <li>Inline embedded holons \u2014 Full holon objects defined in place</li> </ol> <p>Both forms are valid anywhere a holon is expected, and the Holon Data Loader treats them equivalently when staging, validating, and committing.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#motivation-reference-scenarios-map-must-support","title":"\ud83e\udde0 Motivation: Reference Scenarios MAP Must Support","text":"Scenario Example Staged vs. Saved Refer to holons defined in the same file or already saved in the space Local vs. External Link to holons from another HolonSpace (e.g., shared schemas) Keyed vs. Keyless <code>$ref</code> keyed holons; embed keyless ones Reusable vs. One-Off Reuse types and entities via <code>$ref</code>; define constraints inline"},{"location":"mapp-dev/holon-data-loader-guide/#ref-semantics","title":"\ud83e\udded <code>$ref</code> Semantics","text":"<p><code>$ref</code> is a string-based shorthand for referencing previously defined, saved, or external keyed holons. It can be used anywhere a holon is expected and the type can be inferred from context.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#supported-ref-formats","title":"Supported <code>$ref</code> Formats","text":"<code>$ref</code> Format Meaning Example <code>\"#key\"</code> Reference to a keyed holon by key only <code>\"#future-primal\"</code> <code>\"id:&lt;HolonId&gt;\"</code> Reference by ActionHash (HolonId) <code>\"id:uhCAkYmv...\"</code> <code>\"@Proxy:key\"</code> External holon via proxy name + key <code>\"@Library:Books\"</code> <code>\"ext:&lt;Proxy&gt;:&lt;Id&gt;\"</code> External holon via proxy ID + local ID <code>\"ext:uhProxy:uhId\"</code> <p>\ud83d\udd0d The holon\u2019s type is inferred from context. If the key does not match a holon of the expected type, validation will fail.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#inline-embedded-holons","title":"\ud83d\udce6 Inline Embedded Holons","text":"<p>Use inline embedding to define a holon directly in context. This is required for:</p> <ul> <li>Keyless holons</li> <li>One-off structures, like constraints or descriptors</li> <li>Situations where local scoping improves clarity</li> </ul> <p>Caveat: Each inline Holon is importing a new Holon, be careful to avoid unwanted duplication</p>"},{"location":"mapp-dev/holon-data-loader-guide/#reference-examples","title":"\u2705 Reference Examples","text":"<p>TBD</p>"},{"location":"mapp-dev/holon-data-loader-guide/#invalid-reference-cases","title":"\ud83d\udeab Invalid Reference Cases","text":"<ul> <li>\u274c <code>$ref</code> to a keyless holon (must be embedded)</li> <li>\u274c <code>id:</code> reference to a keyless holon \u2014 even though syntactically allowed, keyless holons must never be the target of a declared relationship</li> <li>\u274c References outside expected type context</li> <li>\u274c Mixing <code>$ref</code> and <code>type</code> in a single object</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#summary","title":"\u2705 Summary","text":"Reference Form Best For Requires Key Reusable? <code>$ref</code> Reuse of shared or saved holons \u2705 Yes \u2705 Yes Inline One-off or keyless components \u274c No \u274c No"},{"location":"mapp-dev/holon-data-loader-guide/#file-structure","title":"\ud83d\udcc1 File Structure","text":"<p>Each JSON import file consists of two top-level keys:</p> <pre><code>{\n  \"meta\": { ... },\n  \"holons\": [ ... ]\n}\n</code></pre> <ul> <li><code>meta</code>: Metadata describing the file</li> <li><code>holons</code>: List of holon definitions to be imported</li> </ul> <p>Each entry in the <code>holons</code> array is a self-contained JSON object representing a single holon.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#holon-definition","title":"\ud83d\udd39 Holon Definition","text":"<p>Each holon is a JSON object with four primary fields:</p> <ul> <li><code>type</code>: The descriptor for this holon (replaces <code>DescribedBy</code>)</li> <li><code>key</code>: Required only for keyed holons</li> <li><code>properties</code>: A map of named scalar property values</li> <li><code>relationships</code>: A list of outbound relationships to other holons</li> </ul> <p>See the Foundational Concepts section above for background on types, keys, references, and embedding.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#type","title":"\ud83e\udde9 <code>type</code>","text":"<p>The <code>type</code> field identifies the HolonType (or other descriptor type) that describes this holon. It replaces the need to author a <code>DescribedBy</code> relationship.</p> <ul> <li>Format: a <code>#Key</code> reference to a known type descriptor</li> <li>Required for all holons</li> </ul> <p>Example:</p> <pre><code>\"type\": \"#BookType\"\n</code></pre> <p>This implies: - The holon is described by a <code>BookType</code> - All properties and relationships must conform to the rules defined by that type</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key","title":"\ud83e\udde9 <code>key</code>","text":"<p>The <code>key</code> is a unique identifier for keyed holons. It is:</p> <ul> <li>Required for holons of keyed Holon Types</li> <li>Not allowed for holons of keyless Holon Types</li> <li>Used as the reference target for <code>$ref</code> within the same or other import files</li> </ul> <p>Keys are derived based on the holon\u2019s HolonType, which includes a <code>UsesKeyRule</code> relationship pointing to a <code>FormatKeyRule</code>. This rule specifies how to construct the key from the holon\u2019s property values \u2014 and sometimes values on related holons.</p> <p>\ud83d\udd04 Because the key can be deterministically derived from the holon\u2019s structure, including it is technically redundant. However, the <code>key</code> field is explicitly included in the JSON import for: - Improved readability - <code>$ref</code> compatibility - Validation of key correctness at staging time</p>"},{"location":"mapp-dev/holon-data-loader-guide/#important","title":"\u26a0\ufe0f Important","text":"<p>If any property value involved in key derivation changes, the <code>key</code> field and any <code>$ref</code>'s to it must also be updated to match the new derived value. The loader will recompute the key using the declared <code>FormatKeyRule</code> and compare it to the authored key \u2014 raising a validation error if they do not match.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key-derivation-rules_1","title":"\ud83d\udd22 Key Derivation Rules","text":"<p>Every keyed holon must declare a <code>UsesKeyRule</code> relationship pointing to a <code>FormatKeyRule</code> \u2014 a holon that defines how the key should be constructed.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#formatkeyrule-structure","title":"FormatKeyRule Structure","text":"<p>A <code>FormatKeyRule</code> has two fields:</p> <ul> <li><code>format</code>: A string template (e.g., <code>\"$0\"</code>, <code>\"($0)-[$1]-&gt;($2)\"</code>)</li> <li><code>property_names</code>: An ordered list of names (strings) that supply the values for the placeholders</li> </ul> <p>Example:</p> <pre><code>{\n  \"type\": \"#FormatKeyRule\",\n  \"properties\": {\n    \"format\": \"$0\",\n    \"property_names\": [\"type_name\"]\n  }\n}\n</code></pre>"},{"location":"mapp-dev/holon-data-loader-guide/#common-patterns","title":"\u2705 Common Patterns","text":"<p>Single-property key (e.g., <code>MapStringValueType</code>): <pre><code>{\n  \"format\": \"$0\",\n  \"property_names\": [\"type_name\"]\n}\n</code></pre></p> <p>**Relationship Type Keys ** (inspired by OpenCypher notation): <pre><code>{\n  \"format\": \"($0)-[$1]-&gt;($2)\",\n  \"property_names\": [\"source_type\", \"type_name\", \"target_type\"]\n}\n</code></pre></p>"},{"location":"mapp-dev/holon-data-loader-guide/#declaring-useskeyrule","title":"\u270d\ufe0f Declaring UsesKeyRule","text":"<p>Inline:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": {\n    \"type\": \"#FormatKeyRule\",\n    \"properties\": {\n      \"format\": \"$0\",\n      \"property_names\": [\"type_name\"]\n    }\n  }\n}\n</code></pre> <p>By reference:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": { \"$ref\": \"FormatKeyRule:BookType.KeyRule\" }\n}\n</code></pre> <p>The loader validates all authored <code>key</code> values by recomputing them using the declared key rule and comparing the result.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#properties","title":"\ud83e\udde9 <code>properties</code>","text":"<p>The <code>properties</code> field contains a map of property name to scalar value, like so:</p> <pre><code>\"properties\": {\n  \"type_name\": \"BookType\",\n  \"enabled\": true,\n  \"max_length\": 255\n}\n</code></pre> <p>Each value must be one of the supported MAP scalar types: - <code>string</code> (e.g., <code>\"BookType\"</code>) - <code>number</code> (e.g., <code>42</code>, <code>3.14</code>) - <code>boolean</code> (e.g., <code>true</code>, <code>false</code>) - or an array of scalars (for multi-valued properties)</p> <p>Property types are enforced by the <code>PropertyType</code> descriptor referenced in the holon\u2019s <code>type</code>. The loader will convert each value into its appropriate <code>BaseValue</code> variant based on the declared value type \u2014 not based on any in-band <code>\"type\"</code> or <code>\"value\"</code> tags.</p> <p>\ud83d\udd12 Property values must be scalars. You cannot use structured objects (like <code>{ \"type\": ..., \"value\": ... }</code>) inside the <code>properties</code> field. Those are only valid in embedded holons or type definitions.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#relationships","title":"\ud83e\udde9 <code>relationships</code>","text":"<p>In MAP, every relationship pair is modeled as two named, uni-directional relationships:</p> <ul> <li>A declared relationship (e.g., <code>(Person)-[HasAddress]-&gt;(Address)</code>)</li> <li>Its corresponding inverse relationship (e.g., <code>(Address)-[AddressOf]-&gt;(Person)</code>)</li> </ul> <p>Strictly speaking, only declared relationships are allowed to be directly populated in the system\u2019s internal storage model. Inverse relationships are automatically derived based on this. However, the JSON import format allows you to populate either direction for convenience.</p> <p>If a JSON import populates an inverse relationship, the Holon Data Loader will:</p> <ol> <li>Look up its <code>InverseOf</code> link to find the declared relationship type.</li> <li>Internally redirect the population to that declared relationship.</li> <li>Leave the inverse direction empty (it will be auto-derived later).</li> </ol> <p>This supports a more natural and readable JSON layout in many scenarios.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#authoring-guidelines","title":"\u26a0\ufe0f Authoring Guidelines","text":"<ul> <li> <p>\u2705 Only populate one direction of a relationship pair.   Do not populate both <code>HasAddress</code> and <code>AddressOf</code>.</p> </li> <li> <p>\u26a0\ufe0f If the relationship involves a keyless holon type:</p> </li> <li>The declared relationship must be defined on the keyed holon type.</li> <li>You must embed the keyless holon inline, using the inverse direction.</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#example-embedding-a-keyless-holon","title":"\u2705 Example: Embedding a Keyless Holon","text":"<p>Let\u2019s say <code>PersonType</code> declares the relationship <code>HasAddress \u2192 AddressType</code>, and <code>AddressType</code> is keyless. We want to attach an address to a person:</p> <pre><code>{\n  \"type\": \"#PersonType\",\n  \"key\": \"charles-eisenstein\",\n  \"properties\": {\n    \"name\": \"Charles Eisenstein\"\n  },\n  \"relationships\": [\n    {\n      \"name\": \"AddressOf\",  // inverse of declared \"HasAddress\"\n      \"target\": {\n        \"type\": \"#AddressType\",  // keyless, so must be embedded\n        \"properties\": {\n          \"city\": \"Keene\",\n          \"state\": \"New Hampshire\"\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"mapp-dev/holon-data-loader-guide/#explanation","title":"\ud83e\udde0 Explanation","text":"<ul> <li><code>AddressType</code> is keyless \u2192 it must not be the target of a declared relationship.</li> <li><code>PersonType</code> declares <code>HasAddress \u2192 AddressType</code></li> <li>JSON authors embed the keyless <code>Address</code> and populate its inverse relationship, <code>AddressOf \u2192 Person</code></li> <li>The loader internally flips it and populates <code>HasAddress(charles-eisenstein \u2192 [Address])</code></li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#declared-vs-inverse-relationships","title":"\ud83d\udd01 Declared vs. Inverse Relationships","text":"<p>When importing instance holons, each outbound <code>relationship</code> must ultimately correspond to a declared relationship \u2014 that is, a relationship defined as outbound from the holon\u2019s type.</p> <p>However, the MAP import format allows you to use either direction of a relationship pair when authoring instance data:</p> <ul> <li>A declared relationship, such as:   <pre><code>(Book)-[AUTHORED_BY]-&gt;(Person)\n</code></pre></li> <li>Its corresponding inverse relationship, such as:   <pre><code>(Person)-[AuthorOf]-&gt;(Book)\n</code></pre></li> </ul> <p>These two together form a relationship pair, where one is marked as the <code>InverseOf</code> the other in its relationship type definition.</p> <p>\ud83d\udd04 Even though only declared relationships are persisted, the loader will redirect inverse relationship usage to the appropriate declared relationship and populate it accordingly.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#authoring-either-direction","title":"\u2705 Authoring Either Direction","text":"<p>In your JSON import file, you may use either side:</p> <pre><code>{\n  \"name\": \"AUTHORED_BY\",\n  \"target\": { \"$ref\": \"person-789\" }\n}\n</code></pre> <p>or:</p> <pre><code>{\n  \"name\": \"AuthorOf\",\n  \"target\": { \"$ref\": \"book-123\" }\n}\n</code></pre> <p>Either form will result in the declared <code>AUTHORED_BY</code> relationship being populated.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#authoring-guidelines_1","title":"\u26a0\ufe0f Authoring Guidelines","text":"<ul> <li> <p>\u2705 Only populate one direction of a relationship pair.   Do not populate both <code>AUTHORED_BY</code> and <code>AuthorOf</code> \u2014 choose one or the other.</p> </li> <li> <p>\u26a0\ufe0f If one end of the relationship is a keyless holon (e.g., an inline annotation or constraint):</p> </li> <li>The keyless holon\u2019s type must declare the relationship.</li> <li>You must populate the inverse direction using an embedded target, not a <code>$ref</code>.</li> </ul> <p>\ud83e\udde0 Internally, only declared relationships are directly populated. The system automatically backfills the corresponding inverse relationships.</p> <p>A separate section provides guidance on defining declared and inverse relationship types, and how the <code>InverseOf</code> and <code>Inverse</code> links connect them.</p> <p>In MAP, every relationship pair is modeled as two named, uni-directional relationships:</p> <ul> <li>A declared relationship (e.g., <code>(Book)-[AuthoredBy]-&gt;(Person)</code>)</li> <li>Its corresponding inverse relationship (e.g., <code>(Person)-[AuthorOf]-&gt;(Book)</code>)</li> </ul> <p>Strictly speaking, only declared relationships are allowed to be directly populated in the system\u2019s internal storage model. Inverse relationships are automatically derived based on this. However, the JSON import format allows you to populate either direction for convenience.</p> <p>If a JSON import populates an inverse relationship, the Holon Data Loader will:</p> <ol> <li>Look up its <code>InverseOf</code> link to find the declared relationship type.</li> <li>Internally redirect the population to that declared relationship.</li> <li>Leave the inverse direction empty (it will be auto-derived later).</li> </ol> <p>This supports a more natural and readable JSON layout in many scenarios.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#example-using-inverse-in-json","title":"\u2705 Example: Using Inverse in JSON","text":"<p>You may populate the <code>Extends</code> relationship directly:</p> <pre><code>{\n  \"name\": \"Extends\",\n  \"target\": { \"$ref\": \"MetaTypeDescriptor\" }\n}\n</code></pre> <p>Or, equivalently, populate the inverse <code>ExtendedBy</code>:</p> <pre><code>{\n  \"name\": \"ExtendedBy\",\n  \"target\": {\n    \"type\": \"#MetaHolonType\",\n    \"properties\": {\n      \"type_name\": \"MetaHolonType\"\n    }\n  }\n}\n</code></pre> <p>Both will result in the same internal relationship being established \u2014 on the declared <code>Extends</code> direction.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#authoring-rules-and-caveats","title":"\u26a0\ufe0f Authoring Rules and Caveats","text":"<p>To ensure consistency and correctness, observe the following:</p> <ul> <li>\u2705 Only one direction of a relationship pair should be populated in your JSON file.</li> <li>\u2705 If you choose to use the inverse relationship in your JSON, ensure the inverse type includes an <code>InverseOf</code> link to its declared counterpart.</li> <li>\u26a0\ufe0f If either source or target holon type in the relationship is keyless:</li> <li>That keyless type must declare the relationship (i.e., be the source of the declared direction).</li> <li>The inverse direction must be populated inline, via embedded holons \u2014 since keyless holons cannot be referenced.</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#relationship-pairing-inverseof-and-inverse","title":"\ud83d\udd04 Relationship Pairing: <code>InverseOf</code> and <code>Inverse</code>","text":"<p>Each inverse relationship must include an <code>InverseOf</code> link to its declared counterpart:</p> <pre><code>{\n  \"name\": \"InverseOf\",\n  \"target\": { \"$ref\": \"#(RelationshipType)-[Extends]-&gt;(RelationshipType)\" }\n}\n</code></pre> <p>Once this is present, the system automatically adds the reverse link using <code>Inverse</code>:</p> <pre><code>{\n  \"name\": \"Inverse\",\n  \"target\": { \"$ref\": \"#(RelationshipType)-[ExtendedBy]-&gt;(RelationshipType)\" }\n}\n</code></pre> <p>You do not need to author <code>Inverse</code> links directly.</p> <p>==== OLDER STUFF</p> <p>The <code>relationships</code> field is a list of outbound links from the holon to other holons.</p> <p>Each entry must contain: - <code>name</code>: the name of the relationship - <code>target</code>: a single holon, a <code>$ref</code>, or an array of either</p> <p>You may use either of the following forms:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": { \"$ref\": \"FormatKeyRule:Book.KeyRule\" }\n}\n</code></pre> <p>or</p> <pre><code>{\n  \"name\": \"Components\",\n  \"target\": [\n    { \"$ref\": \"BookType\" },\n    { \"$ref\": \"PersonType\" }\n  ]\n}\n</code></pre> <p>\u2705 The loader automatically normalizes all <code>target</code> values to arrays. Even single references are treated as 1-element arrays internally.</p> <p>\u26a0\ufe0f Cardinality constraints are enforced using the type descriptor associated with the relationship name. For example, relationships like <code>DescribedBy</code> or <code>ComponentOf</code> often have <code>max_cardinality = 1</code>.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#embedded-schema-structure","title":"\ud83d\udcc2 Embedded Schema Structure","text":"<p>Schemas may embed their components directly via inverse relationships:</p> <pre><code>{\n  \"type\": \"#MapSchemaType\",\n  \"key\": \"MAP Core Schema\",\n  \"relationships\": [\n    {\n      \"name\": \"Components\",\n      \"target\": [ { holon }, { holon } ]\n    }\n  ]\n}\n</code></pre> <p>These will be rewritten by the loader into <code>ComponentOf</code> declarations from each child.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#defining-the-relationships-for-a-type","title":"Defining the Relationships for a Type:","text":""},{"location":"mapp-dev/holon-data-loader-guide/#declaring-vs-instantiating-relationships","title":"\ud83d\udd04 Declaring vs. Instantiating Relationships","text":"<p>In the MAP import format, it is essential to distinguish between two conceptually distinct usages of relationships:</p>"},{"location":"mapp-dev/holon-data-loader-guide/#1-declaring-allowed-relationships-for-a-type","title":"1. Declaring Allowed Relationships for a Type","text":"<p>When defining a type descriptor, we use the <code>InstanceRelationships</code> relationship to declare what kinds of relationships instances of this type may include. The targets of <code>InstanceRelationships</code> must be relationship types.</p> <p>Example:</p> <pre><code>{\n  \"name\": \"InstanceRelationships\",\n  \"target\": [\n    { \"$ref\": \"#(TypeDescriptor)-[ComponentOf]-&gt;(Schema)\" }\n  ]\n}\n</code></pre> <p>This states that instances of this type (e.g., <code>TypeDescriptor</code>) may include a <code>ComponentOf</code> relationship, and identifies the structural pattern expected for that relationship. The details of that relationship type (cardinality constraints, whether it is definitional, etc.) are defined in the referenced RelationshipType descriptor.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#2-instantiating-a-specific-relationship-for-a-holon","title":"2. Instantiating a Specific Relationship for a Holon","text":"<p>When authoring a specific holon, such as a type descriptor or instance, the <code>relationships</code> field is used to instantiate actual relationship instances. These entries must include:</p> <ul> <li>A <code>name</code>: the name of the relationship</li> <li>A <code>target</code>: the holon being linked to (typically via <code>$ref</code>)</li> </ul> <p>\u2705 Correct:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": { \"$ref\": \"#TypeName.KeyRule\" }\n}\n</code></pre> <p>\u274c Incorrect:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": {\n    \"type\": \"#Format.KeyRuleType\",\n    \"key\": \"TypeName.KeyRule\",\n    ...\n  }\n}\n</code></pre> <p>The incorrect version attempts to define the target inline \u2014 which may duplicate shared definitions and blur the separation of concerns between relationship declarations and relationship instances.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key-takeaway","title":"\ud83e\udded Key Takeaway","text":"<p>When declaring which relationships a type supports, point to relationship types. When instantiating a relationship in a holon, point to a target holon \u2014 typically via <code>$ref</code>.</p> <p>Following this rule ensures structural clarity, enables reuse, and keeps the MAP type system modular and DRY.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#key-derivation-rules_2","title":"\ud83d\udd22 Key Derivation Rules","text":"<p>Every keyed holon must declare a <code>UsesKeyRule</code>, pointing to a <code>FormatKeyRule</code> with:</p> <ul> <li><code>format</code>: A string template (e.g., <code>\"$0\"</code>, <code>\"($0)-[$1]-&gt;($2)\"</code>)</li> <li><code>property_names</code>: List of property or inferred names used to fill the format</li> </ul> <p>The authored <code>key</code> must match the result of evaluating the format rule.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#best-practices_1","title":"\ud83d\udcda Best Practices","text":"<ul> <li>\u2705 Include <code>UsesKeyRule</code> for every keyed type descriptor</li> <li>\u2705 Use consistent naming across <code>type_name</code>, <code>display_name</code>, and <code>key</code></li> <li>\u2705 Use inline embedding for keyless holons or unique instances</li> <li>\u2705 Use <code>$ref</code> for reusable, keyed holons</li> <li>\u274c Do not author <code>DescribedBy</code> or <code>OwnedBy</code> \u2014 these are handled automatically</li> </ul>"},{"location":"mapp-dev/holon-data-loader-guide/#validation","title":"\ud83d\udd0e Validation","text":"Rule ID Title Description Severity json-schema Syntactic validation via JSON Schema The file must conform to the MAP JSON import format schema. error foundational-rule Foundational Rule for All Type Descriptors Every Type Descriptor must be <code>DescribedBy</code> <code>TypeDescriptor</code> and <code>Extend</code> (at most) exactly 1 Abstract Type. error unresolved-refs Unresolved References All $ref values must resolve to a keyed holon defined in the same or explicitly provided files. error only-declared-properties Only Declared Properties May Be Populated Holons must not specify properties not listed in InstanceProperties of their type. error only-declared-relationships Only Valid Relationships May Be Authored The import file may only author relationships that are either: (1) explicitly listed in the holon\u2019s type descriptor via InstanceRelationships, or (2) valid inverse relationships, which are resolved via InverseRelationshipType definitions that point back to a DeclaredRelationshipType where the holon\u2019s type is the TargetType. The system applies updates through the canonical declared direction. error <p>Files should be validated against:</p> <ol> <li><code>bootstrap-import.schema.json</code> \u2014 ensures structural correctness</li> <li>Schema-specific definitions \u2014 derived from the loaded Meta-Schema or Core Schema</li> </ol> <p>Holons are further validated at runtime by MAP\u2019s shared validators.</p>"},{"location":"mapp-dev/holon-data-loader-guide/#ready-to-import","title":"\ud83c\udf89 Ready to Import","text":"<p>Once authored and validated, the file can be submitted to the Holon Data Loader.</p> <ul> <li>All <code>key</code> and <code>$ref</code> references will be resolved</li> <li>Relationships will be rewritten as needed</li> <li>Keyless holons will be embedded</li> <li>All imported holons will be linked to the HolonSpace via <code>OwnedBy</code></li> </ul> <p>For support, contact the MAP stewarding team or refer to the developer documentation.</p>"},{"location":"mapp-dev/tags_to_memes/","title":"\ud83e\udde0 From Tags to Memes: A Deep Reframing of Tagging in the Memetic Activation Platform (MAP)","text":""},{"location":"mapp-dev/tags_to_memes/#abstract","title":"Abstract","text":"<p>Tagging has long been used to annotate, organize, and discover content in digital environments. Most systems treat tags as flat strings \u2014 simple labels applied to objects \u2014 with minimal structure or semantic depth. The Memetic Activation Platform (MAP) introduces a new model that reimagines tagging as a memetic act, embedded in a rich and evolving semantic graph.</p> <p>In MAP, a tag is a Meme in role \u2014 an object-based conceptual unit participating in a <code>CLASSIFIES</code> relationship. Tags are not a special type, but an expression of memetic function. This shift enables tags to evolve from lightweight associations into richly connected nodes of meaning \u2014 or, in some cases, be reinterpreted as references to non-memetic Holons such as books, people, or organizations.</p> <p>This document situates MAP\u2019s approach within the broader landscape of tagging systems \u2014 from folksonomies and controlled vocabularies to semantic web ontologies \u2014 and highlights how it advances the state of the art.</p>"},{"location":"mapp-dev/tags_to_memes/#1-introduction","title":"1. Introduction","text":"<p>In platforms from Flickr to Twitter to Notion, tagging plays a key role in organizing content. Yet most implementations suffer from common limitations:</p> <ul> <li>Tags are strings, not concepts.</li> <li>No distinction between roles (e.g., topic vs. person vs. action).</li> <li>Little to no governance or semantic disambiguation.</li> <li>Limited pathways for tag evolution or refinement.</li> </ul> <p>MAP addresses these issues by grounding tags in its core memetic ontology. Every tag is a Meme \u2014 a semantic entity \u2014 and tagging is a type of relationship that can be upgraded, refined, or superseded over time.</p>"},{"location":"mapp-dev/tags_to_memes/#2-key-principle-tagging-is-a-role-not-a-type","title":"2. Key Principle: Tagging Is a Role, Not a Type","text":"<p>In MAP:</p> <ul> <li>Any Meme can act as a tag by participating in a <code>CLASSIFIES \u2192 Holon</code> relationship.</li> <li>There is no special \u201cTag\u201d type \u2014 tagging is a function of relationship semantics.</li> </ul> <p>This means:</p> <ul> <li>Tags retain the full expressive power of Memes.</li> <li>The same Meme can classify many Holons, appear in MemeGroups, or evolve into a richly defined concept.</li> </ul> <p>\u201c#capitalism\u201d isn\u2019t a just label \u2014 it\u2019s a Meme that classifies many Holons, relates to other Memes, and can carry definitions, translations, and curated context.</p>"},{"location":"mapp-dev/tags_to_memes/#3-two-evolutionary-paths-for-tags","title":"3. Two Evolutionary Paths for Tags","text":"<p>MAP uniquely recognizes that tags do not all evolve in the same way. Two primary evolutionary pathways exist:</p>"},{"location":"mapp-dev/tags_to_memes/#a-referent-disambiguation","title":"A. Referent Disambiguation","text":"<p>Some tags are initially applied to a Holon as a rough association \u2014 but later turn out to refer to a non-memetic entity.</p> <p>Example:</p> <p><code>#emerging-world</code> is used as a tag, but we later discover it refers to a Book called Emerging World. The proper model is to create a <code>Holon(Book)</code> and connect Roger Briggs to it via <code>AUTHOR_OF</code>.</p> <p>The original tag is now either:</p> <ul> <li>Superseded (no longer needed), or</li> <li>Retained for thematic linkage (e.g., <code>#emerging-world</code> still classifies the Book or Author loosely)</li> </ul> <p>This flow highlights MAP\u2019s ability to distinguish:</p> <ul> <li>Concepts (Memes) from</li> <li>Artifacts, Agents, or Works (Vital Capital, Projects, etc.)</li> </ul>"},{"location":"mapp-dev/tags_to_memes/#b-semantic-deepening","title":"B. Semantic Deepening","text":"<p>Other tags are Memes from the start \u2014 and grow in semantic richness over time.</p> <p>Example:</p> <p><code>#capitalism</code> starts as a tag. It then gains:</p> <ul> <li>A <code>DEFINED_BY</code> link</li> <li>Related Memes (e.g., <code>#socialism</code>, <code>#market-economy</code>)</li> <li>Multilingual equivalents</li> <li>Inclusion in curated groups (e.g., \"Economic Ideologies\")</li> </ul> <p>The tag doesn\u2019t refer to something else \u2014 it is the thing, and it matures into a high-gravity node in the memetic graph.</p>"},{"location":"mapp-dev/tags_to_memes/#4-comparison-with-existing-tagging-paradigms","title":"4. Comparison with Existing Tagging Paradigms","text":"Paradigm Characteristics MAP Distinctions Folksonomy (Web 2.0) Tags are freeform strings; no semantics; bottom-up MAP supports folksonomic tagging but uses object-based Memes and typed relationships Controlled Vocabularies Curated taxonomies; predefined terms; rigid MAP allows emergent structure, but supports curation and governance over time Semantic Web Tags as URIs; typed relationships; machine-readable MAP aligns with RDF-style models but prioritizes human-centered conceptual meaning Discourse-based models Tags reflect user sensemaking; meaning is emergent MAP embraces this, while providing infrastructure for long-term semantic enrichment"},{"location":"mapp-dev/tags_to_memes/#5-implementation-highlights","title":"5. Implementation Highlights","text":""},{"location":"mapp-dev/tags_to_memes/#51-tags-as-first-class-objects","title":"5.1 Tags as First-Class Objects","text":"<ul> <li>Every tag is a <code>Meme</code>, with a unique identifier and optional metadata.</li> <li>Memes can be defined, related, grouped, translated, and governed.</li> </ul>"},{"location":"mapp-dev/tags_to_memes/#52-tag-application-as-an-event","title":"5.2 Tag Application as an Event","text":"<p>Tagging can be represented as a <code>TagApplication</code> or <code>TagAssertion</code>, which may include:</p> <ul> <li>Who applied it</li> <li>When and where</li> <li>Why or in what context</li> <li>Whether it was later superseded by a stronger relationship</li> </ul>"},{"location":"mapp-dev/tags_to_memes/#53-multi-layered-meaning","title":"5.3 Multi-layered Meaning","text":"<p>A single Meme can:</p> <ul> <li>Function as a tag (<code>CLASSIFIES</code>)</li> <li>Be defined (<code>DEFINED_BY</code>)</li> <li>Be related (<code>RELATED_TO</code>, <code>CONTRASTS_WITH</code>)</li> <li>Exist in curated <code>MemeGroups</code> or <code>TagSets</code></li> <li>Be governed in <code>StewardedMemePools</code></li> </ul>"},{"location":"mapp-dev/tags_to_memes/#54-ui-and-ux-opportunities","title":"5.4 UI and UX Opportunities","text":"<ul> <li>Show semantic weight of tags (e.g., enriched vs. raw)</li> <li>Suggest upgrades (\u201cWould you like to mark this person as author of that book?\u201d)</li> <li>Offer tag disambiguation when multiple referents are likely</li> </ul>"},{"location":"mapp-dev/tags_to_memes/#6-why-this-matters","title":"6. Why This Matters","text":"<p>MAP\u2019s approach addresses long-standing challenges in tagging systems:</p> Challenge MAP's Answer Tags lack meaning Tags are Memes: semantically enrichable objects Tags are misapplied Disambiguation allows for correction and clarification Tags can't evolve Tags can deepen into structured, governed knowledge units Tagging is chaotic/brittle MAP supports emergent order and structured refinement <p>This model enables semantic infrastructure that can grow organically, integrating the best of folksonomy, controlled vocabularies, and ontology-based knowledge systems.</p>"},{"location":"mapp-dev/tags_to_memes/#7-conclusion","title":"7. Conclusion","text":"<p>MAP reframes tagging as a memetic function, not a flat annotation. By treating tags as Memes-in-role and allowing them to evolve \u2014 either toward deeper meaning or clearer referents \u2014 MAP bridges the gap between human conceptual creativity and formal semantic integrity.</p> <p>It doesn't just let people tag things \u2014 it lets meaning itself grow.</p>"},{"location":"mapp-dev/tags_to_memes/#8-future-directions","title":"8. Future Directions","text":"<ul> <li>Development of <code>TagApplication</code> schema</li> <li>Semantic weight scoring models</li> <li>UI/UX patterns for tag promotion and disambiguation</li> <li>Stewardship workflows for meme governance</li> <li>Alignment with broader memetic knowledge commons initiatives</li> </ul>"},{"location":"mapp-dev/trust-channel/","title":"\ud83e\ude70 We-Space Trust Channels in Action","text":""},{"location":"mapp-dev/trust-channel/#how-map-enforces-sovereignty-privacy-and-agreement-integrity","title":"How MAP Enforces Sovereignty, Privacy, and Agreement Integrity","text":"<p>This document uses the life-cycle of a DanceRequest to illustrate a deeper story: how the We-Space application layer and Trust Channel services in MAP protect data sovereignty and enforce agreements in a fully decentralized architecture.</p>"},{"location":"mapp-dev/trust-channel/#why-this-matters","title":"\ud83c\udfaf Why This Matters","text":"<p>The primary goals of the We-Space and its Trust Channels are:</p> <ol> <li> <p>Sovereignty and Privacy Without Central Servers    MAP Agents never need to trust a central authority with their data. All routing, validation, and exchange happens peer-to-peer, with no central custody of private information.</p> </li> <li> <p>Infrastructure-Level Security and Governance Enforcement    Authentication, authorization, cryptographic security, and privacy enforcement are built into MAP\u2019s infrastructure layer. This means application developers:</p> </li> <li>Don\u2019t have to implement security protocols themselves</li> <li>Can rely on consistent adherence to the signed promises in Agreements</li> <li>Work with validated, decrypted, role-checked requests \u2014 already safe to act upon</li> </ol> <p>By handling these steps before a request reaches an application\u2019s logic, the MAP ensures consistency, trust, and interoperability across the entire ecosystem.</p>"},{"location":"mapp-dev/trust-channel/#inbound-flow-envelopes-and-membrane-functions","title":"\ud83d\udce5 Inbound Flow: Envelopes and Membrane Functions","text":"<p>Every inbound DanceRequest travels through the We-Space membrane in a layered sequence of envelopes. Each envelope contains the information needed for the membrane function at that stage. The envelopes do not \u201cdo\u201d the work themselves \u2014 the Trust Channel functions act on the envelope\u2019s contents.</p>"},{"location":"mapp-dev/trust-channel/#1-transport-envelope-routing-function","title":"1. Transport Envelope \u2192 Routing Function","text":"<p>Envelope contains: - <code>agreement_id</code> \u2014 identifies governing Agreement - <code>sender_id</code> \u2014 request originator - <code>recipient_id</code> \u2014 intended receiver - <code>message_type = DanceRequest</code></p> <p>Function performed: The We-Space messaging infrastructure reads this metadata to select the allowed protocol (per Agreement) and route the message to the recipient\u2019s membrane \u2014 without exposing any payload contents.</p>"},{"location":"mapp-dev/trust-channel/#2-authentication-envelope-identity-verification-function","title":"2. Authentication Envelope \u2192 Identity Verification Function","text":"<p>Envelope contains: - Cryptographic signature over the hash of the encrypted payload</p> <p>Function performed: The Trust Channel fetches the sender\u2019s public key from the Agreement and verifies: - The signature matches the payload hash - The sender is an authorized Agreement participant</p> <p>This step proves authenticity before any decryption occurs.</p>"},{"location":"mapp-dev/trust-channel/#3-encryption-envelope-confidentiality-function","title":"3. Encryption Envelope \u2192 Confidentiality Function","text":"<p>Envelope contains: - Payload encrypted with the recipient\u2019s public key</p> <p>Function performed: The recipient\u2019s membrane decrypts the payload with its private key. This ensures that even though transport and routing may cross multiple peers, only the final recipient can read the request.</p>"},{"location":"mapp-dev/trust-channel/#4-authorization-envelope-permission-check-function","title":"4. Authorization Envelope \u2192 Permission Check Function","text":"<p>Envelope contains: - Full <code>DanceRequest</code> - Target <code>Dance</code> - Agent roles - Parameters, thresholds, and timing</p> <p>Function performed: Agreement rules are applied to ensure: - The requester\u2019s role is permitted to invoke this Dance - The role pairing is valid under the Agreement - All scope and timing conditions are met</p>"},{"location":"mapp-dev/trust-channel/#5-execution-context-dispatch-function","title":"5. Execution Context \u2192 Dispatch Function","text":"<p>Function performed: Once validated, the We-Space hands the request to the recipient\u2019s I-Space. Here, the MAP Choreographer invokes the Dance. If part of a DanceFlow, subsequent steps are dispatched automatically.</p>"},{"location":"mapp-dev/trust-channel/#outbound-flow-layering-the-response","title":"\ud83d\udce4 Outbound Flow: Layering the Response","text":"<p>Outbound processing mirrors inbound, ensuring the response leaves the membrane as securely and intentionally as the request entered.</p>"},{"location":"mapp-dev/trust-channel/#1-payload-creation-function","title":"1. Payload \u2192 Creation Function","text":"<p>The application logic in the I-Space generates the raw <code>DanceResponse</code>.</p>"},{"location":"mapp-dev/trust-channel/#2-exfiltration-envelope-outbound-authorization-function","title":"2. Exfiltration Envelope \u2192 Outbound Authorization Function","text":"<p>Function performed: Filters response content against Agreement terms, type-level access policies, and trust thresholds before anything leaves the membrane.</p>"},{"location":"mapp-dev/trust-channel/#3-encryption-envelope-confidentiality-function_1","title":"3. Encryption Envelope \u2192 Confidentiality Function","text":"<p>Response is encrypted with the requester\u2019s public key so only they can read it.</p>"},{"location":"mapp-dev/trust-channel/#4-authentication-envelope-integrity-verification-function","title":"4. Authentication Envelope \u2192 Integrity Verification Function","text":"<p>Encrypted response is signed with the responder\u2019s private key to prove origin and integrity.</p>"},{"location":"mapp-dev/trust-channel/#5-transport-envelope-routing-function","title":"5. Transport Envelope \u2192 Routing Function","text":"<p>Routing metadata is wrapped around the response and the Trust Channel selects the allowed protocol for delivery.</p>"},{"location":"mapp-dev/trust-channel/#why-this-is-a-big-deal-for-developers","title":"\ud83e\udde0 Why This is a Big Deal for Developers","text":"<p>Because the We-Space application services and Trust Channel stack do all of this before a request reaches app logic, developers can: - Assume incoming requests are authentic, authorized, and within scope - Skip building custom cryptographic or trust enforcement layers - Focus entirely on the business logic of the Dance itself</p> <p>At the same time, the MAP ensures uniform adherence to Agreements, so every response is also vetted, encrypted, and signed before leaving the agent\u2019s control.</p> <p>In short: The We-Space and Trust Channels are sovereignty-preserving service layers. They are the reason MAP can operate fully decentralized without central servers \u2014 and why MAP apps can remain secure, interoperable, and trust-aligned by default.</p>"},{"location":"shared/glossary/","title":"\ud83e\uddfe Glossary","text":"<p>This glossary defines key concepts and terms used throughout the MAP architecture and narrative framework. Terms are listed alphabetically. Multiple definitions are included where distinctions emerged between narrative threads.</p>"},{"location":"shared/glossary/#agent","title":"Agent","text":"<p>An Agent is any entity capable of sensing and responding to its environment. It may be biological (e.g., a person, whale, or tree), technical (e.g., a computing process), or social (e.g., a family, cooperative, or commons).</p> <ul> <li>Every Agent has a unique identity and a corresponding I-Space \u2014 a private AgentSpace that houses its LifeCode, Data Grove, and core affordances. </li> <li>Agents can make offers and accept offers made by others to form Agreements.</li> </ul> <p>Agents are expressed as Holons that belong to one or more AgentSpaces. Every Agent belongs to the Exosphere and typically one or more additional AgentSpaces.</p>"},{"location":"shared/glossary/#agentspace","title":"AgentSpace","text":"<p>An AgentSpace is a membrane-bound social space where Agents interact, co-create, and participate in regenerative value flows. It is simultaneously:</p> <ul> <li>A HolonSpace \u2014 stewarding both Agents and Holons</li> <li>A container for knowledge, relationships, and shared governance</li> <li>A venue for Offers, Agreements, Promises, and visualization</li> </ul> <p>Every AgentSpace has its own LifeCode, and every interaction between Agents happens within an AgentSpace.</p> <p>\u26a0\ufe0f Not every AgentSpace is itself an Agent (i.e., not all are Social Organisms), but some  AgentSpaces, once sufficiently coherent and governed, may themselves become Agents \u2014 emergent wholes acting at a higher level of the holarchy.</p>"},{"location":"shared/glossary/#agreement","title":"Agreement","text":"<p>An Agreement is created from an Offer when agents have accepted all of the mandatory roles of the Offer. An Agreement may instantiate its own Agreement-Based AgentSpace which becomes the interaction venue for activities governed by that agreement.</p>"},{"location":"shared/glossary/#agreement-based-agentspace","title":"Agreement-Based AgentSpace","text":"<p>An Agreement-Based AgentSpace is a bounded interaction context that emerges when an Offer is accepted and an Agreement is formed.</p> <p>It includes: - All participating Agents - A LifeCode derived from the shared promises and intent of the Agreement - A scoped Data Grove of relevant Holons and references - The governance and coordination logic encoded in the Agreement, including optional roles for verification, mediation, or escalation</p> <p>While agreements may expire, be revoked, or become inactive, the AgentSpace itself \u2014 like all entities in the MAP \u2014 is immutable and persistent. Its history, structure, and prior interactions remain verifiable and accessible, preserving both accountability and lineage.</p> <p>An Agreement-Based AgentSpace is the sovereign membrane where promises take form, interactions unfold, and trust-based coordination becomes possible \u2014 with a cryptographically assured memory.</p>"},{"location":"shared/glossary/#choreographer","title":"Choreographer","text":"<p>The Choreographer is the MAP\u2019s native coordination engine. It manages the invocation and sequencing of modular dances across agents, spaces, and roles using declarative Dance Flows. </p> <p>Each dance performs a single task and emits a completion signal. The Choreographer listens for these signals and, based on the active flow specification and local context, invokes the next appropriate step. By keeping sequencing logic outside of individual dances, MAP enables complex behaviors to be composed from simple, intelligible parts.</p>"},{"location":"shared/glossary/#commoning","title":"Commoning","text":"<p>Commoning is the ongoing social process through which people collaboratively create, steward, and sustain shared resources (i.e., Vital Capitals) and relationships. At its core, commoning is a relational, participatory, and adaptive practice that reclaims shared power in managing the conditions of life. It is not just a structure, but a way of being and doing together.</p> <p>Commoning emerges outside of \u2014 and often in resistance to \u2014 market and state logics, cultivating trust, reciprocity, and long-term ecological and social flourishing. The lived practice of mutual care, collective governance, and cultural co-creation is what enables a commons to thrive.</p> <p>\u201cCommoning is a verb. It\u2019s about the social practices and cultural traditions that people devise to manage shared resources in fair, inclusive, and sustainable ways.\u201d  \u2014 David Bollier, \u201cThink Like a Commoner\u201d (2014)</p> <p>\u201cThere is no commons without commoning.\u201d \u2014 Peter Linebaugh, \u201cThe Magna Carta Manifesto\u201d (2008)</p>"},{"location":"shared/glossary/#commons","title":"Commons","text":"<p>A Commons is a social system for the long-term stewardship of Vital Capital that preserves shared values and community identity. A self-organized system by which communities manage vital capital (both depletable and replenishable) with minimal or no reliance on the Market or State. In the MAP, a commons is represented by an Agent Space whose  LifeCode conveys its community values, join membrane, and governance model.</p>"},{"location":"shared/glossary/#dahn","title":"DAHN (Dynamic Adaptive Holon Navigator)","text":"<p>A personalized, dynamic interface layer for exploring the MAP holon graph. DAHN empowers each agent to shape their own experience \u2014 not just by choosing settings, but by composing the very way information is seen, explored, and interacted with.</p> <p>Rather than each app imposing its own interface, DAHN provides a coherent visual and interaction layer across all Mapps. This coherence is achieved through dynamic selection of visualizers \u2014 modular components contributed by HX designers to the federated Visualizer Commons.</p> <p>DAHN embodies the MAP design philosophy: putting agents at the center of their digital experience, enabling expressive, adaptable, and trustable interfaces that evolve with collective and individual needs.</p>"},{"location":"shared/glossary/#dance","title":"Dance","text":"<p>A Dance is a named, invocable action that a Holon can perform or participate in \u2014 such as querying data, initiating a service, accepting an offer, or responding to a relationship.</p> <p>In MAP, dances represent affordances \u2014 the ways a Holon can be interacted with \u2014 but the term affordance felt overly technical and lacked poetic resonance.</p> <p>So we coined the term Dance.</p> <p>Why Dance?</p> <ul> <li>Because dances are relational \u2014 they involve interaction, timing, rhythm, consent.</li> <li>Because they convey graceful interdependence, not mechanical execution.</li> <li>Because in MAP, even technical operations are wrapped in patterns of trust, meaning, and flow.</li> </ul> <p>Dances are defined through the MAP Uniform API, where each <code>DanceRequest</code> expresses: - Who is dancing (the Holon) - What dance is being performed - With what input parameters - Under what conditions</p> <p>And the <code>DanceResponse</code> returns: - The result of the dance - A set of next possible dances based on the current state of the system</p> <p>A Dance is not just a function call \u2014 it's a structured act of agency within a living graph of relationship and meaning.</p>"},{"location":"shared/glossary/#dance-flow","title":"Dance Flow","text":"<p>A Dance Flow is a named, context-aware sequence of individual dances that collectively coordinate a process across agents, promises, or Agent Spaces.</p> <p>Each dance within the flow performs a discrete task or role and emits a signal upon completion. The MAP Choreographer responds to these signals by invoking the next appropriate dance in the flow, guided by shared agreements and contextual conditions.</p> <p>Key Characteristics: - Composable: Built from modular, reusable dances. - Declarative: Specifies what should unfold, not how each dance works internally. - Membrane-aware: Executes within or across Agent Spaces while respecting boundaries and permissions. - Promise-aligned: Flows often reflect and reinforce explicit promises among participants.</p> <p>Purpose: Dance Flows enable complex behaviors to emerge through the orchestration of simple, intelligible steps \u2014 making collaborative processes legible, adaptable, and agency-respecting.</p> <p>Related Concepts: \u2192 Dance, Choreographer, Promise Weave, Agent Space</p>"},{"location":"shared/glossary/#dance-interface-protocol","title":"Dance Interface Protocol","text":"<p>The Dance Interface Protocol is the universal invocation protocol in the MAP. It replaces traditional REST or RPC calls with a more expressive, memetic, and composable request model.</p> <p>Every Holon exposes available Dances depending on its current state and context.</p>"},{"location":"shared/glossary/#dancerequest","title":"DanceRequest","text":"<p>A DanceRequest is a Holon-encoded invocation of a Dance. It tells a Holon what is being requested \u2014 and under what terms.</p> <p>Each <code>DanceRequest</code> contains: - The ID of the Holon being danced with - The name of the Dance being invoked - A RequestBody \u2014 including input parameters, context, and initiating agent identity - (Optionally) an associated Agreement that governs the terms of the interaction</p> <p>Like all things in the MAP, the DanceRequest is itself a Holon \u2014 with its own type descriptor, provenance, access policy, and potential for visual representation.</p> <p>DanceRequests can be created by: - Human users interacting through DAHN  - Other Holons (e.g., service Holons triggering dances) - External systems interfacing through the MAP Uniform API</p> <p>A <code>DanceRequest</code> is a memetically and permissionally aware act of intent \u2014 a moment of coordinated agency within a shared graph.</p>"},{"location":"shared/glossary/#danceresponse","title":"DanceResponse","text":"<p>A DanceResponse is the result of performing a Dance. It includes not only the outcome of the request but also the forward affordances \u2014 what the Holon now makes possible.</p> <p>Each <code>DanceResponse</code> includes: - A ResponseBody \u2014 containing results, messages, or new Holons - A list of next available Dances \u2014 HATEOAS-style descriptors of follow-up actions - Provenance metadata and optional diagnostics - Links to updated state, derived Agreements, or resulting relationships</p> <p>Like the <code>DanceRequest</code>, the <code>DanceResponse</code> is a fully self-describing Holon and can be visualized, shared, or referenced by other components of the MAP.</p> <p>A <code>DanceResponse</code> is not just a return value \u2014 it\u2019s the moment-by-moment emergence of possibility in a living graph of consent and flow.</p>"},{"location":"shared/glossary/#data-grove","title":"Data Grove","text":"<p>A Data Grove is the sovereign, Holochain-based data storage area. Each AgentSpace has its own private Data Grove.  All of the mapps that are imported into an Agent Space store their information in the Data Grove of that Space.</p>"},{"location":"shared/glossary/#echo","title":"Echo","text":"<p>An Echo is a signed affirmation of a Promise made by another Agent, issued by an agent who chooses to align with that promise.</p> <p>Echoes serve as memetic endorsements\u2014reinforcing, repeating, and extending the trustworthiness of a promise in a given AgentSpace or across spaces.</p> <p>An Echo is:</p> <ul> <li>A verbatim reference to an existing Promise, not a reinterpretation</li> <li>A social trust gesture\u2014binding the echoing agent\u2019s reputation to the original claim</li> <li>A signal of observability\u2014often grounded in direct experience, shared context, or role-based verification</li> <li>A building block of memetic trust networks, used to evaluate promises, inform Agreements, and govern access or delegation</li> </ul> <p>Echoes may carry optional metadata such as echo weight, reasoning, or contextual scope (e.g., \u201cwithin this space only\u201d).</p> <p>\u2733\ufe0f Echoes are foundational to MAP\u2019s distributed trust model\u2014allowing agents to construct verifiable, socially-scaffolded identity and reputation without centralized authorities.</p>"},{"location":"shared/glossary/#echo-weight","title":"Echo Weight","text":"<p>An Echo Weight is an optional indicator attached to an Echo, expressing the echoing Agent\u2019s degree of confidence, verification, or proximity to the original Promise.</p> <p>Echo Weights enable more nuanced interpretation of social signals by:</p> <ul> <li>Differentiating firsthand from secondhand endorsements</li> <li>Informing access decisions, Agreement thresholds, and trust scores</li> <li>Supporting evaluative logic in AgentSpaces and across social holarchies</li> </ul> <p>Weights may be numeric (e.g., 0.9), categorical (e.g., \u201cstrong,\u201d \u201clight\u201d), or policy-defined by a GroupAgent.</p> <p>\u2733\ufe0f While optional, Echo Weights help MAP spaces distinguish between weak support and strong verification\u2014without requiring rigid central scoring systems.</p>"},{"location":"shared/glossary/#exosphere","title":"Exosphere","text":"<p>The Exosphere is the outermost, most inclusive AgentSpace in the MAP. It includes all Agents by default and serves as the lowest-threshold interaction venue across the entire platform.</p> <p>The Exosphere is:</p> <ul> <li>Non-governed (aside from platform-level rules)</li> <li>High-reach, low-trust</li> <li>The place where initial Offers may be surfaced to broad audiences</li> </ul> <p>It is not a commons or Social Organism \u2014 it is a shared membrane of visibility.</p>"},{"location":"shared/glossary/#governance-scaffold","title":"Governance Scaffold","text":"<p>A Governance Scaffold is a modular structure of roles, rules, and processes that guides how coordination and decision-making unfold within an AgentSpace.</p> <p>Rather than imposing a fixed governance model, a governance scaffold provides lightweight, composable affordances that can evolve alongside the needs and context of the space. These scaffolds are often memetically sourced from the Global Meme Pool, where patterns like sociocracy, holacracy, liquid democracy, or bespoke cultural traditions can be adapted and instantiated.</p> <p>Governance scaffolds define: - Who has voice and agency - How decisions are made and validated - What roles exist and how they are assigned or rotated - How conflicts are mediated or escalated</p> <p>They can be: - Hard-coded into Agreements - Expressed as Memeplexes in the Meme Pool - Referenced dynamically during Dance Flows</p> <p>\ud83e\udde9 Governance scaffolds are to governance what protocols are to software: flexible, interoperable building blocks that support resilient, adaptive coordination.</p> <p>See also: AgentSpace, LifeCode, Agreement, Meme Pool</p>"},{"location":"shared/glossary/#holon","title":"Holon","text":"<p>A Holon is the foundational unit of structure, meaning, and interaction in the MAP.</p> <p>Every object in the MAP \u2014 whether it\u2019s a piece of content, an Agent, a relationship, a service, or a visual element \u2014 is encoded as a self-describing, active Holon or HolonRelationship.</p>"},{"location":"shared/glossary/#self-describing","title":"\u2727 Self-Describing","text":"<p>A Holon contains within itself everything needed to interpret and interact with it. When you encounter a Holon \u201cin the wild,\u201d you can ask:</p> <ul> <li> <p>What properties do you have?   What are your current values for those properties?</p> </li> <li> <p>What types of relationships do you participate in?   To what other Holons are you related via those relationships?</p> </li> <li> <p>Through what visualizations can I view and interact with you?   Holons reference one or more Visualizers from the commons, allowing fully customizable rendering and interaction \u2014 from list views to immersive spatial experiences.</p> </li> <li> <p>What types of data access are permitted?   Holons carry their own access policies, provenance signatures, and licensing terms \u2014 enabling granular, trustable permissioning.</p> </li> </ul>"},{"location":"shared/glossary/#active","title":"\u2727 Active","text":"<p>Holons aren\u2019t just data \u2014 being active means holons can do stuff... they offer affordances.</p> <p>Every Holon can declare the Dances it is capable of performing \u2014 actions that can be invoked via the MAP Uniform API. These may include:</p> <ul> <li>Responding to queries</li> <li>Invoking relationships</li> <li>Triggering services</li> <li>Participating in negotiations, offers, or agreements</li> </ul> <p>In this way, Holons are not passive records, but sovereign, interactive knowledge actors that make up the living substrate of the MAP.</p> <p>A Holon is not just a piece of data \u2014 it is a meaningful, permissioned, expressive agent of action in a graph of relationships. It sees, responds, and evolves.</p>"},{"location":"shared/glossary/#holonspace","title":"HolonSpace","text":"<p>A HolonSpace is the foundational data container in the MAP, equivalent to an AgentSpace. While the term highlights its function as a steward of Holons, in MAP narratives, the two terms are generally treated as synonymous.</p>"},{"location":"shared/glossary/#i-space","title":"I-Space","text":"<p>An I-Space is an AgentSpace viewed from the interior perspective \u2014 focusing on internal structure, properties, intentions, and affordances of an Agent.</p> <p>Every Agent has an I-Space. For persons, this is often referred to as a Personal I-Space, but not all I-Spaces are personal.</p> <p>See also: We-Space</p>"},{"location":"shared/glossary/#join-membrane","title":"Join Membrane","text":"<p>The set of rules defined by an AgentSpace's Life Code that govern adding new members of the Agent Space.</p>"},{"location":"shared/glossary/#lifecode","title":"LifeCode","text":"<p>A LifeCode (also known as a Memetic Signature) is the values-and-identity encoding of an Agent, AgentSpace, Offer or Agreement. It defines:</p> <ul> <li>Aspirational purpose</li> <li>Memetic values and ethics</li> <li>Governance expectations</li> <li>Membership criteria</li> <li>Expressed Promises</li> </ul> <p>The LifeCode is the symbolic \"membrane\" of an AgentSpace and plays a foundational role in trust-based interaction.</p>"},{"location":"shared/glossary/#meme","title":"Meme","text":"<p>A Meme is a pattern, story, value, or shared practice that carries meaning and can be passed from one person or group to another.</p> <p>In the MAP, a meme could be a community ritual, a traditional teaching, a way of solving problems, a decision-making method, a symbol, or even a sacred story. Some memes are old and passed down through generations. Others are new, shared in conversation, taught in workshops, or built into tools and agreements.</p> <p>What matters is not just where a meme comes from \u2014 but that it helps people live together with intention, take action, or share understanding.</p> <p>Memes travel in many ways. Some are copied, some are taught, some are woven into daily life. In MAP, we honor all of these. Whether a meme is passed in a ceremony, a drawing, a document, or a song \u2014 it becomes part of our living culture when people put it into use.</p> <p>Memes are gathered into Meme Pools, where they can be shared, adapted, and stewarded with care \u2014 so that wisdom from one place can grow in another, without losing its roots.</p> <p>See also: Meme Pool, Vital Capital, LifeCode</p>"},{"location":"shared/glossary/#meme-technical","title":"Meme (technical)","text":"<p>A Meme is a structured unit of cultural meaning that can be defined, expressed, enacted, and evolved by Agents.</p> <p>In the MAP, a meme may take many forms \u2014 including values, principles, protocols, schemas, profiles, practices, rituals, governance models, economic models, or other cultural structures that guide interaction and meaning-making. Every meme is modular, stewardable, and context-aware.</p> <p>In the MAP, memes are not just viral ideas \u2014 they are the living infrastructure of cultural evolution.</p> <p>MAP extends Richard Dawkins\u2019 original definition \u2014 which emphasized replication through imitation \u2014 to include agentic enactment, contextual re-use, and memetic evolution. Memes may spread via imitation (per Dawkins), but also through instruction, documentation, or embedded use in systems and agreements. What defines a meme is not just how it spreads, but that it encodes actionable meaning and can be activated across diverse contexts.</p> <p>Memes are replicable and selectable: they persist through evolutionary dynamics, where their relevance and effectiveness are tested in lived experience. In this way, MAP supports not just cultural transmission, but the iterative refinement and ecological adaptation of its memetic commons.</p> <p>Epistemic rigor \u2014 such as practices rooted in the scientific method \u2014 can strengthen the fidelity and resilience of a meme by making it easier to reproduce, test, and refine across contexts. However, epistemic rigor is neither the sole pathway to replicability nor a universal standard: many memes in MAP draw from spiritual traditions, embodied practices, or lived experience that offer their own forms of coherence, relevance, and transmission.</p> <p>Memes can be classified by:</p> <ul> <li>Type (e.g. atomic meme, schema, protocol, visualizer)</li> <li>Category (e.g. governance, economics, learning, identity)</li> <li>Functional structure (e.g. memeplex, memefamily)</li> </ul> <p>Every Meme in MAP is a form of Vital Capital, and is stewarded within one or more Meme Pools.</p> <p>See also: Meme Pool, Vital Capital, LifeCode</p>"},{"location":"shared/glossary/#meme-pool","title":"Meme Pool","text":"<p>A Meme Pool is a collection of memes together with the agents and governance processes that steward them. In other words, a Meme Pool is a Commons.</p>"},{"location":"shared/glossary/#memetic-signature","title":"Memetic Signature","text":"<p>Synonym for LifeCode. Refers to the expressive encoding of an Agent\u2019s identity, values, and memetic alignment.</p>"},{"location":"shared/glossary/#observability","title":"Observability","text":"<p>Observability describes the degree to which a Promise can be independently verified by other Agents within a given AgentSpace.</p> <p>Every Promise has an implicit or explicit observability profile, which may be:</p> <ul> <li>Direct \u2014 fulfillment is visible to others (e.g., a submitted file, a public action)</li> <li>Indirect \u2014 fulfillment is verifiable through roles, logs, or trusted intermediaries</li> <li>Unobservable \u2014 fulfillment is private or unverifiable (e.g., internal state, intentions)</li> </ul> <p>Spaces may define Observability Profiles that specify the kinds of promises they accept, echo, or require in Agreements.</p> <p>\u2733\ufe0f Observability governs the memetic legibility of a promise\u2014what others can trust, echo, or build upon.</p>"},{"location":"shared/glossary/#offer","title":"Offer","text":"<p>An Offer is a proposed bundle of Promises, expressing both:</p> <ul> <li>What the offering Agent is willing to do or provide</li> <li>What reciprocal Promises it expects in return</li> </ul> <p>Offers are shared into specific AgentSpaces (e.g., the Exosphere or a Social Organism) and may result in Agreements.</p>"},{"location":"shared/glossary/#offer-type","title":"Offer Type","text":"<p>An Offer Type is a reusable template or pattern that defines the structure, roles, conditions, and expectations for a class of Offers in the MAP.</p> <p>Offer Types allow communities and Agents to create Offers with shared semantics and validated structure. Each Offer Type is a Meme \u2014 discoverable, remixable, and stewarded in the Global Meme Pool.</p> <p>Key properties of an Offer Type may include: - A named purpose or intent (e.g., \u201cTimebank Exchange\u201d, \u201cMicrogrant Application\u201d, \u201cCommons Stewardship Invitation\u201d) - The required and optional roles (e.g., Initiator, Contributor, Verifier) - Preconditions and fulfillment criteria - Common reciprocity patterns (e.g., \u201coffer of service in exchange for learning\u201d)</p> <p>By standardizing structure while remaining adaptable, Offer Types reduce friction and ambiguity in peer coordination, and enable the creation of Agreements that are intelligible across diverse contexts.</p> <p>\ud83d\udce6 An Offer Type is a memetic design pattern for regenerative coordination \u2014 shaping how value is proposed, negotiated, and enacted.</p> <p>See also: Offer, Agreement, Meme, Meme Pool</p>"},{"location":"shared/glossary/#promise","title":"Promise","text":"<p>A Promise is a voluntary, sovereign commitment made by one Agent. It is the atomic unit of value coordination within MAP.</p> <p>Promises may be formal (e.g., I promise to transfer 10 units of water in exchange for 5 units of labor) or informal (e.g., I promise to show up with care and attention).</p> <p>All Agreements are built from bundles of Promises.</p>"},{"location":"shared/glossary/#service","title":"Service","text":"<p>Services support the flow and transformation of vital capitals to/from other agents for mutual benefit. Services are the focus of Offers, Agreements, and Service Invocations.</p>"},{"location":"shared/glossary/#service-invocation","title":"Service Invocation","text":"<p>A request to an offering agent to perform a requested service within the context of an active agreement.</p>"},{"location":"shared/glossary/#social-organism","title":"Social Organism","text":"<p>A Social Organism is an AgentSpace that has developed enough internal coherence, governance capacity, and memetic identity to act as an Agent in its own right\u2014a Holon one level up.</p> <p>Unlike the default Exosphere, which includes all agents by default and lacks any collective governance, a Social Organism is formed intentionally. It may emerge from one or more Agreement-Based AgentSpaces and evolve into an agentic identity through extensions to its LifeCode.</p> <p>A key property of Social Organisms\u2014described by Ken Wilber as Social Holons<sup>1</sup>\u2014is that membership is non-exclusive. That is, an individual agent can participate in multiple Social Organisms at once. This contrasts with Biological Holons (e.g., cells or mitochondria), whose parts typically belong to a single organism. Social Holons reflect the fluid, overlapping, and context-dependent nature of social identity and affiliation.</p> <p>Social Organisms are not merely large groups\u2014they are living holons: capable of acting, adapting, evolving, and participating in higher-order Social Organisms themselves. A canonical example is a corporation\u2014a persistent, governance-equipped AgentSpace that can form agreements and delegate authority to sub-agents.</p> <p>Other examples might include co-ops, intentional communities, DAOs, or bioregional networks.</p> <p>See also: AgentSpace, Exosphere, LifeCode, Agreement, Agent, Holon</p>"},{"location":"shared/glossary/#stewardship","title":"Stewardship","text":"<p>In the MAP, stewardship replaces \"ownership\" to describe the relationship between an AgentSpace and the Holons it is responsible for. Each Holon is stewarded by exactly one AgentSpace, though it may be referenced in many.</p> <p>Stewardship emphasizes care, consent, and accountability.</p>"},{"location":"shared/glossary/#uniform-api","title":"Uniform API","text":"<p>The Uniform API is the singular interface through which all interactions with the MAP take place. It is based on the metaphor of the Dance, framing every invocation \u2014 from data queries to service calls \u2014 as a shared, consensual interaction.</p> <p>At its core is the <code>dance()</code> function, which accepts a <code>DanceRequest</code> and returns a <code>DanceResponse</code>.</p> <ul> <li>The DanceRequest specifies:</li> <li>The Holon (or relationship) initiating the Dance</li> <li>Parameters for the action (e.g., queries, inputs, filters)</li> <li> <p>Optionally, an OpenCypher query \u2014 enabling expressive graph traversal and transformation</p> </li> <li> <p>The DanceResponse returns:</p> </li> <li>Results from the invocation (e.g., data, confirmation, computation)</li> <li>Updated state where appropriate</li> <li>Additional <code>DanceRequest</code> options (HATEOAS-style), revealing the next set of affordances available in the current state</li> </ul> <p>Because the MAP is knowledge-graph native, all interactions \u2014 including service calls, interface rendering, and value flows \u2014 are expressible as Dances across a dynamic graph of Holons.</p> <p>The Uniform API means every Holon interaction is symmetric, discoverable, and composable \u2014 turning the MAP into a danceable language of consent, action, and agency.</p>"},{"location":"shared/glossary/#vital-capital","title":"Vital Capital","text":"<p>A core MAP holon type representing the diverse forms of value that can flow between Agents \u2014 including knowledge, care, trust, materials, attention, and more. Vital Capital is what flows as a result of service invocations and fulfilled Promises. While not inherently scarce or commodified, each Vital Capital holon is definable, describable, and context-aware. When under the stewardship of a particular Agent, it may be treated as an Asset. The concept draws from multiple sources, including Context-Based Sustainability (McElroy), the Metacurrency Project (which defines wealth as \"the capacity to meet the needs of a living system\"), and the 8 Forms of Capital in permaculture theory.</p> <p>The MAP concept of Vital Capital refers to the many forms of value \u2014 not just financial \u2014 that flow through MAP Agreements. These include:</p> <p>draws heavily on the work around Context-Based Sustainability (see citation below) </p> Capital Type Description Natural Capital Ecosystem services, land, water, air, biodiversity Human Capital Skills, labor, knowledge, health, attention Social Capital Trust, reputation, relationships, group cohesion Cultural Capital Stories, rituals, symbols, traditions, identity Built Capital Tools, infrastructure, digital systems, physical assets Financial Capital Currency, tokens, credit, investments Experiential Capital Aesthetic, emotional, and lived experiences Memetic Capital Values, beliefs, narratives, memetic signatures Temporal Capital Time, availability, scheduling of attention or actions Spiritual Capital Purpose, presence, connection to meaning (optional but supported dimension) <ul> <li>Social capital</li> <li>Ecological contributions</li> <li>Attention, care, and creativity</li> <li>Knowledge and memetic resources</li> </ul> <p>Vital capital flows are explicitly tracked via Promises and Agreements.</p> <p>For more information: see  McElroy, M. W. (2008). Social Footprints: Measuring the Social Sustainability Performance of Organizations. Middlebury: Center for Sustainable Innovation. https://www.sustainableinnovation.org ResearchGate PDF</p>"},{"location":"shared/glossary/#visualizer","title":"Visualizer","text":"<p>A Visualizer is a Holon that describes how another Holon should be rendered and interacted with \u2014 in 2D, 3D, text, graph, gallery, immersive environment, or any other format.</p> <p>Visualizers are contributed to the Visualizer Commons and selected at runtime by DAHN based on: - The type of Holon - The preferences of the Agent viewing it - The popularity and contextual fit of available visualizers</p> <p>Every Holon can reference one or more Visualizers, allowing radically different renderings for different contexts \u2014 from dashboards to immersive journeys.</p> <p>A Visualizer is not just a UI component \u2014 it is a semantic lens, a votable style, and a participatory aesthetic contribution to the shared experience of the MAP. </p>"},{"location":"shared/glossary/#visualizer-commons","title":"Visualizer Commons","text":"<p>A federated network of stewarded sets of Visualizers. DAHN dynamically selects and configures visualizers from the Visualizer Commons to present and enable interaction with the MAP' self-describing, active Holons</p>"},{"location":"shared/glossary/#we-space","title":"We-Space","text":"<p>A We-Space is an AgentSpace viewed from the exterior perspective \u2014 how it participates within larger structures, how it exposes interfaces and affordances, and how it relates to other spaces.</p> <p>A Social Organism is always a We-Space, but not all We-Spaces are yet Social Organisms.</p> <ol> <li> <p>Wilber, Ken. Sex, Ecology, Spirituality: The Spirit of Evolution. Shambhala Publications, 1995.\u00a0\u21a9</p> </li> </ol>"}]}