{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MAP Developer Documentation","text":"<p>Welcome to the MAP Developer Documentation.</p> <p>This site is intended to support developers, schema authors, and community contributors who are building with the MAP Type System and holonic data structures.</p> <p>MAP is designed to be:</p> <ul> <li>Self-describing \u2014 every type is a holon</li> <li>Composable \u2014 types and schemas can be extended without breaking compatibility</li> <li>Federated \u2014 schema evolution happens across a network of independently defined but interoperable types</li> </ul>"},{"location":"#getting-started","title":"\ud83e\udded Getting Started","text":"<p>This documentation is still evolving. It's initial focus is on a JSON File Authoring Guide as part of the MAP Holon Data Loader. </p> <ul> <li>Explore the type system design in the MAP wiki</li> <li>Review example import files in <code>schemas/</code> if available</li> <li>Watch this space for developer guides and schema authoring tips</li> </ul> <p>We\u2019ll be adding more structured guides and references as the project grows. Contributions are welcome.</p> <p>For licensing info, see LICENSE.md.</p>"},{"location":"importing-data/holon-data-loader-design-spec/","title":"MAP Holon Data Loader Design Specification (Updated)","text":"<p>The Holon Data Loader will convert holon data presented in JSON files into Holons and HolonRelationships that are staged and committed to a (single) MAP Space using existing MAP APIs. Because all MAP types (e.g., PropertyType, HolonType, RelationshipType) are themselves holons, the Holon Data Loader can be used to load TypeDescriptors just like any other data \u2014 eliminating the need for a separate type-specific loader. Input files are syntactically validated against a JSON Schema to ensure they represent well-formed holons, properties, relationships and, eventually, dances.</p> <p>Validation of imported holons and their properties and relationships against their Type Descriptors is triggered by standard Holochain validation callbacks. These callback functions, implemented in the <code>holons_integrity_zome</code> invoke shared validation functions to actually perform the validations. All Holochain dependencies are isolated in the integrity zome so that the shared validation functions have no holochain dependencies.</p> <p>If the target space does not already contain all required TypeDescriptors (e.g., BookType, title, HAS_AUTHOR), they must be included as part of the import and loaded first. Since we do not yet have deployed instances of the MAP that persist data, all types and data required for an integration Test Case must be loaded as part of the test case itself. This includes importing the MAP Schema. Thus, the test case initialization includes the following steps:</p> <ol> <li>Import MAP Meta-Schema</li> <li>Import MAP Core Schema</li> <li>Import Domain-Specific Type Descriptors (if any)</li> <li>Import Domain-Specific Data (if any)</li> </ol> <p>All four test steps use the same Holon Data Loader. Each step imports the type descriptors needed to validate the data imported in the subsequent step.</p>"},{"location":"importing-data/holon-data-loader-design-spec/#process-overview","title":"\ud83e\udde9 Process Overview","text":"<p>The following diagram shows the Holon Data Loading process.</p> <p></p>"},{"location":"importing-data/holon-data-loader-design-spec/#step-by-step-map-holon-data-loader-flow","title":"\ud83e\udded Step-by-Step: MAP Holon Data Loader Flow","text":"<ol> <li> <p>Define Holons in Airtable -- For now, we are using Airtable as our source of truth for data imports. A user or domain expert defines holons, properties, and relationships as rows in a spreadsheet-like interface. NOTE: This is just one option \u2014 other JSON generation methods are possible.</p> </li> <li> <p>Export CSV from Airtable -- Airtable exports the holon definitions into a CSV file, which contains structured tabular data for each holon, including properties, types, and relationships.</p> </li> <li> <p>Convert CSV to JSON -- A Jupyter Notebook (written in Python) loads the CSV file and uses the MAP Holon JSON Generator to transform the rows into JSON-formatted Holon Definitions. These definitions conform to the MAP Holon Data Loader's expected schema.</p> </li> <li> <p>Run the JSON Schema Validator -- Before loading, the generated JSON input file is validated using a JSON Schema Validator. This ensures that the file:</p> </li> <li>Is structurally valid</li> <li>Uses valid type names and relationship formats</li> </ol> <p>The validated file represents well-formed Holons, Properties, and Relationships.</p> <ol> <li> <p>Parse and Prepare Holons  -- The validated JSON is parsed into in-memory data structures. The Holon Generator builds internal <code>HolonImportSpec</code> structs from the parsed data.</p> </li> <li> <p>Invoke the Holon Data Loader -- The Holon Generator passes the structured holon definitions to the Holon Data Loader, a Rust crate. This loader:</p> </li> <li>Handles all staging and relationship resolution</li> <li> <p>Works for both instance data and TypeDescriptors</p> </li> <li> <p>(Optional) Other Data Loaders -- Other data loaders may bypass JSON entirely and produce Rust-structured holon definitions directly. These are also accepted by the Holon Data Loader pipeline.</p> </li> <li> <p>Stage Holons -- The loader performs Pass 1, where each holon is:</p> </li> <li>Assigned a local ID or temp key</li> <li>Validated for syntactic structure</li> <li> <p>Staged with its properties only (relationships deferred)</p> </li> <li> <p>Stage Relationships -- The loader performs Pass 2, resolving all deferred relationships:</p> </li> <li>References to staged holons use <code>temp_key</code></li> <li>References to saved holons use keys or HolonIds</li> <li> <p>External references resolve via space proxies</p> </li> <li> <p>Commit Holons -- All staged holons are committed into the MAP space via the <code>holons_core</code> crate. This action triggers holochain\u2019s commit lifecycle.</p> </li> <li> <p>Trigger Validation -- As part of the commit, the Holochain Conductor invokes validation actions. These hit the HolonNode Validation Hooks in the <code>holons_integrity_zome</code>. The implementation of these hook functions converts the data into \"holochain-independent\" data structures in order to invoke the shared validation functions.</p> </li> <li> <p>Run Shared Validation Logic The hooks delegate to the Shared Holons Validator, which contains:</p> </li> <li>Validation against TypeDescriptors</li> <li>Enforcement of required properties and cardinalities</li> <li>No direct Holochain dependencies \u2014 enabling reuse of these validations from holons_core without pulling in holochain and its dependencies.</li> </ol>"},{"location":"importing-data/holon-data-loader-design-spec/#design-philosophy","title":"\ud83e\udde0 Design Philosophy","text":"Principle Description Holonic Uniformity Everything \u2014 including types \u2014 is a holon Self-Describing Types The <code>type</code> and <code>key</code> fields provide identity and classification Declarative Imports Inverse relationships and embedded holons may be expressed naturally Keyed Reference Integrity Only keyed holons may be targeted by <code>$ref</code> Two-Pass Import Enables circular references and loose ordering in authoring Minimal, Consistent Format Supports both human authoring and automated generation"},{"location":"importing-data/holon-data-loader-design-spec/#keyed-vs-keyless-holons","title":"\ud83d\udccc Keyed vs Keyless Holons","text":"<p>MAP distinguishes two structural categories of holons:</p> Feature Keyed Holons Keyless Holons Includes <code>key</code> \u2705 Yes \u274c No Unique within space \u2705 Yes \u274c Not applicable Can be referenced via <code>$ref</code> \u2705 Yes \u274c No Must be embedded in JSON \u274c Optional \u2705 Required Can be target of declared relationship \u2705 Yes \u274c No Must declare outgoing relationship to keyed holon \u274c Optional \u2705 Required <ul> <li>Keyed holons include a stable <code>key</code> (materialized from properties) and may be referenced by other holons via <code>$ref</code>.</li> <li>Keyless holons are contextual and must be embedded as part of another holon\u2019s relationship. They must not be referenced or stand alone.</li> </ul> <p>This pattern ensures clean graph semantics, staging integrity, and simplicity for authors.</p>"},{"location":"importing-data/holon-data-loader-design-spec/#declared-vs-inverse-relationships-in-json","title":"\ud83d\udd01 Declared vs Inverse Relationships in JSON","text":"<p>MAP represents both Declared and Inverse relationships using SmartLinks, but only Declared Relationships are:</p> <ul> <li>Explicitly defined in schemas</li> <li>Directly authored and persisted</li> <li>Validated against cardinality, semantics, and direction</li> </ul> <p>Inverse Relationships are: - Inferred by the system - Automatically maintained as mirrors of their declared counterparts - Not directly writable in the storage layer</p>"},{"location":"importing-data/holon-data-loader-design-spec/#ergonomic-authoring-support","title":"\u2728 Ergonomic Authoring Support","text":"<p>To improve JSON authoring, the Holon Data Loader supports:</p> <p>\u2705 Expressing inverse relationships in JSON \u2014 which are then automatically rewritten into their declared equivalents before staging</p> <p>For example, a JSON snippet like:</p> <pre><code>{\n  \"type\": \"#Schema\",\n  \"key\": \"LibrarySchema\",\n  \"relationships\": [\n    { \"name\": \"Components\", \"target\": [{ \"$ref\": \"BookType\" }] }\n  ]\n}\n</code></pre> <p>will be rewritten internally to:</p> <pre><code>{\n  \"type\": \"#BookType\",\n  \"relationships\": [\n    { \"name\": \"ComponentOf\", \"target\": { \"$ref\": \"LibrarySchema\" } }\n  ]\n}\n</code></pre> <p>This preserves the storage model while making authoring more intuitive.</p> <p>\ud83d\uded1 Note: If both directions of a relationship pair are expressed in the same import file, the loader will raise a warning or error.</p>"},{"location":"importing-data/holon-data-loader-design-spec/#json-import-file-structure","title":"\ud83d\udcc2 JSON Import File Structure","text":"<p>Details about JSON formatting, required fields, reference expressions (<code>$ref</code>), embedded holons, and schema validation rules have been moved to the Holon Data Loader Guide.</p> <p>See: Holon Data Loader Guide \u2013 Authoring Valid JSON Files</p>"},{"location":"importing-data/holon-data-loader-design-spec/#validation-lifecycle","title":"\ud83d\udd0d Validation Lifecycle","text":"<p>The Holon Data Loader and MAP system use multiple layers of validation to ensure correctness, schema alignment, and safe persistence.</p>"},{"location":"importing-data/holon-data-loader-design-spec/#1-schema-validation-pre-load","title":"1. Schema Validation (Pre-Load)","text":"<p>Before holons are even staged, input files are validated using JSON Schema:</p> <ul> <li>The loader always begins by validating imports against the <code>bootstrap-import.schema.json</code> schema. This schema ensures:<ul> <li>Holons are properly structured</li> <li>Properties are well-formed</li> <li>Relationship targets follow required structure</li> <li>No invalid reference forms are present (e.g., unkeyed <code>$ref</code> targets)</li> </ul> </li> </ul>"},{"location":"importing-data/holon-data-loader-design-spec/#cascading-schema-validation","title":"\ud83e\uddec Cascading Schema Validation","text":"<p>After loading the MAP Meta-Schema, additional JSON Schemas can be generated automatically for downstream validation:</p> <ul> <li>Meta-Schema \u2192 Used to validate Core Type imports (e.g., PropertyType, ValueType)</li> <li>Core Schema \u2192 Used to validate Domain-Specific Schema files</li> <li>Domain Schema \u2192 Used to validate Domain-Specific Data files</li> </ul> <p>This allows every import layer to be validated against a holon-based, introspected schema, enforcing MAP type rules long before runtime.</p>"},{"location":"importing-data/holon-data-loader-design-spec/#2-runtime-validation-post-commit","title":"2. Runtime Validation (Post-Commit)","text":"<p>After holons are committed, Holochain's Conductor orchestrates the integrity checks by invoking validation callbacks defined in the <code>map_holons_integrity</code> zome.</p> <p>\u2757 Holons do not themselves trigger validation \u2014 the request to persist a holon causes the Conductor to invoke validation logic.</p> <p>The validation callbacks: - Receive Holochain-native types like <code>Record</code>, <code>Link</code>, <code>ActionHash</code> - Convert these into MAP-native, Holochain-independent structures:     - <code>Holon</code>     - <code>HolonRelationships</code>     - <code>LocalId</code>, etc.</p> <p>These converted forms are passed to shared validation functions (in <code>holons_core</code>) that enforce:</p> <ul> <li>Required and optional property rules</li> <li>Cardinality constraints on relationships</li> <li>Reference resolution and type compatibility</li> <li>Key and relationship uniqueness</li> <li>Schema-defined constraints (e.g., min/max values, enum values, etc.)</li> </ul> <p>This design allows the same validation logic to be reused across client tools, data loaders, and runtime validation \u2014 avoiding duplication and enabling introspection.</p>"},{"location":"importing-data/holon-data-loader-design-spec/#3-loader-level-validations","title":"3. Loader-Level Validations","text":"<p>The Holon Data Loader performs additional checks during staging:</p> <ul> <li>Ensures no inverse relationship appears more than once (after rewriting)</li> <li>Validates that all <code>$ref</code> targets resolve to keyed holons or embedded holons</li> <li>Rejects direct references to keyless holons</li> <li>Ensures that all keyless holons are:<ul> <li>Embedded as relationship targets</li> <li>The source of at least one declared relationship</li> </ul> </li> <li>Ensures that keys (when present) are unique within the load scope</li> </ul>"},{"location":"importing-data/holon-data-loader-design-spec/#staging-and-commit-process","title":"\ud83d\udcbe Staging and Commit Process","text":""},{"location":"importing-data/holon-data-loader-design-spec/#pass-1-stage-holons","title":"Pass 1: Stage Holons","text":"<ul> <li>Create in-memory Holon stubs for each input</li> <li>Only properties are staged; relationships are deferred</li> <li>Holons must include <code>type</code> (and <code>key</code>, if keyed)</li> <li>Relationships are stored for Pass 2</li> </ul>"},{"location":"importing-data/holon-data-loader-design-spec/#pass-2-stage-relationships","title":"Pass 2: Stage Relationships","text":"<ul> <li>Resolve all <code>relationships</code> from JSON</li> <li>References are resolved by <code>$ref</code>, <code>Type:Key</code>, or embedded inline</li> <li>Inverse relationships are rewritten to their declared form</li> <li>Embedded keyless holons are inlined into source holon relationships</li> </ul>"},{"location":"importing-data/holon-data-loader-design-spec/#commit-and-validate","title":"Commit and Validate","text":"<ul> <li>After all holons are staged, the loader invokes <code>holons_core</code> to commit</li> <li>Holochain callbacks are triggered</li> <li>Shared validation logic enforces type rules</li> </ul>"},{"location":"importing-data/holon-data-loader-design-spec/#future-enhancements","title":"\ud83d\udd2e Future Enhancements","text":"<ul> <li>Add schema-based authoring for enum types, constraint types, and complex nested holons</li> <li>Expand support for symbolic references (<code>DanceRequest</code>)</li> <li>Enhance loader validation to support contextual awareness of target schemas</li> <li>Support streaming JSON parsing for very large imports</li> </ul>"},{"location":"importing-data/holon-data-loader-design-spec/#summary","title":"\ud83d\udcce Summary","text":"<p>The Holon Data Loader is the universal import engine for MAP Types and Instances. It supports:</p> <ul> <li>Bootstrap loading of MAP Meta-Schema and Core Schema</li> <li>Domain-specific extension imports</li> <li>Declarative instance creation with ergonomic syntax</li> <li>Unified graph population using a two-pass process</li> <li>Rewriting of inverse relationships for intuitive JSON authoring</li> <li>Holochain-independent shared validation</li> </ul> <p>Authors and tool builders can rely on a consistent, minimal JSON format while benefiting from full MAP introspection, validation, and schema enforcement.</p> <p>See also: Holon Data Loader Guide for JSON authoring rules and examples.</p>"},{"location":"importing-data/holon-data-loader-design-spec/#obsolete-content","title":"========== OBSOLETE CONTENT ==============","text":"<p>Everything after this point is left-over from prior versions are targeted to be deleted.</p>"},{"location":"importing-data/holon-data-loader-design-spec/#json-file-structure","title":"\ud83d\udd0e JSON File Structure","text":"<p>A JSON import file contains two top-level keys:</p> <pre><code>{\n   \"meta\": { ... },\n   \"holons\": [ { ... }, { ... }, ... ]\n}\n</code></pre> <ul> <li><code>meta</code> contains metadata about the import (version, author, etc.).</li> <li><code>holons</code> contains the list of holons to be imported.</li> </ul>"},{"location":"importing-data/holon-data-loader-design-spec/#holon-structure","title":"Holon Structure","text":"<p>Each holon in the <code>holons</code> list is represented as a JSON object with the following keys:</p> <ul> <li><code>type</code> (string): Fully qualified <code>$ref</code> to the holon's type (e.g., <code>\"#MapStringValueType\"</code>). Replaces the older <code>DescribedBy</code> pattern.</li> <li><code>key</code> (optional): A unique identifier if the holon is keyed.</li> <li><code>temp_key</code> (optional): A temporary key for referencing other holons within the same import file.</li> <li><code>properties</code>: A map of property name to typed value.</li> <li><code>relationships</code>: A list of relationship objects, each containing:</li> <li><code>name</code>: Relationship name</li> <li><code>target</code>: Either a <code>$ref</code> string or an embedded holon</li> </ul>"},{"location":"importing-data/holon-data-loader-design-spec/#key-design-rules","title":"\ud83d\udd0e Key Design Rules","text":""},{"location":"importing-data/holon-data-loader-design-spec/#type-implies-describedby","title":"\u2705 <code>type</code> Implies <code>DescribedBy</code>","text":"<ul> <li>Every holon must specify a <code>type</code> using <code>#Key</code> syntax.</li> <li>This replaces the need for an explicit <code>DescribedBy</code> relationship.</li> </ul>"},{"location":"importing-data/holon-data-loader-design-spec/#use-components-instead-of-iscomponentof","title":"\u2705 Use <code>Components</code> Instead of <code>IsComponentOf</code>","text":"<ul> <li>All imported holons are children of a <code>MapSchemaType</code> holon.</li> <li>The <code>Components</code> relationship replaces <code>IsComponentOf</code>.</li> </ul>"},{"location":"importing-data/holon-data-loader-design-spec/#declare-useskeyrule-for-keyed-holons","title":"\u2705 Declare <code>UsesKeyRule</code> for Keyed Holons","text":"<p>Each keyed holon must include a relationship: <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": {\n    \"type\": \"#FormatKeyRule\",\n    \"properties\": {\n      \"format\": \"$0\",\n      \"property_names\": [\"type_name\"]\n    }\n  }\n}\n</code></pre></p>"},{"location":"importing-data/holon-data-loader-design-spec/#fully-qualified-keys-for-relationship-types","title":"\u2705 Fully Qualified Keys for Relationship Types","text":"<p>Use a <code>key</code> such as: <pre><code>(HolonType)-[DescribedBy]-&gt;(TypeDescriptor)\n</code></pre> This prevents ambiguity and supports inverse resolution.</p>"},{"location":"importing-data/holon-data-loader-design-spec/#ref-is-the-only-reference-format","title":"\u2705 <code>$ref</code> Is the Only Reference Format","text":"<p>Reference targets in relationships must use <code>$ref</code> strings, such as: - <code>#temp-key</code> - <code>Type:Key</code> - <code>id:&lt;HolonId&gt;</code> - <code>@Proxy:Type:Key</code> - <code>ext:&lt;ProxyId&gt;:&lt;LocalId&gt;</code></p>"},{"location":"importing-data/holon-data-loader-design-spec/#data-loader-flow","title":"\ud83d\udcca Data Loader Flow","text":"<ol> <li>Author Holons \u2013 Use Airtable or any editor</li> <li>Convert to JSON \u2013 Jupyter notebook or custom tool</li> <li>Validate \u2013 Run against JSON Schema</li> <li>Parse \u2013 Create internal <code>HolonImportSpec</code> structs</li> <li>Pass 1: Stage Holons<ul> <li>Assign temp_keys and validate shape</li> <li>Properties only; defer relationships</li> </ul> </li> <li>Pass 2: Stage Relationships<ul> <li>Resolve references using <code>$ref</code></li> </ul> </li> <li>Commit \u2013 Insert holons via <code>holons_core</code></li> <li>Validate \u2013 Trigger integrity zome and shared validators</li> </ol>"},{"location":"importing-data/holon-data-loader-design-spec/#example-holon-with-relationships","title":"\ud83d\udd01 Example Holon with Relationships","text":"<pre><code>{\n  \"type\": \"#BookType\",\n  \"temp_key\": \"book-001\",\n  \"properties\": {\n    \"title\": { \"type\": \"#MapStringValueType\", \"value\": \"Future Primal\" }\n  },\n  \"relationships\": [\n    { \"name\": \"AUTHORED_BY\", \"target\": { \"$ref\": \"PersonType:charles-eisenstein\" } },\n    { \"name\": \"MENTORED_BY\", \"target\": { \"$ref\": \"#mentor-temp-001\" } }\n  ]\n}\n</code></pre>"},{"location":"importing-data/holon-data-loader-design-spec/#meta-modeling-relationship-types","title":"\ud83c\udf93 Meta-Modeling: Relationship Types","text":""},{"location":"importing-data/holon-data-loader-design-spec/#primary-vs-inverse-relationship-types","title":"\u2709\ufe0f Primary vs. Inverse Relationship Types","text":"<p>Use two types: - <code>MetaPrimaryRelationshipType</code>: explicitly declared by source - <code>MetaInverseRelationshipType</code>: inferred only</p>"},{"location":"importing-data/holon-data-loader-design-spec/#inverse-links","title":"\ud83d\udd01 Inverse Links","text":"<p>Each relationship holon must link to its inverse using: <pre><code>{\n  \"name\": \"InverseOf\",\n  \"target\": { \"$ref\": \"#OtherRelationshipType\" }\n}\n</code></pre></p> <p>Only primary relationships are listed in <code>PRIMARY_SOURCE_FOR</code> of the source HolonType.</p>"},{"location":"importing-data/holon-data-loader-design-spec/#key-rules-for-relationship-types","title":"\ud83d\udcc4 Key Rules for Relationship Types","text":"<pre><code>{\n  \"format\": \"($0)-[$1]-&gt;($2)\",\n  \"property_names\": [\"source_type\", \"type_name\", \"target_type\"]\n}\n</code></pre> <p>This ensures uniqueness and proper <code>$ref</code> resolution.</p>"},{"location":"importing-data/holon-data-loader-design-spec/#validation-overview","title":"\ud83e\udd1d Validation Overview","text":"<ul> <li>Holon validation happens via Holochain callbacks</li> <li>Type validation uses shared holochain-independent logic</li> <li><code>$ref</code> entries must resolve in Pass 2 or trigger errors</li> </ul>"},{"location":"importing-data/holon-data-loader-design-spec/#design-philosophy_1","title":"\ud83c\udf10 Design Philosophy","text":"Principle Description Holonic Uniformity Everything (types, rules, instances) is a holon Self-Describing <code>type</code> and <code>key</code> provide all descriptor info Keyed Reference Integrity No reference unless <code>key</code> or <code>temp_key</code> defined Two-Pass Import Enables circular refs and easy authoring Minimal Format Concise JSON with embedded metadata"},{"location":"importing-data/holon-data-loader-design-spec/#next-steps","title":"\ud83d\udd2e Next Steps","text":"<ul> <li>Add section on symbolic references via <code>DanceRequest</code></li> <li>Add schema examples for EnumType, PropertyType, etc.</li> <li>Publish complete reference <code>bootstrap-import.schema.json</code></li> </ul> <p>\u2e3b</p>"},{"location":"importing-data/holon-data-loader-guide/","title":"MAP Holon Data Loader: JSON Import Format \u2013 Comprehensive Authoring Guide","text":"<p>This guide provides developers with a complete and authoritative reference for constructing valid JSON import files for the MAP Holon Data Loader. It reflects current conventions for authoring schema definitions, base/core types, and domain-specific instances in a self-describing, holonic data model.</p>"},{"location":"importing-data/holon-data-loader-guide/#overview","title":"\u2728 Overview","text":"<p>The MAP Holon Data Loader allows for the declarative import of holons and their relationships into a MAP-compatible space. The import format is intentionally minimal, self-describing, and designed for bootstrapping both type descriptors and real data without relying on runtime logic.</p> <p>All holons \u2014 including types, schemas, and instances \u2014 are defined uniformly. Their type, structure, and descriptors are all expressible using the same format.</p>"},{"location":"importing-data/holon-data-loader-guide/#foundational-concepts","title":"\ud83d\udcda Foundational Concepts","text":"<p>MAP import files are composed of holons \u2014 self-contained objects representing types, data, or components. This section introduces three key concepts that underpin the entire format.</p>"},{"location":"importing-data/holon-data-loader-guide/#holons-and-types","title":"Holons and Types","text":"<p>Every holon has a <code>type</code> that points to a type descriptor (e.g., <code>BookType</code>, <code>PropertyType</code>). The type is used to determine:</p> <ul> <li>What properties are allowed</li> <li>What relationships can be included</li> <li>How validation is applied</li> </ul> <p>The <code>type</code> field acts as both a signal and a shortcut. It removes the need to include an explicit <code>DescribedBy</code> relationship.</p>"},{"location":"importing-data/holon-data-loader-guide/#keyed-vs-keyless-holon-types","title":"Keyed vs. Keyless Holon Types","text":"<p>Every holon in MAP is an instance of a HolonType, and that HolonType determines whether instances are keyed or keyless.</p> <ul> <li>Keyed Holon Types require that each instance includes a stable <code>key</code>, derived from one or more of its properties using a <code>UsesKeyRule</code>. Holons of these types:</li> <li>Must include a <code>key</code> field in the JSON import</li> <li>May be referenced elsewhere using <code>$ref</code></li> <li> <p>May be the target of declared relationships</p> </li> <li> <p>Keyless Holon Types do not permit their instances to include a key. Holons of these types:</p> </li> <li>Must be embedded inline wherever they are used</li> <li>May not be referenced via <code>$ref</code> (not even by <code>id:</code>)</li> <li>May not be the target of any declared relationship</li> <li>Must act as the source of at least one relationship to a keyed holon (to remain anchored in the graph)</li> </ul> <p>This distinction is structural and enforced during staging. The loader will reject any violation of these rules \u2014 including attempts to reference or directly target a keyless holon.</p> <p>\ud83d\udd0d Whether a holon is keyed is not an authoring choice \u2014 it is defined by the HolonType it instantiates.</p>"},{"location":"importing-data/holon-data-loader-guide/#key-derivation-rules","title":"\ud83d\udd22 Key Derivation Rules","text":"<p>Every keyed holon must declare a <code>UsesKeyRule</code>, pointing to a <code>FormatKeyRule</code> with:</p> <ul> <li><code>format</code>: A string template (e.g., <code>\"$0\"</code>, <code>\"($0)-[$1]-&gt;($2)\"</code>)</li> <li><code>property_names</code>: List of property or inferred names used to fill the format</li> </ul> <p>The authored <code>key</code> must match the result of evaluating the format rule.</p>"},{"location":"importing-data/holon-data-loader-guide/#foundational-rule-for-all-types","title":"\ud83e\uddf1 Foundational Rule for All Types","text":"<p>Every MAP type descriptor (e.g., <code>BookType</code>, <code>PropertyType</code>, <code>MetaHolonType</code>) must:</p> <ul> <li>\u2705 Be DescribedBy the <code>MetaHolonType</code> \u2014 this defines the meta-structure of the type descriptor itself</li> <li>\u2705 Extend the foundational <code>MetaTypeDescriptor</code> \u2014 inheriting shared fields like <code>type_name</code>, <code>description</code>, etc.</li> </ul> <p>This rule applies uniformly to all types in MAP, including both core types (like <code>PropertyType</code>, <code>SchemaType</code>) and meta-types (like <code>MetaHolonType</code>, <code>MetaSchemaType</code>). It ensures:</p> <ul> <li>\ud83d\udd04 Reflexivity \u2014 Types are holons too</li> <li>\ud83d\udd0d Introspection \u2014 Schema tools can explore and validate all descriptors using a shared structure</li> <li>\ud83e\uddf1 Composability \u2014 Specialized descriptors build on common foundations</li> </ul> <p>\ud83e\udde0 Even <code>MetaHolonType</code> itself is DescribedBy the <code>MetaHolonType</code> and Extends <code>MetaTypeDescriptor</code>.</p>"},{"location":"importing-data/holon-data-loader-guide/#holontype-requirements","title":"\ud83d\udd10 HolonType Requirements","text":"<p>In addition to the foundational rule above, all HolonTypes must:</p> <ul> <li>\u2705 Declare a <code>UsesKeyRule</code> \u2014 either a formatting rule (e.g., <code>TypeName.KeyRule</code>) or <code>None.KeyRule</code></li> </ul> <p>This ensures that the distinction between keyed and keyless types is structurally enforced and discoverable via introspection.</p>"},{"location":"importing-data/holon-data-loader-guide/#best-practices","title":"\ud83d\udcda Best Practices","text":"<ul> <li>\u2705 Include <code>UsesKeyRule</code> for every HolonType descriptor</li> <li>\u2705 Use consistent naming across <code>type_name</code>, <code>display_name</code>, and <code>key</code></li> <li>\u2705 Use inline embedding for keyless holons or unique instances</li> <li>\u2705 Use <code>$ref</code> for reusable, keyed holons</li> <li>\u274c Do not author <code>DescribedBy</code> or <code>OwnedBy</code> \u2014 these are handled automatically</li> </ul>"},{"location":"importing-data/holon-data-loader-guide/#referencing-other-holons-ref-and-inline-embedding","title":"Referencing Other Holons: <code>$ref</code> and Inline Embedding","text":"<p>In MAP\u2019s JSON import format, holons frequently refer to other holons \u2014 whether to define relationships, specify constraints, compose schemas, or extend descriptors. These references can be expressed in one of two interchangeable forms:</p> <ol> <li><code>$ref</code> strings \u2014 Concise pointers to other keyed holons</li> <li>Inline embedded holons \u2014 Full holon objects defined in place</li> </ol> <p>Both forms are valid anywhere a holon is expected, and the Holon Data Loader treats them equivalently when staging, validating, and committing.</p>"},{"location":"importing-data/holon-data-loader-guide/#motivation-reference-scenarios-map-must-support","title":"\ud83e\udde0 Motivation: Reference Scenarios MAP Must Support","text":"Scenario Example Staged vs. Saved Refer to holons defined in the same file or already saved in the space Local vs. External Link to holons from another HolonSpace (e.g., shared schemas) Keyed vs. Keyless <code>$ref</code> keyed holons; embed keyless ones Reusable vs. One-Off Reuse types and entities via <code>$ref</code>; define constraints inline"},{"location":"importing-data/holon-data-loader-guide/#ref-semantics","title":"\ud83e\udded <code>$ref</code> Semantics","text":"<p><code>$ref</code> is a string-based shorthand for referencing previously defined, saved, or external keyed holons. It can be used anywhere a holon is expected and the type can be inferred from context.</p>"},{"location":"importing-data/holon-data-loader-guide/#supported-ref-formats","title":"Supported <code>$ref</code> Formats","text":"<code>$ref</code> Format Meaning Example <code>\"#key\"</code> Reference to a keyed holon by key only <code>\"#future-primal\"</code> <code>\"id:&lt;HolonId&gt;\"</code> Reference by ActionHash (HolonId) <code>\"id:uhCAkYmv...\"</code> <code>\"@Proxy:key\"</code> External holon via proxy name + key <code>\"@Library:Books\"</code> <code>\"ext:&lt;Proxy&gt;:&lt;Id&gt;\"</code> External holon via proxy ID + local ID <code>\"ext:uhProxy:uhId\"</code> <p>\ud83d\udd0d The holon\u2019s type is inferred from context. If the key does not match a holon of the expected type, validation will fail.</p>"},{"location":"importing-data/holon-data-loader-guide/#inline-embedded-holons","title":"\ud83d\udce6 Inline Embedded Holons","text":"<p>Use inline embedding to define a holon directly in context. This is required for:</p> <ul> <li>Keyless holons</li> <li>One-off structures, like constraints or descriptors</li> <li>Situations where local scoping improves clarity</li> </ul> <p>Caveat: Each inline Holon is importing a new Holon, be careful to avoid unwanted duplication</p>"},{"location":"importing-data/holon-data-loader-guide/#reference-examples","title":"\u2705 Reference Examples","text":"<p>TBD</p>"},{"location":"importing-data/holon-data-loader-guide/#invalid-reference-cases","title":"\ud83d\udeab Invalid Reference Cases","text":"<ul> <li>\u274c <code>$ref</code> to a keyless holon (must be embedded)</li> <li>\u274c <code>id:</code> reference to a keyless holon \u2014 even though syntactically allowed, keyless holons must never be the target of a declared relationship</li> <li>\u274c References outside expected type context</li> <li>\u274c Mixing <code>$ref</code> and <code>type</code> in a single object</li> </ul>"},{"location":"importing-data/holon-data-loader-guide/#summary","title":"\u2705 Summary","text":"Reference Form Best For Requires Key Reusable? <code>$ref</code> Reuse of shared or saved holons \u2705 Yes \u2705 Yes Inline One-off or keyless components \u274c No \u274c No"},{"location":"importing-data/holon-data-loader-guide/#file-structure","title":"\ud83d\udcc1 File Structure","text":"<p>Each JSON import file consists of two top-level keys:</p> <pre><code>{\n  \"meta\": { ... },\n  \"holons\": [ ... ]\n}\n</code></pre> <ul> <li><code>meta</code>: Metadata describing the file</li> <li><code>holons</code>: List of holon definitions to be imported</li> </ul> <p>Each entry in the <code>holons</code> array is a self-contained JSON object representing a single holon.</p>"},{"location":"importing-data/holon-data-loader-guide/#holon-definition","title":"\ud83d\udd39 Holon Definition","text":"<p>Each holon is a JSON object with four primary fields:</p> <ul> <li><code>type</code>: The descriptor for this holon (replaces <code>DescribedBy</code>)</li> <li><code>key</code>: Required only for keyed holons</li> <li><code>properties</code>: A map of named scalar property values</li> <li><code>relationships</code>: A list of outbound relationships to other holons</li> </ul> <p>See the Foundational Concepts section above for background on types, keys, references, and embedding.</p>"},{"location":"importing-data/holon-data-loader-guide/#type","title":"\ud83e\udde9 <code>type</code>","text":"<p>The <code>type</code> field identifies the HolonType (or other descriptor type) that describes this holon. It replaces the need to author a <code>DescribedBy</code> relationship.</p> <ul> <li>Format: a <code>#Key</code> reference to a known type descriptor</li> <li>Required for all holons</li> </ul> <p>Example:</p> <pre><code>\"type\": \"#BookType\"\n</code></pre> <p>This implies: - The holon is described by a <code>BookType</code> - All properties and relationships must conform to the rules defined by that type</p>"},{"location":"importing-data/holon-data-loader-guide/#key","title":"\ud83e\udde9 <code>key</code>","text":"<p>The <code>key</code> is a unique identifier for keyed holons. It is:</p> <ul> <li>Required for holons of keyed Holon Types</li> <li>Not allowed for holons of keyless Holon Types</li> <li>Used as the reference target for <code>$ref</code> within the same or other import files</li> </ul> <p>Keys are derived based on the holon\u2019s HolonType, which includes a <code>UsesKeyRule</code> relationship pointing to a <code>FormatKeyRule</code>. This rule specifies how to construct the key from the holon\u2019s property values \u2014 and sometimes values on related holons.</p> <p>\ud83d\udd04 Because the key can be deterministically derived from the holon\u2019s structure, including it is technically redundant. However, the <code>key</code> field is explicitly included in the JSON import for: - Improved readability - <code>$ref</code> compatibility - Validation of key correctness at staging time</p>"},{"location":"importing-data/holon-data-loader-guide/#important","title":"\u26a0\ufe0f Important","text":"<p>If any property value involved in key derivation changes, the <code>key</code> field and any <code>$ref</code>'s to it must also be updated to match the new derived value. The loader will recompute the key using the declared <code>FormatKeyRule</code> and compare it to the authored key \u2014 raising a validation error if they do not match.</p>"},{"location":"importing-data/holon-data-loader-guide/#key-derivation-rules_1","title":"\ud83d\udd22 Key Derivation Rules","text":"<p>Every keyed holon must declare a <code>UsesKeyRule</code> relationship pointing to a <code>FormatKeyRule</code> \u2014 a holon that defines how the key should be constructed.</p>"},{"location":"importing-data/holon-data-loader-guide/#formatkeyrule-structure","title":"FormatKeyRule Structure","text":"<p>A <code>FormatKeyRule</code> has two fields:</p> <ul> <li><code>format</code>: A string template (e.g., <code>\"$0\"</code>, <code>\"($0)-[$1]-&gt;($2)\"</code>)</li> <li><code>property_names</code>: An ordered list of names (strings) that supply the values for the placeholders</li> </ul> <p>Example:</p> <pre><code>{\n  \"type\": \"#FormatKeyRule\",\n  \"properties\": {\n    \"format\": \"$0\",\n    \"property_names\": [\"type_name\"]\n  }\n}\n</code></pre>"},{"location":"importing-data/holon-data-loader-guide/#common-patterns","title":"\u2705 Common Patterns","text":"<p>Single-property key (e.g., <code>MapStringValueType</code>): <pre><code>{\n  \"format\": \"$0\",\n  \"property_names\": [\"type_name\"]\n}\n</code></pre></p> <p>**Relationship Type Keys ** (inspired by OpenCypher notation): <pre><code>{\n  \"format\": \"($0)-[$1]-&gt;($2)\",\n  \"property_names\": [\"source_type\", \"type_name\", \"target_type\"]\n}\n</code></pre></p>"},{"location":"importing-data/holon-data-loader-guide/#declaring-useskeyrule","title":"\u270d\ufe0f Declaring UsesKeyRule","text":"<p>Inline:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": {\n    \"type\": \"#FormatKeyRule\",\n    \"properties\": {\n      \"format\": \"$0\",\n      \"property_names\": [\"type_name\"]\n    }\n  }\n}\n</code></pre> <p>By reference:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": { \"$ref\": \"FormatKeyRule:BookType.KeyRule\" }\n}\n</code></pre> <p>The loader validates all authored <code>key</code> values by recomputing them using the declared key rule and comparing the result.</p>"},{"location":"importing-data/holon-data-loader-guide/#properties","title":"\ud83e\udde9 <code>properties</code>","text":"<p>The <code>properties</code> field contains a map of property name to scalar value, like so:</p> <pre><code>\"properties\": {\n  \"type_name\": \"BookType\",\n  \"enabled\": true,\n  \"max_length\": 255\n}\n</code></pre> <p>Each value must be one of the supported MAP scalar types: - <code>string</code> (e.g., <code>\"BookType\"</code>) - <code>number</code> (e.g., <code>42</code>, <code>3.14</code>) - <code>boolean</code> (e.g., <code>true</code>, <code>false</code>) - or an array of scalars (for multi-valued properties)</p> <p>Property types are enforced by the <code>PropertyType</code> descriptor referenced in the holon\u2019s <code>type</code>. The loader will convert each value into its appropriate <code>BaseValue</code> variant based on the declared value type \u2014 not based on any in-band <code>\"type\"</code> or <code>\"value\"</code> tags.</p> <p>\ud83d\udd12 Property values must be scalars. You cannot use structured objects (like <code>{ \"type\": ..., \"value\": ... }</code>) inside the <code>properties</code> field. Those are only valid in embedded holons or type definitions.</p>"},{"location":"importing-data/holon-data-loader-guide/#relationships","title":"\ud83e\udde9 <code>relationships</code>","text":"<p>In MAP, every relationship pair is modeled as two named, uni-directional relationships:</p> <ul> <li>A declared relationship (e.g., <code>(Person)-[HasAddress]-&gt;(Address)</code>)</li> <li>Its corresponding inverse relationship (e.g., <code>(Address)-[AddressOf]-&gt;(Person)</code>)</li> </ul> <p>Strictly speaking, only declared relationships are allowed to be directly populated in the system\u2019s internal storage model. Inverse relationships are automatically derived based on this. However, the JSON import format allows you to populate either direction for convenience.</p> <p>If a JSON import populates an inverse relationship, the Holon Data Loader will:</p> <ol> <li>Look up its <code>InverseOf</code> link to find the declared relationship type.</li> <li>Internally redirect the population to that declared relationship.</li> <li>Leave the inverse direction empty (it will be auto-derived later).</li> </ol> <p>This supports a more natural and readable JSON layout in many scenarios.</p>"},{"location":"importing-data/holon-data-loader-guide/#authoring-guidelines","title":"\u26a0\ufe0f Authoring Guidelines","text":"<ul> <li> <p>\u2705 Only populate one direction of a relationship pair.   Do not populate both <code>HasAddress</code> and <code>AddressOf</code>.</p> </li> <li> <p>\u26a0\ufe0f If the relationship involves a keyless holon type:</p> </li> <li>The declared relationship must be defined on the keyed holon type.</li> <li>You must embed the keyless holon inline, using the inverse direction.</li> </ul>"},{"location":"importing-data/holon-data-loader-guide/#example-embedding-a-keyless-holon","title":"\u2705 Example: Embedding a Keyless Holon","text":"<p>Let\u2019s say <code>PersonType</code> declares the relationship <code>HasAddress \u2192 AddressType</code>, and <code>AddressType</code> is keyless. We want to attach an address to a person:</p> <pre><code>{\n  \"type\": \"#PersonType\",\n  \"key\": \"charles-eisenstein\",\n  \"properties\": {\n    \"name\": \"Charles Eisenstein\"\n  },\n  \"relationships\": [\n    {\n      \"name\": \"AddressOf\",  // inverse of declared \"HasAddress\"\n      \"target\": {\n        \"type\": \"#AddressType\",  // keyless, so must be embedded\n        \"properties\": {\n          \"city\": \"Keene\",\n          \"state\": \"New Hampshire\"\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"importing-data/holon-data-loader-guide/#explanation","title":"\ud83e\udde0 Explanation","text":"<ul> <li><code>AddressType</code> is keyless \u2192 it must not be the target of a declared relationship.</li> <li><code>PersonType</code> declares <code>HasAddress \u2192 AddressType</code></li> <li>JSON authors embed the keyless <code>Address</code> and populate its inverse relationship, <code>AddressOf \u2192 Person</code></li> <li>The loader internally flips it and populates <code>HasAddress(charles-eisenstein \u2192 [Address])</code></li> </ul>"},{"location":"importing-data/holon-data-loader-guide/#declared-vs-inverse-relationships","title":"\ud83d\udd01 Declared vs. Inverse Relationships","text":"<p>When importing instance holons, each outbound <code>relationship</code> must ultimately correspond to a declared relationship \u2014 that is, a relationship defined as outbound from the holon\u2019s type.</p> <p>However, the MAP import format allows you to use either direction of a relationship pair when authoring instance data:</p> <ul> <li>A declared relationship, such as:   <pre><code>(Book)-[AUTHORED_BY]-&gt;(Person)\n</code></pre></li> <li>Its corresponding inverse relationship, such as:   <pre><code>(Person)-[AuthorOf]-&gt;(Book)\n</code></pre></li> </ul> <p>These two together form a relationship pair, where one is marked as the <code>InverseOf</code> the other in its relationship type definition.</p> <p>\ud83d\udd04 Even though only declared relationships are persisted, the loader will redirect inverse relationship usage to the appropriate declared relationship and populate it accordingly.</p>"},{"location":"importing-data/holon-data-loader-guide/#authoring-either-direction","title":"\u2705 Authoring Either Direction","text":"<p>In your JSON import file, you may use either side:</p> <pre><code>{\n  \"name\": \"AUTHORED_BY\",\n  \"target\": { \"$ref\": \"person-789\" }\n}\n</code></pre> <p>or:</p> <pre><code>{\n  \"name\": \"AuthorOf\",\n  \"target\": { \"$ref\": \"book-123\" }\n}\n</code></pre> <p>Either form will result in the declared <code>AUTHORED_BY</code> relationship being populated.</p>"},{"location":"importing-data/holon-data-loader-guide/#authoring-guidelines_1","title":"\u26a0\ufe0f Authoring Guidelines","text":"<ul> <li> <p>\u2705 Only populate one direction of a relationship pair.   Do not populate both <code>AUTHORED_BY</code> and <code>AuthorOf</code> \u2014 choose one or the other.</p> </li> <li> <p>\u26a0\ufe0f If one end of the relationship is a keyless holon (e.g., an inline annotation or constraint):</p> </li> <li>The keyless holon\u2019s type must declare the relationship.</li> <li>You must populate the inverse direction using an embedded target, not a <code>$ref</code>.</li> </ul> <p>\ud83e\udde0 Internally, only declared relationships are directly populated. The system automatically backfills the corresponding inverse relationships.</p> <p>A separate section provides guidance on defining declared and inverse relationship types, and how the <code>InverseOf</code> and <code>Inverse</code> links connect them.</p> <p>In MAP, every relationship pair is modeled as two named, uni-directional relationships:</p> <ul> <li>A declared relationship (e.g., <code>(Book)-[AuthoredBy]-&gt;(Person)</code>)</li> <li>Its corresponding inverse relationship (e.g., <code>(Person)-[AuthorOf]-&gt;(Book)</code>)</li> </ul> <p>Strictly speaking, only declared relationships are allowed to be directly populated in the system\u2019s internal storage model. Inverse relationships are automatically derived based on this. However, the JSON import format allows you to populate either direction for convenience.</p> <p>If a JSON import populates an inverse relationship, the Holon Data Loader will:</p> <ol> <li>Look up its <code>InverseOf</code> link to find the declared relationship type.</li> <li>Internally redirect the population to that declared relationship.</li> <li>Leave the inverse direction empty (it will be auto-derived later).</li> </ol> <p>This supports a more natural and readable JSON layout in many scenarios.</p>"},{"location":"importing-data/holon-data-loader-guide/#example-using-inverse-in-json","title":"\u2705 Example: Using Inverse in JSON","text":"<p>You may populate the <code>Extends</code> relationship directly:</p> <pre><code>{\n  \"name\": \"Extends\",\n  \"target\": { \"$ref\": \"MetaTypeDescriptor\" }\n}\n</code></pre> <p>Or, equivalently, populate the inverse <code>ExtendedBy</code>:</p> <pre><code>{\n  \"name\": \"ExtendedBy\",\n  \"target\": {\n    \"type\": \"#MetaHolonType\",\n    \"properties\": {\n      \"type_name\": \"MetaHolonType\"\n    }\n  }\n}\n</code></pre> <p>Both will result in the same internal relationship being established \u2014 on the declared <code>Extends</code> direction.</p>"},{"location":"importing-data/holon-data-loader-guide/#authoring-rules-and-caveats","title":"\u26a0\ufe0f Authoring Rules and Caveats","text":"<p>To ensure consistency and correctness, observe the following:</p> <ul> <li>\u2705 Only one direction of a relationship pair should be populated in your JSON file.</li> <li>\u2705 If you choose to use the inverse relationship in your JSON, ensure the inverse type includes an <code>InverseOf</code> link to its declared counterpart.</li> <li>\u26a0\ufe0f If either source or target holon type in the relationship is keyless:</li> <li>That keyless type must declare the relationship (i.e., be the source of the declared direction).</li> <li>The inverse direction must be populated inline, via embedded holons \u2014 since keyless holons cannot be referenced.</li> </ul>"},{"location":"importing-data/holon-data-loader-guide/#relationship-pairing-inverseof-and-inverse","title":"\ud83d\udd04 Relationship Pairing: <code>InverseOf</code> and <code>Inverse</code>","text":"<p>Each inverse relationship must include an <code>InverseOf</code> link to its declared counterpart:</p> <pre><code>{\n  \"name\": \"InverseOf\",\n  \"target\": { \"$ref\": \"#(RelationshipType)-[Extends]-&gt;(RelationshipType)\" }\n}\n</code></pre> <p>Once this is present, the system automatically adds the reverse link using <code>Inverse</code>:</p> <pre><code>{\n  \"name\": \"Inverse\",\n  \"target\": { \"$ref\": \"#(RelationshipType)-[ExtendedBy]-&gt;(RelationshipType)\" }\n}\n</code></pre> <p>You do not need to author <code>Inverse</code> links directly.</p> <p>==== OLDER STUFF</p> <p>The <code>relationships</code> field is a list of outbound links from the holon to other holons.</p> <p>Each entry must contain: - <code>name</code>: the name of the relationship - <code>target</code>: a single holon, a <code>$ref</code>, or an array of either</p> <p>You may use either of the following forms:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": { \"$ref\": \"FormatKeyRule:Book.KeyRule\" }\n}\n</code></pre> <p>or</p> <pre><code>{\n  \"name\": \"Components\",\n  \"target\": [\n    { \"$ref\": \"BookType\" },\n    { \"$ref\": \"PersonType\" }\n  ]\n}\n</code></pre> <p>\u2705 The loader automatically normalizes all <code>target</code> values to arrays. Even single references are treated as 1-element arrays internally.</p> <p>\u26a0\ufe0f Cardinality constraints are enforced using the type descriptor associated with the relationship name. For example, relationships like <code>DescribedBy</code> or <code>ComponentOf</code> often have <code>max_cardinality = 1</code>.</p>"},{"location":"importing-data/holon-data-loader-guide/#embedded-schema-structure","title":"\ud83d\udcc2 Embedded Schema Structure","text":"<p>Schemas may embed their components directly via inverse relationships:</p> <pre><code>{\n  \"type\": \"#MapSchemaType\",\n  \"key\": \"MAP Core Schema\",\n  \"relationships\": [\n    {\n      \"name\": \"Components\",\n      \"target\": [ { holon }, { holon } ]\n    }\n  ]\n}\n</code></pre> <p>These will be rewritten by the loader into <code>ComponentOf</code> declarations from each child.</p>"},{"location":"importing-data/holon-data-loader-guide/#defining-the-relationships-for-a-type","title":"Defining the Relationships for a Type:","text":""},{"location":"importing-data/holon-data-loader-guide/#declaring-vs-instantiating-relationships","title":"\ud83d\udd04 Declaring vs. Instantiating Relationships","text":"<p>In the MAP import format, it is essential to distinguish between two conceptually distinct usages of relationships:</p>"},{"location":"importing-data/holon-data-loader-guide/#1-declaring-allowed-relationships-for-a-type","title":"1. Declaring Allowed Relationships for a Type","text":"<p>When defining a type descriptor, we use the <code>InstanceRelationships</code> relationship to declare what kinds of relationships instances of this type may include. The targets of <code>InstanceRelationships</code> must be relationship types.</p> <p>Example:</p> <pre><code>{\n  \"name\": \"InstanceRelationships\",\n  \"target\": [\n    { \"$ref\": \"#(TypeDescriptor)-[ComponentOf]-&gt;(Schema)\" }\n  ]\n}\n</code></pre> <p>This states that instances of this type (e.g., <code>TypeDescriptor</code>) may include a <code>ComponentOf</code> relationship, and identifies the structural pattern expected for that relationship. The details of that relationship type (cardinality constraints, whether it is definitional, etc.) are defined in the referenced RelationshipType descriptor.</p>"},{"location":"importing-data/holon-data-loader-guide/#2-instantiating-a-specific-relationship-for-a-holon","title":"2. Instantiating a Specific Relationship for a Holon","text":"<p>When authoring a specific holon, such as a type descriptor or instance, the <code>relationships</code> field is used to instantiate actual relationship instances. These entries must include:</p> <ul> <li>A <code>name</code>: the name of the relationship</li> <li>A <code>target</code>: the holon being linked to (typically via <code>$ref</code>)</li> </ul> <p>\u2705 Correct:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": { \"$ref\": \"#TypeName.KeyRule\" }\n}\n</code></pre> <p>\u274c Incorrect:</p> <pre><code>{\n  \"name\": \"UsesKeyRule\",\n  \"target\": {\n    \"type\": \"#Format.KeyRuleType\",\n    \"key\": \"TypeName.KeyRule\",\n    ...\n  }\n}\n</code></pre> <p>The incorrect version attempts to define the target inline \u2014 which may duplicate shared definitions and blur the separation of concerns between relationship declarations and relationship instances.</p>"},{"location":"importing-data/holon-data-loader-guide/#key-takeaway","title":"\ud83e\udded Key Takeaway","text":"<p>When declaring which relationships a type supports, point to relationship types. When instantiating a relationship in a holon, point to a target holon \u2014 typically via <code>$ref</code>.</p> <p>Following this rule ensures structural clarity, enables reuse, and keeps the MAP type system modular and DRY.</p>"},{"location":"importing-data/holon-data-loader-guide/#key-derivation-rules_2","title":"\ud83d\udd22 Key Derivation Rules","text":"<p>Every keyed holon must declare a <code>UsesKeyRule</code>, pointing to a <code>FormatKeyRule</code> with:</p> <ul> <li><code>format</code>: A string template (e.g., <code>\"$0\"</code>, <code>\"($0)-[$1]-&gt;($2)\"</code>)</li> <li><code>property_names</code>: List of property or inferred names used to fill the format</li> </ul> <p>The authored <code>key</code> must match the result of evaluating the format rule.</p>"},{"location":"importing-data/holon-data-loader-guide/#best-practices_1","title":"\ud83d\udcda Best Practices","text":"<ul> <li>\u2705 Include <code>UsesKeyRule</code> for every keyed type descriptor</li> <li>\u2705 Use consistent naming across <code>type_name</code>, <code>display_name</code>, and <code>key</code></li> <li>\u2705 Use inline embedding for keyless holons or unique instances</li> <li>\u2705 Use <code>$ref</code> for reusable, keyed holons</li> <li>\u274c Do not author <code>DescribedBy</code> or <code>OwnedBy</code> \u2014 these are handled automatically</li> </ul>"},{"location":"importing-data/holon-data-loader-guide/#validation","title":"\ud83d\udd0e Validation","text":"Rule ID Title Description Severity json-schema Syntactic validation via JSON Schema The file must conform to the MAP JSON import format schema. error foundational-rule Foundational Rule for All Type Descriptors Every Type Descriptor must be DescribedBy the MetaHolonType and Extend the MetaTypeDescriptor. error unresolved-refs Unresolved References All $ref values must resolve to a keyed holon defined in the same or explicitly provided files. error only-declared-properties Only Declared Properties May Be Populated Holons must not specify properties not listed in InstanceProperties of their type. error only-declared-relationships Only Valid Relationships May Be Authored The import file may only author relationships that are either: (1) explicitly listed in the holon\u2019s type descriptor via InstanceRelationships, or (2) valid inverse relationships, which are resolved via InverseRelationshipType definitions that point back to a DeclaredRelationshipType where the holon\u2019s type is the TargetType. The system applies updates through the canonical declared direction. error <p>Files should be validated against:</p> <ol> <li><code>bootstrap-import.schema.json</code> \u2014 ensures structural correctness</li> <li>Schema-specific definitions \u2014 derived from the loaded Meta-Schema or Core Schema</li> </ol> <p>Holons are further validated at runtime by MAP\u2019s shared validators.</p>"},{"location":"importing-data/holon-data-loader-guide/#ready-to-import","title":"\ud83c\udf89 Ready to Import","text":"<p>Once authored and validated, the file can be submitted to the Holon Data Loader.</p> <ul> <li>All <code>key</code> and <code>$ref</code> references will be resolved</li> <li>Relationships will be rewritten as needed</li> <li>Keyless holons will be embedded</li> <li>All imported holons will be linked to the HolonSpace via <code>OwnedBy</code></li> </ul> <p>For support, contact the MAP stewarding team or refer to the developer documentation.</p>"},{"location":"reference/glossary/","title":"\ud83e\uddfe Glossary","text":"<p>This glossary defines key concepts and terms used throughout the MAP architecture and narrative framework. Terms are listed alphabetically. Multiple definitions are included where distinctions emerged between narrative threads.</p>"},{"location":"reference/glossary/#agent","title":"Agent","text":"<p>An Agent is any entity capable of sensing and responding to its environment. It may be biological (e.g., a person, whale, or tree), technical (e.g., a computing process), or social (e.g., a family, cooperative, or commons).</p> <ul> <li>Every Agent has a unique identity and a corresponding I-Space \u2014 a private AgentSpace that houses its LifeCode, Data Grove, and core affordances. </li> <li>Agents can make offers and accept offers made by others to form Agreements.</li> </ul> <p>Agents are expressed as Holons that belong to one or more AgentSpaces. Every Agent belongs to the Exosphere and typically one or more additional AgentSpaces.</p>"},{"location":"reference/glossary/#agentspace","title":"AgentSpace","text":"<p>An AgentSpace is a membrane-bound social space where Agents interact, co-create, and participate in regenerative value flows. It is simultaneously:</p> <ul> <li>A HolonSpace \u2014 stewarding both Agents and Holons</li> <li>A container for knowledge, relationships, and shared governance</li> <li>A venue for Offers, Agreements, Promises, and visualization</li> </ul> <p>Every AgentSpace has its own LifeCode, and every interaction between Agents happens within an AgentSpace.</p> <p>\u26a0\ufe0f Not every AgentSpace is itself an Agent (i.e., not all are Social Organisms), but some  AgentSpaces, once sufficiently coherent and governed, may themselves become Agents \u2014 emergent wholes acting at a higher level of the holarchy.</p>"},{"location":"reference/glossary/#agreement","title":"Agreement","text":"<p>An Agreement is created from an Offer when agents have accepted all of the mandatory roles of the Offer. An Agreement may instantiate its own Agreement-Based AgentSpace which becomes the interaction venue for activities governed by that agreement.</p>"},{"location":"reference/glossary/#agreement-based-agentspace","title":"Agreement-Based AgentSpace","text":"<p>An Agreement-Based AgentSpace is a bounded interaction context that emerges when an Offer is accepted and an Agreement is formed.</p> <p>It includes: - All participating Agents - A LifeCode derived from the shared promises and intent of the Agreement - A scoped Data Grove of relevant Holons and references - The governance and coordination logic encoded in the Agreement, including optional roles for verification, mediation, or escalation</p> <p>While agreements may expire, be revoked, or become inactive, the AgentSpace itself \u2014 like all entities in the MAP \u2014 is immutable and persistent. Its history, structure, and prior interactions remain verifiable and accessible, preserving both accountability and lineage.</p> <p>An Agreement-Based AgentSpace is the sovereign membrane where promises take form, interactions unfold, and trust-based coordination becomes possible \u2014 with a cryptographically assured memory.</p>"},{"location":"reference/glossary/#choreographer","title":"Choreographer","text":"<p>The Choreographer is the MAP\u2019s native coordination engine. It manages the invocation and sequencing of modular dances across agents, spaces, and roles using declarative Dance Flows. </p> <p>Each dance performs a single task and emits a completion signal. The Choreographer listens for these signals and, based on the active flow specification and local context, invokes the next appropriate step. By keeping sequencing logic outside of individual dances, MAP enables complex behaviors to be composed from simple, intelligible parts.</p>"},{"location":"reference/glossary/#commoning","title":"Commoning","text":"<p>Commoning is the ongoing social process through which people collaboratively create, steward, and sustain shared resources (i.e., Vital Capitals) and relationships. At its core, commoning is a relational, participatory, and adaptive practice that reclaims shared power in managing the conditions of life. It is not just a structure, but a way of being and doing together.</p> <p>Commoning emerges outside of \u2014 and often in resistance to \u2014 market and state logics, cultivating trust, reciprocity, and long-term ecological and social flourishing. The lived practice of mutual care, collective governance, and cultural co-creation is what enables a commons to thrive.</p> <p>\u201cCommoning is a verb. It\u2019s about the social practices and cultural traditions that people devise to manage shared resources in fair, inclusive, and sustainable ways.\u201d  \u2014 David Bollier, \u201cThink Like a Commoner\u201d (2014)</p> <p>\u201cThere is no commons without commoning.\u201d \u2014 Peter Linebaugh, \u201cThe Magna Carta Manifesto\u201d (2008)</p>"},{"location":"reference/glossary/#commons","title":"Commons","text":"<p>A Commons is a social system for the long-term stewardship of Vital Capital that preserves shared values and community identity. A self-organized system by which communities manage vital capital (both depletable and replenishable) with minimal or no reliance on the Market or State. In the MAP, a commons is represented by an Agent Space whose  LifeCode conveys its community values, join membrane, and governance model.</p>"},{"location":"reference/glossary/#dahn","title":"DAHN (Dynamic Adaptive Holon Navigator)","text":"<p>A personalized, dynamic interface layer for exploring the MAP holon graph. DAHN empowers each agent to shape their own experience \u2014 not just by choosing settings, but by composing the very way information is seen, explored, and interacted with.</p> <p>Rather than each app imposing its own interface, DAHN provides a coherent visual and interaction layer across all Mapps. This coherence is achieved through dynamic selection of visualizers \u2014 modular components contributed by HX designers to the federated Visualizer Commons.</p> <p>DAHN embodies the MAP design philosophy: putting agents at the center of their digital experience, enabling expressive, adaptable, and trustable interfaces that evolve with collective and individual needs.</p>"},{"location":"reference/glossary/#dance","title":"Dance","text":"<p>A Dance is a named, invocable action that a Holon can perform or participate in \u2014 such as querying data, initiating a service, accepting an offer, or responding to a relationship.</p> <p>In MAP, dances represent affordances \u2014 the ways a Holon can be interacted with \u2014 but the term affordance felt overly technical and lacked poetic resonance.</p> <p>So we coined the term Dance.</p> <p>Why Dance?</p> <ul> <li>Because dances are relational \u2014 they involve interaction, timing, rhythm, consent.</li> <li>Because they convey graceful interdependence, not mechanical execution.</li> <li>Because in MAP, even technical operations are wrapped in patterns of trust, meaning, and flow.</li> </ul> <p>Dances are defined through the MAP Uniform API, where each <code>DanceRequest</code> expresses: - Who is dancing (the Holon) - What dance is being performed - With what input parameters - Under what conditions</p> <p>And the <code>DanceResponse</code> returns: - The result of the dance - A set of next possible dances based on the current state of the system</p> <p>A Dance is not just a function call \u2014 it's a structured act of agency within a living graph of relationship and meaning.</p>"},{"location":"reference/glossary/#dance-flow","title":"Dance Flow","text":"<p>A Dance Flow is a named, context-aware sequence of individual dances that collectively coordinate a process across agents, promises, or Agent Spaces.</p> <p>Each dance within the flow performs a discrete task or role and emits a signal upon completion. The MAP Choreographer responds to these signals by invoking the next appropriate dance in the flow, guided by shared agreements and contextual conditions.</p> <p>Key Characteristics: - Composable: Built from modular, reusable dances. - Declarative: Specifies what should unfold, not how each dance works internally. - Membrane-aware: Executes within or across Agent Spaces while respecting boundaries and permissions. - Promise-aligned: Flows often reflect and reinforce explicit promises among participants.</p> <p>Purpose: Dance Flows enable complex behaviors to emerge through the orchestration of simple, intelligible steps \u2014 making collaborative processes legible, adaptable, and agency-respecting.</p> <p>Related Concepts: \u2192 Dance, Choreographer, Promise Weave, Agent Space</p>"},{"location":"reference/glossary/#dance-interface-protocol","title":"Dance Interface Protocol","text":"<p>The Dance Interface Protocol is the universal invocation protocol in the MAP. It replaces traditional REST or RPC calls with a more expressive, memetic, and composable request model.</p> <p>Every Holon exposes available Dances depending on its current state and context.</p>"},{"location":"reference/glossary/#dancerequest","title":"DanceRequest","text":"<p>A DanceRequest is a Holon-encoded invocation of a Dance. It tells a Holon what is being requested \u2014 and under what terms.</p> <p>Each <code>DanceRequest</code> contains: - The ID of the Holon being danced with - The name of the Dance being invoked - A RequestBody \u2014 including input parameters, context, and initiating agent identity - (Optionally) an associated Agreement that governs the terms of the interaction</p> <p>Like all things in the MAP, the DanceRequest is itself a Holon \u2014 with its own type descriptor, provenance, access policy, and potential for visual representation.</p> <p>DanceRequests can be created by: - Human users interacting through DAHN  - Other Holons (e.g., service Holons triggering dances) - External systems interfacing through the MAP Uniform API</p> <p>A <code>DanceRequest</code> is a memetically and permissionally aware act of intent \u2014 a moment of coordinated agency within a shared graph.</p>"},{"location":"reference/glossary/#danceresponse","title":"DanceResponse","text":"<p>A DanceResponse is the result of performing a Dance. It includes not only the outcome of the request but also the forward affordances \u2014 what the Holon now makes possible.</p> <p>Each <code>DanceResponse</code> includes: - A ResponseBody \u2014 containing results, messages, or new Holons - A list of next available Dances \u2014 HATEOAS-style descriptors of follow-up actions - Provenance metadata and optional diagnostics - Links to updated state, derived Agreements, or resulting relationships</p> <p>Like the <code>DanceRequest</code>, the <code>DanceResponse</code> is a fully self-describing Holon and can be visualized, shared, or referenced by other components of the MAP.</p> <p>A <code>DanceResponse</code> is not just a return value \u2014 it\u2019s the moment-by-moment emergence of possibility in a living graph of consent and flow.</p>"},{"location":"reference/glossary/#data-grove","title":"Data Grove","text":"<p>A Data Grove is the sovereign, Holochain-based data storage area. Each AgentSpace has its own private Data Grove.  All of the mapps that are imported into an Agent Space store their information in the Data Grove of that Space.</p>"},{"location":"reference/glossary/#echo","title":"Echo","text":"<p>An Echo is a signed affirmation of a Promise made by another Agent, issued by an agent who chooses to align with that promise.</p> <p>Echoes serve as memetic endorsements\u2014reinforcing, repeating, and extending the trustworthiness of a promise in a given AgentSpace or across spaces.</p> <p>An Echo is:</p> <ul> <li>A verbatim reference to an existing Promise, not a reinterpretation</li> <li>A social trust gesture\u2014binding the echoing agent\u2019s reputation to the original claim</li> <li>A signal of observability\u2014often grounded in direct experience, shared context, or role-based verification</li> <li>A building block of memetic trust networks, used to evaluate promises, inform Agreements, and govern access or delegation</li> </ul> <p>Echoes may carry optional metadata such as echo weight, reasoning, or contextual scope (e.g., \u201cwithin this space only\u201d).</p> <p>\u2733\ufe0f Echoes are foundational to MAP\u2019s distributed trust model\u2014allowing agents to construct verifiable, socially-scaffolded identity and reputation without centralized authorities.</p>"},{"location":"reference/glossary/#echo-weight","title":"Echo Weight","text":"<p>An Echo Weight is an optional indicator attached to an Echo, expressing the echoing Agent\u2019s degree of confidence, verification, or proximity to the original Promise.</p> <p>Echo Weights enable more nuanced interpretation of social signals by:</p> <ul> <li>Differentiating firsthand from secondhand endorsements</li> <li>Informing access decisions, Agreement thresholds, and trust scores</li> <li>Supporting evaluative logic in AgentSpaces and across social holarchies</li> </ul> <p>Weights may be numeric (e.g., 0.9), categorical (e.g., \u201cstrong,\u201d \u201clight\u201d), or policy-defined by a GroupAgent.</p> <p>\u2733\ufe0f While optional, Echo Weights help MAP spaces distinguish between weak support and strong verification\u2014without requiring rigid central scoring systems.</p>"},{"location":"reference/glossary/#exosphere","title":"Exosphere","text":"<p>The Exosphere is the outermost, most inclusive AgentSpace in the MAP. It includes all Agents by default and serves as the lowest-threshold interaction venue across the entire platform.</p> <p>The Exosphere is:</p> <ul> <li>Non-governed (aside from platform-level rules)</li> <li>High-reach, low-trust</li> <li>The place where initial Offers may be surfaced to broad audiences</li> </ul> <p>It is not a commons or Social Organism \u2014 it is a shared membrane of visibility.</p>"},{"location":"reference/glossary/#governance-scaffold","title":"Governance Scaffold","text":"<p>A Governance Scaffold is a modular structure of roles, rules, and processes that guides how coordination and decision-making unfold within an AgentSpace.</p> <p>Rather than imposing a fixed governance model, a governance scaffold provides lightweight, composable affordances that can evolve alongside the needs and context of the space. These scaffolds are often memetically sourced from the Global Meme Pool, where patterns like sociocracy, holacracy, liquid democracy, or bespoke cultural traditions can be adapted and instantiated.</p> <p>Governance scaffolds define: - Who has voice and agency - How decisions are made and validated - What roles exist and how they are assigned or rotated - How conflicts are mediated or escalated</p> <p>They can be: - Hard-coded into Agreements - Expressed as Memeplexes in the Meme Pool - Referenced dynamically during Dance Flows</p> <p>\ud83e\udde9 Governance scaffolds are to governance what protocols are to software: flexible, interoperable building blocks that support resilient, adaptive coordination.</p> <p>See also: AgentSpace, LifeCode, Agreement, Meme Pool</p>"},{"location":"reference/glossary/#holon","title":"Holon","text":"<p>A Holon is the foundational unit of structure, meaning, and interaction in the MAP.</p> <p>Every object in the MAP \u2014 whether it\u2019s a piece of content, an Agent, a relationship, a service, or a visual element \u2014 is encoded as a self-describing, active Holon or HolonRelationship.</p>"},{"location":"reference/glossary/#self-describing","title":"\u2727 Self-Describing","text":"<p>A Holon contains within itself everything needed to interpret and interact with it. When you encounter a Holon \u201cin the wild,\u201d you can ask:</p> <ul> <li> <p>What properties do you have?   What are your current values for those properties?</p> </li> <li> <p>What types of relationships do you participate in?   To what other Holons are you related via those relationships?</p> </li> <li> <p>Through what visualizations can I view and interact with you?   Holons reference one or more Visualizers from the commons, allowing fully customizable rendering and interaction \u2014 from list views to immersive spatial experiences.</p> </li> <li> <p>What types of data access are permitted?   Holons carry their own access policies, provenance signatures, and licensing terms \u2014 enabling granular, trustable permissioning.</p> </li> </ul>"},{"location":"reference/glossary/#active","title":"\u2727 Active","text":"<p>Holons aren\u2019t just data \u2014 being active means holons can do stuff... they offer affordances.</p> <p>Every Holon can declare the Dances it is capable of performing \u2014 actions that can be invoked via the MAP Uniform API. These may include:</p> <ul> <li>Responding to queries</li> <li>Invoking relationships</li> <li>Triggering services</li> <li>Participating in negotiations, offers, or agreements</li> </ul> <p>In this way, Holons are not passive records, but sovereign, interactive knowledge actors that make up the living substrate of the MAP.</p> <p>A Holon is not just a piece of data \u2014 it is a meaningful, permissioned, expressive agent of action in a graph of relationships. It sees, responds, and evolves.</p>"},{"location":"reference/glossary/#holonspace","title":"HolonSpace","text":"<p>A HolonSpace is the foundational data container in the MAP, equivalent to an AgentSpace. While the term highlights its function as a steward of Holons, in MAP narratives, the two terms are generally treated as synonymous.</p>"},{"location":"reference/glossary/#i-space","title":"I-Space","text":"<p>An I-Space is an AgentSpace viewed from the interior perspective \u2014 focusing on internal structure, properties, intentions, and affordances of an Agent.</p> <p>Every Agent has an I-Space. For persons, this is often referred to as a Personal I-Space, but not all I-Spaces are personal.</p> <p>See also: We-Space</p>"},{"location":"reference/glossary/#join-membrane","title":"Join Membrane","text":"<p>The set of rules defined by an AgentSpace's Life Code that govern adding new members of the Agent Space.</p>"},{"location":"reference/glossary/#lifecode","title":"LifeCode","text":"<p>A LifeCode (also known as a Memetic Signature) is the values-and-identity encoding of an Agent, AgentSpace, Offer or Agreement. It defines:</p> <ul> <li>Aspirational purpose</li> <li>Memetic values and ethics</li> <li>Governance expectations</li> <li>Membership criteria</li> <li>Expressed Promises</li> </ul> <p>The LifeCode is the symbolic \"membrane\" of an AgentSpace and plays a foundational role in trust-based interaction.</p>"},{"location":"reference/glossary/#meme","title":"Meme","text":"<p>A Meme is a pattern, story, value, or shared practice that carries meaning and can be passed from one person or group to another.</p> <p>In the MAP, a meme could be a community ritual, a traditional teaching, a way of solving problems, a decision-making method, a symbol, or even a sacred story. Some memes are old and passed down through generations. Others are new, shared in conversation, taught in workshops, or built into tools and agreements.</p> <p>What matters is not just where a meme comes from \u2014 but that it helps people live together with intention, take action, or share understanding.</p> <p>Memes travel in many ways. Some are copied, some are taught, some are woven into daily life. In MAP, we honor all of these. Whether a meme is passed in a ceremony, a drawing, a document, or a song \u2014 it becomes part of our living culture when people put it into use.</p> <p>Memes are gathered into Meme Pools, where they can be shared, adapted, and stewarded with care \u2014 so that wisdom from one place can grow in another, without losing its roots.</p> <p>See also: Meme Pool, Vital Capital, LifeCode</p>"},{"location":"reference/glossary/#meme-technical","title":"Meme (technical)","text":"<p>A Meme is a structured unit of cultural meaning that can be defined, expressed, enacted, and evolved by Agents.</p> <p>In the MAP, a meme may take many forms \u2014 including values, principles, protocols, schemas, profiles, practices, rituals, governance models, economic models, or other cultural structures that guide interaction and meaning-making. Every meme is modular, stewardable, and context-aware.</p> <p>In the MAP, memes are not just viral ideas \u2014 they are the living infrastructure of cultural evolution.</p> <p>MAP extends Richard Dawkins\u2019 original definition \u2014 which emphasized replication through imitation \u2014 to include agentic enactment, contextual re-use, and memetic evolution. Memes may spread via imitation (per Dawkins), but also through instruction, documentation, or embedded use in systems and agreements. What defines a meme is not just how it spreads, but that it encodes actionable meaning and can be activated across diverse contexts.</p> <p>Memes are replicable and selectable: they persist through evolutionary dynamics, where their relevance and effectiveness are tested in lived experience. In this way, MAP supports not just cultural transmission, but the iterative refinement and ecological adaptation of its memetic commons.</p> <p>Epistemic rigor \u2014 such as practices rooted in the scientific method \u2014 can strengthen the fidelity and resilience of a meme by making it easier to reproduce, test, and refine across contexts. However, epistemic rigor is neither the sole pathway to replicability nor a universal standard: many memes in MAP draw from spiritual traditions, embodied practices, or lived experience that offer their own forms of coherence, relevance, and transmission.</p> <p>Memes can be classified by:</p> <ul> <li>Type (e.g. atomic meme, schema, protocol, visualizer)</li> <li>Category (e.g. governance, economics, learning, identity)</li> <li>Functional structure (e.g. memeplex, memefamily)</li> </ul> <p>Every Meme in MAP is a form of Vital Capital, and is stewarded within one or more Meme Pools.</p> <p>See also: Meme Pool, Vital Capital, LifeCode</p>"},{"location":"reference/glossary/#meme-pool","title":"Meme Pool","text":"<p>A Meme Pool is a collection of memes together with the agents and governance processes that steward them. In other words, a Meme Pool is a Commons.</p>"},{"location":"reference/glossary/#memetic-signature","title":"Memetic Signature","text":"<p>Synonym for LifeCode. Refers to the expressive encoding of an Agent\u2019s identity, values, and memetic alignment.</p>"},{"location":"reference/glossary/#observability","title":"Observability","text":"<p>Observability describes the degree to which a Promise can be independently verified by other Agents within a given AgentSpace.</p> <p>Every Promise has an implicit or explicit observability profile, which may be:</p> <ul> <li>Direct \u2014 fulfillment is visible to others (e.g., a submitted file, a public action)</li> <li>Indirect \u2014 fulfillment is verifiable through roles, logs, or trusted intermediaries</li> <li>Unobservable \u2014 fulfillment is private or unverifiable (e.g., internal state, intentions)</li> </ul> <p>Spaces may define Observability Profiles that specify the kinds of promises they accept, echo, or require in Agreements.</p> <p>\u2733\ufe0f Observability governs the memetic legibility of a promise\u2014what others can trust, echo, or build upon.</p>"},{"location":"reference/glossary/#offer","title":"Offer","text":"<p>An Offer is a proposed bundle of Promises, expressing both:</p> <ul> <li>What the offering Agent is willing to do or provide</li> <li>What reciprocal Promises it expects in return</li> </ul> <p>Offers are shared into specific AgentSpaces (e.g., the Exosphere or a Social Organism) and may result in Agreements.</p>"},{"location":"reference/glossary/#offer-type","title":"Offer Type","text":"<p>An Offer Type is a reusable template or pattern that defines the structure, roles, conditions, and expectations for a class of Offers in the MAP.</p> <p>Offer Types allow communities and Agents to create Offers with shared semantics and validated structure. Each Offer Type is a Meme \u2014 discoverable, remixable, and stewarded in the Global Meme Pool.</p> <p>Key properties of an Offer Type may include: - A named purpose or intent (e.g., \u201cTimebank Exchange\u201d, \u201cMicrogrant Application\u201d, \u201cCommons Stewardship Invitation\u201d) - The required and optional roles (e.g., Initiator, Contributor, Verifier) - Preconditions and fulfillment criteria - Common reciprocity patterns (e.g., \u201coffer of service in exchange for learning\u201d)</p> <p>By standardizing structure while remaining adaptable, Offer Types reduce friction and ambiguity in peer coordination, and enable the creation of Agreements that are intelligible across diverse contexts.</p> <p>\ud83d\udce6 An Offer Type is a memetic design pattern for regenerative coordination \u2014 shaping how value is proposed, negotiated, and enacted.</p> <p>See also: Offer, Agreement, Meme, Meme Pool</p>"},{"location":"reference/glossary/#promise","title":"Promise","text":"<p>A Promise is a voluntary, sovereign commitment made by one Agent. It is the atomic unit of value coordination within MAP.</p> <p>Promises may be formal (e.g., I promise to transfer 10 units of water in exchange for 5 units of labor) or informal (e.g., I promise to show up with care and attention).</p> <p>All Agreements are built from bundles of Promises.</p>"},{"location":"reference/glossary/#service","title":"Service","text":"<p>Services support the flow and transformation of vital capitals to/from other agents for mutual benefit. Services are the focus of Offers, Agreements, and Service Invocations.</p>"},{"location":"reference/glossary/#service-invocation","title":"Service Invocation","text":"<p>A request to an offering agent to perform a requested service within the context of an active agreement.</p>"},{"location":"reference/glossary/#social-organism","title":"Social Organism","text":"<p>A Social Organism is an AgentSpace that has developed enough internal coherence, governance capacity, and memetic identity to act as an Agent in its own right\u2014a Holon one level up.</p> <p>Unlike the default Exosphere, which includes all agents by default and lacks any collective governance, a Social Organism is formed intentionally. It may emerge from one or more Agreement-Based AgentSpaces and evolve into an agentic identity through extensions to its LifeCode.</p> <p>A key property of Social Organisms\u2014described by Ken Wilber as Social Holons<sup>1</sup>\u2014is that membership is non-exclusive. That is, an individual agent can participate in multiple Social Organisms at once. This contrasts with Biological Holons (e.g., cells or mitochondria), whose parts typically belong to a single organism. Social Holons reflect the fluid, overlapping, and context-dependent nature of social identity and affiliation.</p> <p>Social Organisms are not merely large groups\u2014they are living holons: capable of acting, adapting, evolving, and participating in higher-order Social Organisms themselves. A canonical example is a corporation\u2014a persistent, governance-equipped AgentSpace that can form agreements and delegate authority to sub-agents.</p> <p>Other examples might include co-ops, intentional communities, DAOs, or bioregional networks.</p> <p>See also: AgentSpace, Exosphere, LifeCode, Agreement, Agent, Holon</p>"},{"location":"reference/glossary/#stewardship","title":"Stewardship","text":"<p>In the MAP, stewardship replaces \"ownership\" to describe the relationship between an AgentSpace and the Holons it is responsible for. Each Holon is stewarded by exactly one AgentSpace, though it may be referenced in many.</p> <p>Stewardship emphasizes care, consent, and accountability.</p>"},{"location":"reference/glossary/#uniform-api","title":"Uniform API","text":"<p>The Uniform API is the singular interface through which all interactions with the MAP take place. It is based on the metaphor of the Dance, framing every invocation \u2014 from data queries to service calls \u2014 as a shared, consensual interaction.</p> <p>At its core is the <code>dance()</code> function, which accepts a <code>DanceRequest</code> and returns a <code>DanceResponse</code>.</p> <ul> <li>The DanceRequest specifies:</li> <li>The Holon (or relationship) initiating the Dance</li> <li>Parameters for the action (e.g., queries, inputs, filters)</li> <li> <p>Optionally, an OpenCypher query \u2014 enabling expressive graph traversal and transformation</p> </li> <li> <p>The DanceResponse returns:</p> </li> <li>Results from the invocation (e.g., data, confirmation, computation)</li> <li>Updated state where appropriate</li> <li>Additional <code>DanceRequest</code> options (HATEOAS-style), revealing the next set of affordances available in the current state</li> </ul> <p>Because the MAP is knowledge-graph native, all interactions \u2014 including service calls, interface rendering, and value flows \u2014 are expressible as Dances across a dynamic graph of Holons.</p> <p>The Uniform API means every Holon interaction is symmetric, discoverable, and composable \u2014 turning the MAP into a danceable language of consent, action, and agency.</p>"},{"location":"reference/glossary/#vital-capital","title":"Vital Capital","text":"<p>A core MAP holon type representing the diverse forms of value that can flow between Agents \u2014 including knowledge, care, trust, materials, attention, and more. Vital Capital is what flows as a result of service invocations and fulfilled Promises. While not inherently scarce or commodified, each Vital Capital holon is definable, describable, and context-aware. When under the stewardship of a particular Agent, it may be treated as an Asset. The concept draws from multiple sources, including Context-Based Sustainability (McElroy), the Metacurrency Project (which defines wealth as \"the capacity to meet the needs of a living system\"), and the 8 Forms of Capital in permaculture theory.</p> <p>The MAP concept of Vital Capital refers to the many forms of value \u2014 not just financial \u2014 that flow through MAP Agreements. These include:</p> <p>draws heavily on the work around Context-Based Sustainability (see citation below) </p> Capital Type Description Natural Capital Ecosystem services, land, water, air, biodiversity Human Capital Skills, labor, knowledge, health, attention Social Capital Trust, reputation, relationships, group cohesion Cultural Capital Stories, rituals, symbols, traditions, identity Built Capital Tools, infrastructure, digital systems, physical assets Financial Capital Currency, tokens, credit, investments Experiential Capital Aesthetic, emotional, and lived experiences Memetic Capital Values, beliefs, narratives, memetic signatures Temporal Capital Time, availability, scheduling of attention or actions Spiritual Capital Purpose, presence, connection to meaning (optional but supported dimension) <ul> <li>Social capital</li> <li>Ecological contributions</li> <li>Attention, care, and creativity</li> <li>Knowledge and memetic resources</li> </ul> <p>Vital capital flows are explicitly tracked via Promises and Agreements.</p> <p>For more information: see  McElroy, M. W. (2008). Social Footprints: Measuring the Social Sustainability Performance of Organizations. Middlebury: Center for Sustainable Innovation. https://www.sustainableinnovation.org ResearchGate PDF</p>"},{"location":"reference/glossary/#visualizer","title":"Visualizer","text":"<p>A Visualizer is a Holon that describes how another Holon should be rendered and interacted with \u2014 in 2D, 3D, text, graph, gallery, immersive environment, or any other format.</p> <p>Visualizers are contributed to the Visualizer Commons and selected at runtime by DAHN based on: - The type of Holon - The preferences of the Agent viewing it - The popularity and contextual fit of available visualizers</p> <p>Every Holon can reference one or more Visualizers, allowing radically different renderings for different contexts \u2014 from dashboards to immersive journeys.</p> <p>A Visualizer is not just a UI component \u2014 it is a semantic lens, a votable style, and a participatory aesthetic contribution to the shared experience of the MAP. </p>"},{"location":"reference/glossary/#visualizer-commons","title":"Visualizer Commons","text":"<p>A federated network of stewarded sets of Visualizers. DAHN dynamically selects and configures visualizers from the Visualizer Commons to present and enable interaction with the MAP' self-describing, active Holons</p>"},{"location":"reference/glossary/#we-space","title":"We-Space","text":"<p>A We-Space is an AgentSpace viewed from the exterior perspective \u2014 how it participates within larger structures, how it exposes interfaces and affordances, and how it relates to other spaces.</p> <p>A Social Organism is always a We-Space, but not all We-Spaces are yet Social Organisms.</p> <ol> <li> <p>Wilber, Ken. Sex, Ecology, Spirituality: The Spirit of Evolution. Shambhala Publications, 1995.\u00a0\u21a9</p> </li> </ol>"}]}